                  2   $LIST
0000              4   
0000              5   ;  N76E003 pinout:
0000              6   ;                               -------
0000              7   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000              8   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000              9   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             10   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             11   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             12   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             13   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             14   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             15   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             16   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             17   ;                               -------
0000             18   ;
0000             19   
0000             20   CLK                 EQU 16600000                                                 ; Microcontroller system frequency in Hz
0000             21   BAUD                EQU 115200                                                   ; Baud rate of UART in bps
0000             22   TIMER1_RELOAD       EQU (0x100-(CLK/(16*BAUD)))
0000             23   TIMER0_RELOAD_1MS   EQU (0x10000-(CLK/1000))
0000             24   TIMER2_RATE              EQU 100                                                         ; 1/100 = 10ms
0000             25   TIMER2_RELOAD            EQU (65536-(CLK/(16*TIMER2_RATE)))
0000             26   
0000             27   org 0000H
0000 0205A5      28      ljmp Main
0003             29   
0003             30   ; /* TIMER2 ENABLE */
002B             31   org 0x002B
002B 020427      32            ljmp Timer2_ISR
002E             33   
002E             34   ;                     1234567890123456    <- This helps determine the location of the counter
002E 2A2A2A2A    35   test_message:     db '****LOADING*****', 0
     4C4F4144
     494E472A
     2A2A2A2A
     00
003F 54454D50    36   value_message:    db 'TEMP:      ', 0
     3A202020
     20202000
004B 43454C43    37   cel_message:       db 'CELCIUS  READING',0
     49555320
     20524541
     44494E47
     00
005C 46415245    38   fah_message:      db 'FARENHET READING',0
     4E484554
     20524541
     44494E47
     00
006D             39   
006D             40   CSEG
006D             41   
006D             42   ; /* PORT DEFINITIONS */
006D             43   LCD_RS equ P1.3
006D             44   LCD_E  equ P1.4
006D             45   LCD_D4 equ P0.0
006D             46   LCD_D5 equ P0.1
006D             47   LCD_D6 equ P0.2
006D             48   LCD_D7 equ P0.3
006D             49   OPAMP  equ P1.4                  ; Port 20 
006D             50   PWM_OUT equ P1.0
006D             51   START_BUTTON equ P0.4
006D             52   
                 54   	$LIST
0135             56   
0135             57   ; /* MATH.INC STUFFS */
0030             58   DSEG at 30H
0030             59   x:               ds 4
0034             60   y:               ds 4
0038             61   data_out:   ds 1
0039             62   
0039             63   bcd:             ds 5
003E             64   temp_out:        ds 4
0042             65   
0042             66   VLED_ADC: ds 2
0044             67   dtemp:  ds 2
0046             68   tempc: ds 1
0047             69   
0047             70   ; /* FSM STATES */
0047             71   FSM1_state:  ds 1
0048             72   
0048             73   ; /* TIME CHECK AND PWM */
0048             74   pwm_counter:     ds 1
0049             75   count10ms:               ds 1
004A             76   seconds:                 ds 1
004B             77   pwm:                     ds 1
004C             78   
004C             79   
004C             80   
0000             81   BSEG
0000             82   mf: dbit 1
0001             83   seconds_flag: dbit 1
0002             84   s_flag:          dbit 1
0003             85   
                546   $LIST
                 87   $LIST
03A5             89   
03A5             90   ; /* Configure the serial port and baud rate */
03A5             91   
03A5             92   InitAll:
03A5             93            ; /*** SERIAL PORT INITIALIZATION ***/
03A5             94   
03A5 75AC00      95            mov     P3M1,#0x00                      ; Configure all the pins for biderectional I/O
03A8 75AD00      96            mov     P3M2,#0x00
03AB 75B300      97            mov     P1M1,#0x00
03AE 75B400      98            mov     P1M2,#0x00
03B1 75B100      99            mov     P0M1,#0x00
03B4 75B200     100            mov     P0M2,#0x00
03B7            101       ; Since the reset button bounces, we need to wait a bit before
03B7            102       ; sending messages, otherwise we risk displaying gibberish!
03B7            103       ;mov R1, #200
03B7            104       ;mov R0, #104
03B7            105       ;djnz R0, $                                  ; 4 cycles->4*60.285ns*104=25us
03B7            106       ;djnz R1, $-4                                ; 25us*200=5.0ms
03B7 7A05       107       mov R2, #5
03B9 1204CF     108       lcall waitms
03BC            109       ; Now we can proceed with the configuration of the serial port
03BC 438E10     110            orl     CKCON, #0x10                    ; CLK is the input for timer 1
03BF 438780     111            orl     PCON, #0x80                     ; Bit SMOD=1, double baud rate
03C2 759852     112            mov     SCON, #0x52
03C5 53C4DF     113            anl     T3CON, #0b11011111
03C8 53890F     114            anl     TMOD, #0x0F                             ; Clear the configuration bits for timer 1
03CB 438920     115            orl     TMOD, #0x20                     ; Timer 1 Mode 2
03CE 758DF7     116            mov     TH1, #TIMER1_RELOAD
03D1 D28E       117            setb TR1
03D3            118   
03D3            119            ; /*** INITIALIZE THE REST ***/
03D3            120   
03D3 438E10     121            orl     CKCON, #0x10                    ; CLK is the input for timer 1
03D6 438780     122            orl     PCON, #0x80                     ; Bit SMOD=1, double baud rate
03D9 759852     123            mov     SCON, #0x52
03DC 53C4DF     124            anl     T3CON, #0b11011111
03DF 53890F     125            anl     TMOD, #0x0F                     ; Clear the configuration bits for timer 1
03E2 438920     126            orl     TMOD, #0x20                     ; Timer 1 Mode 2
03E5 758DF7     127            mov     TH1, #TIMER1_RELOAD     ; TH1=TIMER1_RELOAD;
03E8 D28E       128            setb TR1
03EA            129            
03EA            130            ; Using timer 0 for delay functions.  Initialize here:
03EA C28C       131            clr     TR0                                     ; Stop timer 0
03EC 438E08     132            orl     CKCON,#0x08                     ; CLK is the input for timer 0
03EF 5389F0     133            anl     TMOD,#0xF0                              ; Clear the configuration bits for timer 0
03F2 438901     134            orl     TMOD,#0x01                              ; Timer 0 in Mode 1: 16-bit timer
03F5            135            
03F5            136            ; Initialize the pin used by the ADC (P1.1) as input.
03F5 43B302     137            orl     P1M1, #0b00000010
03F8 53B4FD     138            anl     P1M2, #0b11111101
03FB            139            
03FB            140            ; Initialize and start the ADC:
03FB 53E8F0     141            anl ADCCON0, #0xF0
03FE 43E807     142            orl ADCCON0, #0x07                      ; Select channel 7
0401            143            ; AINDIDS select if some pins are analog inputs or digital I/O:
0401 75F600     144            mov AINDIDS, #0x00                      ; Disable all analog inputs
0404 43F680     145            orl AINDIDS, #0b10000000        ; P1.1 is analog input
0407 43E101     146            orl ADCCON1, #0x01                      ; Enable ADC
040A            147   
040A            148   ;----------------------------------------------------------------;
040A            149   ;                                        TIMER 2 INITIALIZATION
040A            150   ;----------------------------------------------------------------;
040A            151   
040A 75C800     152            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
040D 75CDD7     153            mov TH2, #high(TIMER2_RELOAD)
0410 75CC79     154            mov TL2, #low(TIMER2_RELOAD)
0413            155            ; Set the reload value
0413 75C9A0     156            mov T2MOD, #0b1010_0000 ; Enable timer 2 autoreload, and clock divider is 16
0416 75CBD7     157            mov RCMP2H, #high(TIMER2_RELOAD)
0419 75CA79     158            mov RCMP2L, #low(TIMER2_RELOAD)
041C            159            ; Init the free running 10 ms counter to zero
041C 754800     160            mov pwm_counter, #0
041F            161            ; Enable the timer and interrupts
041F 439B80     162            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0422 D2CA       163       setb TR2  ; Enable timer 2
0424            164   
0424 D2AF       165            setb EA ; Enable global interrupts
0426 22         166       ret
0427            167   
0427            168   ;---------------------------------;
0427            169   ; ISR for Timer 2                 ;
0427            170   ;---------------------------------;
0427            171   Timer2_ISR:
0427 C2CF       172            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
0429 C0D0       173            push psw
042B C0E0       174            push acc
042D            175            
042D 0548       176            inc pwm_counter
042F C3         177            clr c
0430 E54B       178            mov a, pwm
0432 9548       179            subb a, pwm_counter ; If pwm_counter <= pwm then c=1
0434 B3         180            cpl c
0435 9290       181            mov PWM_OUT, c
0437            182            
0437 E548       183            mov a, pwm_counter
0439 B46407     184            cjne a, #100, Timer2_ISR_done
043C 754800     185            mov pwm_counter, #0
043F 054A       186            inc seconds ; It is super easy to keep a seconds count here
0441 D202       187            setb s_flag
0443            188   
0443            189   Timer2_ISR_done:
0443 D0E0       190            pop acc
0445 D0D0       191            pop psw
0447 32         192            reti
0448            193   
0448            194   line1:
0448 50574D20   195            DB 'PWM Example     '
     4578616D
     706C6520
     20202020
0458 00         196            DB 0
0459            197   line2:
0459 43686B20   198            DB 'Chk pin 15:P1.0 '
     70696E20
     31353A50
     312E3020
0469 00         199            DB 0
046A            200   
046A            201   
046A            202   
046A            203   ; /* Send a character using the serial port */
046A            204   putchar:
046A 3099FD     205       jnb TI, putchar
046D C299       206       clr TI
046F F599       207       mov SBUF, a
0471 22         208       ret
0472            209   
0472            210   
0472            211   ; Send a constant-zero-terminated string using the serial port
0472            212   SendString:
0472 E4         213       clr A
0473 93         214       movc A, @A+DPTR
0474 6006       215       jz SendStringDone
0476 12046A     216       lcall putchar
0479 A3         217       inc DPTR
047A 80F6       218       sjmp SendString
047C            219   SendStringDone:
047C 22         220       ret
047D            221   
047D            222   ; Sends binary data to Python via putchar
047D            223   SendBin:                                         
047D E4         224            clr A                                   ; Sends temp_out
047E E53E       225            mov a, temp_out+0
0480 12046A     226            lcall putchar
0483 E4         227            clr A
0484 E53F       228            mov a, temp_out+1
0486 12046A     229            lcall putchar
0489 E4         230            clr A
048A E540       231            mov a, temp_out+2
048C 12046A     232            lcall putchar
048F E4         233            clr A
0490 E541       234            mov a, temp_out+3
0492 12046A     235            lcall putchar
0495            236   
0495 E4         237            clr A                                   ; Sends data_out
0496 E538       238            mov a, data_out 
0498 12046A     239            lcall putchar
049B 22         240            ret
049C            241   
049C            242   ASCII_CHAR: 
049C 30313233   243            db '0123456789ABCDEF'
     34353637
     38394142
     43444546
04AC            244   
04AC            245   Hello_World:
04AC 48656C6C   246       DB  'Hello, World!', '\r', '\n', 0
     6F2C2057
     6F726C64
     210D0A00
04BC            247   New_Line:
04BC 0D0A00     248            DB '\r', '\n', 0
04BF            249   
04BF            250   ; /* 1ms DELAY FUNCTIONS */
04BF            251   wait_1ms:
04BF C28C       252            clr     TR0 ; Stop timer 0
04C1 C28D       253            clr     TF0 ; Clear overflow flag
04C3 758CBF     254            mov     TH0, #high(TIMER0_RELOAD_1MS)
04C6 758A28     255            mov     TL0,#low(TIMER0_RELOAD_1MS)
04C9 D28C       256            setb TR0
04CB 308DFD     257            jnb     TF0, $ ; Wait for overflow
04CE 22         258            ret
04CF            259   waitms:
04CF 1204BF     260            lcall wait_1ms
04D2 DAFB       261            djnz R2, waitms
04D4 22         262            ret
04D5            263   
04D5            264   Display_formated_BCD: ;4 dig 
04D5 C0E0       265            push acc
04D7 7401       265            mov a, #1
04D9 14         265            dec a
04DA 120107     265            lcall ?Set_Cursor_1 ; Select column and row
04DD D0E0       265            pop acc
04DF C083       266            push dph
04E1 C082       266            push dpl
04E3 C0E0       266            push acc
04E5 90004B     266            mov dptr, #cel_message
04E8 1200FA     266            lcall ?Send_Constant_String
04EB D0E0       266            pop acc
04ED D082       266            pop dpl
04EF D083       266            pop dph
04F1 C0E0       267            push acc
04F3 7407       267            mov a, #7
04F5 14         267            dec a
04F6 120105     267            lcall ?Set_Cursor_2 ; Select column and row
04F9 D0E0       267            pop acc
04FB            267   
04FB C000       268            push ar0
04FD A83B       268            mov r0, bcd+2
04FF 12010C     268            lcall ?Display_BCD
0502 D000       268            pop ar0
0504 C0E0       269            push acc
0506 7409       269            mov a, #9
0508 14         269            dec a
0509 120105     269            lcall ?Set_Cursor_2 ; Select column and row
050C D0E0       269            pop acc
050E C000       270            push ar0
0510 A83A       270            mov r0, bcd+1
0512 12010C     270            lcall ?Display_BCD
0515 D000       270            pop ar0
0517 C0E0       271            push acc
0519 740A       271            mov a, #10
051B 14         271            dec a
051C 120105     271            lcall ?Set_Cursor_2 ; Select column and row
051F D0E0       271            pop acc
0521 C000       272            push ar0
0523 A83A       272            mov r0, bcd+1
0525 12010C     272            lcall ?Display_BCD
0528 D000       272            pop ar0
052A            273            
052A C0E0       274            push acc
052C 740C       274            mov a, #12
052E 14         274            dec a
052F 120105     274            lcall ?Set_Cursor_2 ; Select column and row
0532 D0E0       274            pop acc
0534 C000       275            push ar0
0536 A839       275            mov r0, bcd+0
0538 12010C     275            lcall ?Display_BCD
053B D000       275            pop ar0
053D C0E0       276            push acc
053F 740A       276            mov a, #10
0541 14         276            dec a
0542 120105     276            lcall ?Set_Cursor_2 ; Select column and row
0545 D0E0       276            pop acc
0547 C0E0       277            push acc
0549 742E       277            mov a, #'.'
054B 1200BD     277            lcall ?WriteData
054E D0E0       277            pop acc
0550 C0E0       278            push acc
0552 7407       278            mov a, #7
0554 14         278            dec a
0555 120105     278            lcall ?Set_Cursor_2 ; Select column and row
0558 D0E0       278            pop acc
055A C0E0       279            push acc
055C 7420       279            mov a, #0x20
055E 1200BD     279            lcall ?WriteData
0561 D0E0       279            pop acc
0563 C0E0       280            push acc
0565 740F       280            mov a, #15
0567 14         280            dec a
0568 120105     280            lcall ?Set_Cursor_2 ; Select column and row
056B D0E0       280            pop acc
056D C0E0       281            push acc
056F 74DF       281            mov a, #0xDF
0571 1200BD     281            lcall ?WriteData
0574 D0E0       281            pop acc
0576 C0E0       282            push acc
0578 7410       282            mov a, #16
057A 14         282            dec a
057B 120105     282            lcall ?Set_Cursor_2 ; Select column and row
057E D0E0       282            pop acc
0580 C0E0       283            push acc
0582 7443       283            mov a, #'C'
0584 1200BD     283            lcall ?WriteData
0587 D0E0       283            pop acc
0589            284   
0589 22         285            ret
058A            286   
058A            287   ; /* READ ADC */
058A            288   Read_ADC:
058A C2EF       289            clr ADCF
058C D2EE       290            setb ADCS ;  ADC start trigger signal
058E 30EFFD     291       jnb ADCF, $ ; Wait for conversion complete
0591            292       
0591            293       ; Read the ADC result and store in [R1, R0]
0591 E5C2       294       mov a, ADCRL
0593 540F       295       anl a, #0x0f
0595 F8         296       mov R0, a
0596 E5C3       297       mov a, ADCRH   
0598 C4         298       swap a
0599 C0E0       299       push acc
059B 540F       300       anl a, #0x0f
059D F9         301       mov R1, a
059E D0E0       302       pop acc
05A0 54F0       303       anl a, #0xf0
05A2 48         304       orl a, R0
05A3 F8         305       mov R0, A
05A4 22         306            ret
05A5            307   
05A5            308   Main:
05A5 75817F     309       mov SP, #0x7F ; Set the stack pointer to the begining of idata
05A8            310       
05A8 1203A5     311       lcall InitAll
05AB 1200C7     312       lcall LCD_4BIT
05AE            313   
05AE            314            ; Initialize all variables
05AE D201       315            setb seconds_flag
05B0 754700     316            mov FSM1_state, #0
05B3 754A00     317            mov seconds, #0
05B6            318   
05B6            319       ; initial messages in LCD
05B6            320            ;Set_Cursor(1, 1)
05B6            321       ;Send_Constant_String(#test_message)
05B6            322            ;Set_Cursor(2, 1)
05B6            323       ;Send_Constant_String(#value_message)
05B6            324   
05B6 C0E0       325            push acc
05B8 7401       325            mov a, #1
05BA 14         325            dec a
05BB 120107     325            lcall ?Set_Cursor_1 ; Select column and row
05BE D0E0       325            pop acc
05C0 900448     326            mov dptr, #Line1
05C3 1200FA     327            lcall ?Send_Constant_String
05C6 C0E0       328            push acc
05C8 7401       328            mov a, #1
05CA 14         328            dec a
05CB 120105     328            lcall ?Set_Cursor_2 ; Select column and row
05CE D0E0       328            pop acc
05D0 900459     329            mov dptr, #Line2
05D3 1200FA     330            lcall ?Send_Constant_String
05D6            331   
05D6 754B14     332            mov pwm, #20
05D9            333   
05D9 753801     334            mov data_out, #0b00000001
05DC            335   
05DC            336   ;Forever: ;avaliable: r2, r3
05DC            337   FSM_sys:
05DC            338   
05DC            339            ; /* CALIBRATE */ 
05DC 53E8F0     340            anl ADCCON0, #0xF0 ; Read the 2.08V LED voltage connected to AIN0 on pin 6
05DF 43E800     341            orl ADCCON0, #0x00 ; Select channel 0
05E2 12058A     342       lcall Read_ADC
05E5            343       
05E5 8842       344            mov VLED_ADC+0, R0 ; Save result for later use
05E7 8943       345            mov VLED_ADC+1, R1
05E9            346   
05E9 53E8F0     347            anl ADCCON0, #0xF0 ; Read the signal connected to AIN7
05EC 43E807     348            orl ADCCON0, #0x07 ; Select channel 7
05EF 12058A     349            lcall Read_ADC
05F2            350   
05F2            351   Celcius: 
05F2 8830       352            mov x+0, R0                     ; x <- adc(ch) 
05F4 8931       353            mov x+1, R1
05F6 753200     354            mov x+2, #0                     ; pad w/0
05F9 753300     355            mov x+3, #0
05FC 753498     356            mov y+0, #low (207000 % 0x10000) 
05FF 753528     356            mov y+1, #high(207000 % 0x10000) 
0602 753603     356            mov y+2, #low (207000 / 0x10000) 
0605 753700     356            mov y+3, #high(207000 / 0x10000)                        ; y <- (x.xxx (vled) * 1000) * 100
0608 1202AF     357            lcall mul32                             
060B 854234     358       mov y+0, VLED_ADC+0          ; y <- adc(led)
060E 854335     359            mov y+1, VLED_ADC+1
0611 753600     360            mov y+2, #0                     
0614 753700     361            mov y+3, #0 
0617 12033C     362            lcall div32                             ; x <- adc(ch) * vled * 100 / adc(led)
061A 7534FE     363            mov y+0, #low (273150 % 0x10000) 
061D 75352A     363            mov y+1, #high(273150 % 0x10000) 
0620 753604     363            mov y+2, #low (273150 / 0x10000) 
0623 753700     363            mov y+3, #high(273150 / 0x10000)                        ; y <- (2.7315 * 1000) * 100
0626 12021B     364            lcall sub32     
0629            365   
0629 120135     366            lcall hex2bcd                   ; Convert to BCD and display
062C 1204D5     367            lcall Display_formated_BCD
062F 1201BE     368       lcall bcd2hex                        ;hex number now stored in x                     
0632            369   
0632            370   Export:                                                  ; Data export to python
0632 7AFA       371            mov R2, #250                            ; Wait 500 ms between conversions
0634 1204CF     372            lcall waitms
0637 7AFA       373            mov R2, #250
0639 1204CF     374            lcall waitms
063C            375   
063C            376            ;mov dptr, #x
063C 12047D     377       lcall SendBin
063F            378            ;mov dptr, #New_Line
063F            379            ;lcall SendString
063F            380       ;ljmp Forever
063F            381   
063F            382            ; /* FSM1 STATE CHANGE CONTROLS */
063F 020642     383            ljmp FSM1
0642            384   
0642            385   
0642            386   FSM1:
0642 E547       387            mov a, FSM1_state
0644            388   
0644            389   
0644            390   FSM1_state0:
0644 B40011     391            cjne a, #0, FSM1_state1 ; if FSM1_state (currently stored in a) is not equal to zero (ie. state zero), go to state 1
0647 754B00     392            mov pwm, #0
064A C201       393            clr seconds_flag
064C            394            ; check for push button input
064C 208406     395            jb START_BUTTON, FSM1_state0_done
064F 3084FD     396            jnb START_BUTTON, $ ; Wait for key release
0652 754701     397            mov FSM1_state, #1
0655            398   
0655            399   FSM1_state0_done:
0655 0205DC     400            ljmp FSM_sys
0658            401   
0658            402   FSM1_state1:
0658 B40113     403            cjne a, #1, FSM1_state2
065B 754B64     404            mov pwm, #100
065E 754A00     405            mov seconds, #0
0661 7496       406            mov a, #150
0663 C3         407            clr c
0664 9546       408            subb a, tempc
0666 5003       409            jnc FSM1_state1_done
0668 754702     410            mov FSM1_state, #2
066B            411   
066B            412   FSM1_state1_done:
066B 0205DC     413            ljmp FSM_sys
066E            414   
066E            415   FSM1_state2:
066E B40220     416            cjne a, #2, FSM1_state3
0671 754B14     417            mov pwm, #20
0674 30010F     418            jnb seconds_flag, FSM_state2_funk
0677 E4         419            clr a
0678 F54A       420            mov seconds, a
067A 743C       421            mov a, #60
067C C3         422            clr c
067D 954A       423            subb a, seconds
067F 7447       424            mov a, #FSM1_state
0681 500B       425            jnc FSM1_state2_done
0683 754703     426            mov FSM1_state, #3
0686            427   
0686            428   FSM_state2_funk:
0686 754A00     429            mov seconds, #0         ; Set seconds so we can count up to the required time 
0689 D201       430            setb seconds_flag       ; seconds flag so we don't reset seconds_flag multiple times
068B 02066E     431            ljmp FSM1_state2        
068E            432   
068E            433   FSM1_state2_done:
068E 0205DC     434            ljmp FSM_sys
0691            435   
0691            436   FSM1_state3:
0691 B40312     437            cjne a, #3, FSM1_state4
0694 754B64     438            mov pwm, #100
0697 74DC       439            mov a, #220
0699 C201       440            clr seconds_flag
069B C3         441            clr c
069C 9546       442            subb a, tempc
069E 5003       443            jnc FSM1_state3_done
06A0 754704     444            mov FSM1_state, #4
06A3            445   
06A3            446   FSM1_state3_done:
06A3 0205DC     447            ljmp FSM_sys
06A6            448   
06A6            449   FSM1_state4:
06A6 B40412     450            cjne a, #4, FSM1_state5
06A9 754B14     451            mov pwm, #20 
06AC 300101     452            jnb seconds_flag, FSM1_state4_funk
06AF C3         453            clr c 
06B0            454   
06B0            455   FSM1_state4_funk:
06B0 754A00     456            mov seconds, #0
06B3 D201       457            setb seconds_flag
06B5 0206A6     458            ljmp FSM1_state4
06B8            459   
06B8            460   FSM1_state4_done:
06B8 0205DC     461            ljmp FSM_sys
06BB            462   
06BB            463   FSM1_state5:
06BB 754B00     464            mov pwm, #0
06BE 743C       465            mov a, #60
06C0 C3         466            clr c
06C1 9546       467            subb a, tempc
06C3 4003       468            jc FSM1_state5_done
06C5 754700     469            mov FSM1_state, #0
06C8            470   
06C8            471   FSM1_state5_done:
06C8 0205DC     472            ljmp FSM_sys
06CB            473   
06CB            474   END
