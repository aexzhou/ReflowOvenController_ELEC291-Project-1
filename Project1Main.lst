                  2   $LIST
0000              4   
0000              5   ;  N76E003 pinout:
0000              6   ;                               -------
0000              7   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000              8   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000              9   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             10   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             11   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             12   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             13   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             14   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             15   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             16   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             17   ;                               -------
0000             18   ;
0000             19   
0000             20   CLK                 EQU 16600000                                                 ; Microcontroller system frequency in Hz
0000             21   BAUD                EQU 115200                                                   ; Baud rate of UART in bps
0000             22   TIMER1_RELOAD       EQU (0x100-(CLK/(16*BAUD)))
0000             23   TIMER0_RELOAD_1MS   EQU (0x10000-(CLK/1000))
0000             24   TIMER2_RATE              EQU 100                                                         ; 1/100 = 10ms
0000             25   TIMER2_RELOAD            EQU (65536-(CLK/(16*TIMER2_RATE)))
0000             26   GAIN                             EQU 25
0000             27   ;V2C_DIVISOR                     EQU (GAIN*41)
0000             28   V2C_DIVISOR                      EQU 1051
0000             29   
0000             30   ; /*** PORT DEFINITIONS ***/
0000             31   LCD_RS                   equ P1.3
0000             32   LCD_E                    equ P1.4
0000             33   LCD_D4                   equ P0.0
0000             34   LCD_D5                   equ P0.1
0000             35   LCD_D6                   equ P0.2
0000             36   LCD_D7                   equ P0.3
0000             37   PWM_OUT                  equ P1.0
0000             38   START_BUTTON     equ P0.4
0000             39   ; Analog Input Port Numbering
0000             40   LED_PORT                 equ 0x00                        ; AIN port numbers
0000             41   LM335_PORT               equ 0x05
0000             42   OPAMP_PORT               equ 0x07
0000             43   AINCONFIG                equ 0b10100001          ; bits 1 = toggled analog in
0000             44   
0000             45   ; /*** VECTORS ***/
0000             46   org 0000H
0000 023A84      47            ljmp Main
0003             48   
002B             49   org 002BH                                        ; timer 2 enable
002B 02382E      50            ljmp Timer2_ISR
002E             51   
3000             52   org 3000H                                        ; lookup table stored at APROM address starting 0x4000
3000             53   ;        $NOLIST
                 -1    	$include(thermodata.inc)
3000              1   ; Contains mV offset for Thermocouple
3000              2   ; Stored in APROM location: 0x3000
3000              3   thermodata:
3000 00000027     4       DW  0, 39, 79, 119, 158, 198, 238, 277, 317, 357, 397, 437, 477, 517, 557, 597 
     004F0077
     009E00C6
     00EE0115
     013D0165
     018D01B5
     01DD0205
     022D0255
3020 027D02A5     5       DW  637, 677, 718, 758, 798, 838, 879, 919, 960, 1000, 1041, 1081, 1122, 1163, 1203, 1244
     02CE02F6
     031E0346
     036F0397
     03C003E8
     04110439
     0462048B
     04B304DC
3040 0505052E     6       DW  1285, 1326, 1366, 1407, 1448, 1489, 1530, 1571, 1612, 1653, 1694, 1735, 1776, 1817, 1858, 1899
     0556057F
     05A805D1
     05FA0623
     064C0675
     069E06C7
     06F00719
     0742076B
3060 079507BE     7       DW  1941, 1982, 2023, 2064, 2106, 2147, 2188, 2230, 2271, 2312, 2354, 2395, 2436, 2478, 2519, 2561 
     07E70810
     083A0863
     088C08B6
     08DF0908
     0932095B
     098409AE
     09D70A01
3080 0A2A0A54     8       DW  2602, 2644, 2685, 2727, 2768, 2810, 2851, 2893, 2934, 2976, 3017, 3059, 3100, 3142, 3184, 3225
     0A7D0AA7
     0AD00AFA
     0B230B4D
     0B760BA0
     0BC90BF3
     0C1C0C46
     0C700C99
30A0 0CC30CEC     9       DW  3267, 3308, 3350, 3391, 3433, 3474, 3516, 3557, 3599, 3640, 3682, 3723, 3765, 3806, 3848, 3889 
     0D160D3F
     0D690D92
     0DBC0DE5
     0E0F0E38
     0E620E8B
     0EB50EDE
     0F080F31
30C0 0F5B0F84    10       DW  3931, 3972, 4013, 4055, 4096, 4138, 4179, 4220, 4262, 4303, 4344, 4385, 4427, 4468, 4509, 4550 
     0FAD0FD7
     1000102A
     1053107C
     10A610CF
     10F81121
     114B1174
     119D11C6
30E0 11EF1219    11       DW  4591, 4633, 4674, 4715, 4756, 4797, 4838, 4879, 4920, 4961, 5002, 5043, 5084, 5124, 5165, 5206
     1242126B
     129412BD
     12E6130F
     13381361
     138A13B3
     13DC1404
     142D1456
3100 147F14A8    12       DW  5247, 5288, 5328, 5369, 5410, 5450, 5491, 5532, 5572, 5613, 5653, 5694, 5735, 5775, 5815, 5856
     14D014F9
     1522154A
     1573159C
     15C415ED
     1615163E
     1667168F
     16B716E0
3120 17081731    13       DW  5896, 5937, 5977, 6017, 6058, 6098, 6138, 6179, 6219, 6259, 6299, 6339, 6380, 6420, 6460, 6500
     17591781
     17AA17D2
     17FA1823
     184B1873
     189B18C3
     18EC1914
     193C1964
3140 198C19B4    14       DW  6540, 6580, 6620, 6660, 6701, 6741, 6781, 6821, 6861, 6901, 6941, 6981, 7021, 7060, 7100, 7140
     19DC1A04
     1A2D1A55
     1A7D1AA5
     1ACD1AF5
     1B1D1B45
     1B6D1B94
     1BBC1BE4
3160 1C0C1C34    15       DW  7180, 7220, 7260, 7300, 7340, 7380, 7420, 7460, 7500, 7540, 7579, 7619, 7659, 7699, 7739, 7779
     1C5C1C84
     1CAC1CD4
     1CFC1D24
     1D4C1D74
     1D9B1DC3
     1DEB1E13
     1E3B1E63
3180 1E8B1EB3    16       DW  7819, 7859, 7899, 7939, 7979, 8019, 8059, 8099, 8138, 8178, 8218, 8258, 8298, 8338, 8378, 8418
     1EDB1F03
     1F2B1F53
     1F7B1FA3
     1FCA1FF2
     201A2042
     206A2092
     20BA20E2
31A0 210A2133    17       DW  8458, 8499, 8539, 8579, 8619, 8659, 8699, 8739, 8779, 8819, 8860, 8900, 8940, 8980, 9020, 9061
     215B2183
     21AB21D3
     21FB2223
     224B2273
     229C22C4
     22EC2314
     233C2365
31C0 238D23B5    18       DW  9101, 9141, 9181, 9222, 9262, 9302, 9343, 9383, 9423, 9464, 9504, 9545, 9585, 9626, 9666, 9707
     23DD2406
     242E2456
     247F24A7
     24CF24F8
     25202549
     2571259A
     25C225EB
31E0 2613263C    19       DW  9747, 9788, 9828, 9869, 9909, 9950, 9991, 10031, 10072, 10113, 10153, 10194, 10235, 10276, 10316, 10357 
     2664268D
     26B526DE
     2707272F
     27582781
     27A927D2
     27FB2824
     284C2875
3200 289E28C7    20       DW  10398, 10439, 10480, 10520, 10561, 10602, 10643, 10684, 10725, 10766, 10807, 10848, 10889, 10930, 10971, 11012 
     28F02918
     2941296A
     299329BC
     29E52A0E
     2A372A60
     2A892AB2
     2ADB2B04
3220 2B2D2B56    21       DW  11053, 11094, 11135, 11176, 11217, 11259, 11300, 11341, 11382, 11423, 11465, 11506, 11547, 11588, 11630, 11671
     2B7F2BA8
     2BD12BFB
     2C242C4D
     2C762C9F
     2CC92CF2
     2D1B2D44
     2D6E2D97
3240 2DC02DE9    22       DW  11712, 11753, 11795, 11836, 11877, 11919, 11960, 12001, 12043, 12084, 12126, 12167, 12209, 12250, 12291, 12333
     2E132E3C
     2E652E8F
     2EB82EE1
     2F0B2F34
     2F5E2F87
     2FB12FDA
     3003302D
3260 30563080    23       DW  12374, 12416, 12457, 12499, 12540, 12582, 12624
     30A930D3
     30FC3126
     3150
326E             24   
326E             55   ;        $List
326E             56   
326E             57   ; /*** DIRECT ACCESS VARIABLES @RAM 0x30 -> 0x7F ***/
0030             58   DSEG at 30H
0030             59   x:                       ds 4            ; for math
0034             60   y:                       ds 4
0038             61   data_out:        ds 4            ; for python
003C             62   bcd:                     ds 5            ; for display
0041             63   
0041             64   VLED_ADC:                ds 2            ; for temperature 
0043             65   dtemp:                   ds 2
0045             66   tempc:                   ds 1
0046             67   temp_mc:                 ds 4
004A             68   OPAMP_temp:      ds 4
004E             69   temp_lm:                 ds 4
0052             70   temp_offset:     ds 2
0054             71   mV_offset:       ds 2
0056             72   
0056             73   FSM1_state:      ds 1            ; fsm states
0057             74   
0057             75   pwm_counter:     ds 1            ; time check and pwm
0058             76   count10ms:               ds 1
0059             77   seconds:                 ds 1
005A             78   pwm:                     ds 1
005B             79   abort_time:              ds 1
005C             80   
005C             81   ReflowTemp:      ds 1            ; reflow profile parameters
005D             82   ReflowTime:              ds 1
005E             83   SoakTime:                ds 1
005F             84   
005F             85   Val_test:                ds 4
0063             86   Val_temp:                ds 4
0067             87   
0067             88   ; /*** SINGLE BIT VARIABLES @RAM 0x20 -> 0x2F ***/
0000             89   BSEG 
0000             90   mf:                      dbit 1
0001             91   seconds_flag:    dbit 1
0002             92   s_flag:                  dbit 1
0003             93   
0003             94   ; /*** CODE SEGMENT ***/
326E             95   CSEG
326E             96   ;                     1234567890123456    <- This helps determine the location of the counter
326E 2A2A2A2A    97   test_message:     db '****LOADING*****', 0
     4C4F4144
     494E472A
     2A2A2A2A
     00
327F 54454D50    98   value_message:    db 'TEMP:           ', 0
     3A202020
     20202020
     20202020
     00
3290 4F56454E    99   temp_message:      db 'OVEN TEMP:      ', 0
     2054454D
     503A2020
     20202020
     00
32A1 46415245   100   fah_message:      db 'FARENHET READING', 0
     4E484554
     20524541
     44494E47
     00
32B2 41424F52   101   abort_message:     db 'ABORTABORTABORT ', 0
     5441424F
     52544142
     4F525420
     00
32C3 43757272   102   state_message:     db 'Current State:  ', 0
     656E7420
     53746174
     653A2020
     00
32D4 53746174   103   error_message:     db 'State Error     ', 0
     65204572
     726F7220
     20202020
     00
32E5            104   
33DA            122   $LIST
                546   $LIST
37A9            141   $LIST
                108   $LIST
37A9            110   
37A9            111   
37A9            112   InitAll:
37A9            113            ; /*** SERIAL PORT INITIALIZATION ***/
37A9 75AC00     114            mov     P3M1,#0x00                      ; Configure all the pins for biderectional I/O
37AC 75AD00     115            mov     P3M2,#0x00
37AF 75B300     116            mov     P1M1,#0x00
37B2 75B400     117            mov     P1M2,#0x00
37B5 75B100     118            mov     P0M1,#0x00
37B8 75B200     119            mov     P0M2,#0x00
37BB            120       ; Since the reset button bounces, we need to wait a bit before
37BB            121       ; sending messages, otherwise we risk displaying gibberish!
37BB            122       ;mov R1, #200
37BB            123       ;mov R0, #104
37BB            124       ;djnz R0, $                                  ; 4 cycles->4*60.285ns*104=25us
37BB            125       ;djnz R1, $-4                                ; 25us*200=5.0ms
37BB 7A05       126       mov R2, #5
37BD 123913     127       lcall waitms
37C0            128       ; Now we can proceed with the configuration of the serial port
37C0 438E10     129            orl     CKCON, #0x10                    ; CLK is the input for timer 1
37C3 438780     130            orl     PCON, #0x80                     ; Bit SMOD=1, double baud rate
37C6 759852     131            mov     SCON, #0x52
37C9 53C4DF     132            anl     T3CON, #0b11011111
37CC 53890F     133            anl     TMOD, #0x0F                             ; Clear the configuration bits for timer 1
37CF 438920     134            orl     TMOD, #0x20                     ; Timer 1 Mode 2
37D2 758DF7     135            mov     TH1, #TIMER1_RELOAD
37D5 D28E       136            setb TR1
37D7            137   
37D7            138            ; /*** INITIALIZE THE REST ***/
37D7 438E10     139            orl     CKCON, #0x10                    ; CLK is the input for timer 1
37DA 438780     140            orl     PCON, #0x80                     ; Bit SMOD=1, double baud rate
37DD 759852     141            mov     SCON, #0x52
37E0 53C4DF     142            anl     T3CON, #0b11011111
37E3 53890F     143            anl     TMOD, #0x0F                     ; Clear the configuration bits for timer 1
37E6 438920     144            orl     TMOD, #0x20                     ; Timer 1 Mode 2
37E9 758DF7     145            mov     TH1, #TIMER1_RELOAD     ; TH1=TIMER1_RELOAD;
37EC D28E       146            setb TR1
37EE            147            
37EE            148            ; Using timer 0 for delay functions.  Initialize here:
37EE C28C       149            clr     TR0                                     ; Stop timer 0
37F0 438E08     150            orl     CKCON,#0x08                     ; CLK is the input for timer 0
37F3 5389F0     151            anl     TMOD,#0xF0                              ; Clear the configuration bits for timer 0
37F6 438901     152            orl     TMOD,#0x01                              ; Timer 0 in Mode 1: 16-bit timer
37F9            153            
37F9            154            ; Initialize the pin used by the ADC (P1.1) as input.
37F9 43B302     155            orl     P1M1, #0b00000010
37FC 53B4FD     156            anl     P1M2, #0b11111101
37FF            157            
37FF            158            ; Initialize and start the ADC:
37FF 53E8F0     159            anl ADCCON0, #0xF0
3802 43E807     160            orl ADCCON0, #0x07                      ; Select channel 7
3805            161            ; AINDIDS select if some pins are analog inputs or digital I/O:
3805 75F600     162            mov AINDIDS, #0x00                      ; Disable all analog inputs
3808 43F640     163            orl AINDIDS, #0b1000000         ; P1.1 is analog input
380B 43E101     164            orl ADCCON1, #0x01                      ; Enable ADC
380E 755200     165            mov temp_offset, #0x00
3811            166   
3811            167   
3811            168   ;----------------------------------------------------------------;
3811            169   ;                                        TIMER 2 INITIALIZATION
3811            170   ;----------------------------------------------------------------;
3811            171   
3811 75C800     172            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
3814 75CDD7     173            mov TH2, #high(TIMER2_RELOAD)
3817 75CC79     174            mov TL2, #low(TIMER2_RELOAD)
381A            175            ; Set the reload value
381A 75C9A0     176            mov T2MOD, #0b1010_0000 ; Enable timer 2 autoreload, and clock divider is 16
381D 75CBD7     177            mov RCMP2H, #high(TIMER2_RELOAD)
3820 75CA79     178            mov RCMP2L, #low(TIMER2_RELOAD)
3823            179            ; Init the free running 10 ms counter to zero
3823 755700     180            mov pwm_counter, #0
3826            181            ; Enable the timer and interrupts
3826 439B80     182            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
3829 D2CA       183       setb TR2  ; Enable timer 2
382B            184   
382B D2AF       185            setb EA ; Enable global interrupts
382D 22         186       ret
382E            187   
382E            188   
382E            189   ;---------------------------------;
382E            190   ; ISR for Timer 2                 ;
382E            191   ;---------------------------------;
382E            192   Timer2_ISR:
382E C2CF       193            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
3830 C0D0       194            push psw
3832 C0E0       195            push acc
3834            196            
3834 0557       197            inc pwm_counter
3836 C3         198            clr c
3837 E55A       199            mov a, pwm
3839 9557       200            subb a, pwm_counter ; If pwm_counter <= pwm then c=1
383B B3         201            cpl c
383C 9290       202            mov PWM_OUT, c
383E            203            
383E E557       204            mov a, pwm_counter
3840 B46432     205            cjne a, #100, Timer2_ISR_done
3843            206            ; executes every second
3843 755700     207            mov pwm_counter, #0
3846 0559       208            inc seconds ; It is super easy to keep a seconds count here
3848 D202       209            setb s_flag
384A E556       210            mov a, FSM1_state
384C B40003     211            cjne a, #0, Abort_Check0                        ; For abort check, the abort should not trigger if you are in state 0
384F 023875     212            ljmp Timer2_ISR_done
3852            213   
3852            214   Abort_Check0:
3852            215   ; Check if temperature is above 240. If so, abort
3852 C3         216            clr c
3853 E545       217            mov a, tempc
3855 94F0       218            subb a, #240                                            ; if a is greater than 240, there will be no carry bit so we need to abort
3857 4006       219            jc Abort_Check1                                                 ; if temperature is below 240, continue to next check
3859            220            ; abort routine
3859 75560A     221            mov FSM1_state, #10
385C 023875     222       ljmp Timer2_ISR_done                ; if temp is above 240, abort condition has already been triggered, skip ahead to done
385F            223   
385F            224   Abort_Check1:
385F            225   ; Check if temperature is below 50. If so, check for how long
385F E545       226            mov a, tempc
3861 C3         227            clr c
3862 9432       228            subb a, #50                                                     ; if tempc (stored in a) is less than 50, there will be a carry bit
3864 500C       229            jnc Timer2_ISR_abort_done                       ; skip the abort checks if temperature is above 50
3866            230   
3866            231   Abort_Check2:
3866            232   ; Check if has been 60 seconds (at below 50 degrees)
3866 055B       233            inc abort_time
3868 E55B       234            mov a, abort_time
386A C3         235            clr c
386B 943C       236            subb a, #60                                                     ; if abort_time is less than 60, there will be a carry bit
386D 5006       237            jnc Timer2_ISR_done                                     ; if there is a carry 
386F 75560A     238            mov FSM1_state, #10
3872            239   
3872            240   Timer2_ISR_abort_done:
3872 755B00     241            mov abort_time, #0
3875            242   
3875            243   Timer2_ISR_done:
3875 D0E0       244            pop acc
3877 D0D0       245            pop psw
3879 32         246            reti
387A            247   
387A            248   line1:
387A 50574D20   249            DB 'PWM Example     '
     4578616D
     706C6520
     20202020
388A 00         250            DB 0
388B            251   line2:
388B 43686B20   252            DB 'Chk pin 15:P1.0 '
     70696E20
     31353A50
     312E3020
389B 00         253            DB 0
389C            254   
389C            255   ; /* Send a character using the serial port */
389C            256   putchar:
389C 3099FD     257       jnb TI, putchar
389F C299       258       clr TI
38A1 F599       259       mov SBUF, a
38A3 22         260       ret
38A4            261   
38A4            262   ; Send a constant-zero-terminated string using the serial port
38A4            263   SendString:
38A4 E4         264       clr A
38A5 93         265       movc A, @A+DPTR
38A6 6006       266       jz SendStringDone
38A8 12389C     267       lcall putchar
38AB A3         268       inc DPTR
38AC 80F6       269       sjmp SendString
38AE            270   SendStringDone:
38AE 22         271       ret
38AF            272   
38AF            273   ; Sends binary data to Python via putchar
38AF            274   SendBin:                                         
38AF E4         275            clr A                                   ; Sends temp_mc
38B0 E546       276            mov a, temp_mc+0
38B2 12389C     277            lcall putchar
38B5 E4         278            clr A
38B6 E547       279            mov a, temp_mc+1
38B8 12389C     280            lcall putchar
38BB E4         281            clr A
38BC E548       282            mov a, temp_mc+2
38BE 12389C     283            lcall putchar
38C1 E4         284            clr A
38C2 E549       285            mov a, temp_mc+3
38C4 12389C     286            lcall putchar
38C7            287   
38C7 E4         288            clr A                                   ; Sends data_out
38C8 E538       289            mov a, data_out+0
38CA 12389C     290            lcall putchar
38CD E4         291            clr A
38CE E539       292            mov a, data_out+1
38D0 12389C     293            lcall putchar
38D3 E4         294            clr A                                   ; Sends data_out
38D4 E53A       295            mov a, data_out+2
38D6 12389C     296            lcall putchar
38D9 E4         297            clr A
38DA E53B       298            mov a, data_out+3
38DC 12389C     299            lcall putchar
38DF 22         300            ret
38E0            301   
38E0            302   ASCII_CHAR: 
38E0 30313233   303            db '0123456789ABCDEF'
     34353637
     38394142
     43444546
38F0            304   
38F0            305   Hello_World:
38F0 48656C6C   306       DB  'Hello, World!', '\r', '\n', 0
     6F2C2057
     6F726C64
     210D0A00
3900            307   New_Line:
3900 0D0A00     308            DB '\r', '\n', 0
3903            309   
3903            310   ; /* 1ms DELAY FUNCTIONS */
3903            311   wait_1ms:
3903 C28C       312            clr     TR0 ; Stop timer 0
3905 C28D       313            clr     TF0 ; Clear overflow flag
3907 758CBF     314            mov     TH0, #high(TIMER0_RELOAD_1MS)
390A 758A28     315            mov     TL0,#low(TIMER0_RELOAD_1MS)
390D D28C       316            setb TR0
390F 308DFD     317            jnb     TF0, $ ; Wait for overflow
3912 22         318            ret
3913            319   waitms:
3913 123903     320            lcall wait_1ms
3916 DAFB       321            djnz R2, waitms
3918 22         322            ret
3919            323   
3919            324   Display_formated_BCD: ;4 dig 
3919 C0E0       325            push acc
391B 7401       325            mov a, #1
391D 14         325            dec a
391E 12336D     325            lcall ?Set_Cursor_1 ; Select column and row
3921 D0E0       325            pop acc
3923 C083       326            push dph
3925 C082       326            push dpl
3927 C0E0       326            push acc
3929 903290     326            mov dptr, #temp_message
392C 123360     326            lcall ?Send_Constant_String
392F D0E0       326            pop acc
3931 D082       326            pop dpl
3933 D083       326            pop dph
3935 C0E0       327            push acc
3937 7407       327            mov a, #7
3939 14         327            dec a
393A 12336B     327            lcall ?Set_Cursor_2 ; Select column and row
393D D0E0       327            pop acc
393F C000       328            push ar0
3941 A83E       328            mov r0, bcd+2
3943 123372     328            lcall ?Display_BCD
3946 D000       328            pop ar0
3948 C0E0       329            push acc
394A 7409       329            mov a, #9
394C 14         329            dec a
394D 12336B     329            lcall ?Set_Cursor_2 ; Select column and row
3950 D0E0       329            pop acc
3952 C000       330            push ar0
3954 A83D       330            mov r0, bcd+1
3956 123372     330            lcall ?Display_BCD
3959 D000       330            pop ar0
395B C0E0       331            push acc
395D 740A       331            mov a, #10
395F 14         331            dec a
3960 12336B     331            lcall ?Set_Cursor_2 ; Select column and row
3963 D0E0       331            pop acc
3965            331   
3965 C000       332            push ar0
3967 A83D       332            mov r0, bcd+1
3969 123372     332            lcall ?Display_BCD
396C D000       332            pop ar0
396E            333            
396E C0E0       334            push acc
3970 740C       334            mov a, #12
3972 14         334            dec a
3973 12336B     334            lcall ?Set_Cursor_2 ; Select column and row
3976 D0E0       334            pop acc
3978 C000       335            push ar0
397A A83C       335            mov r0, bcd+0
397C 123372     335            lcall ?Display_BCD
397F D000       335            pop ar0
3981 C0E0       336            push acc
3983 740A       336            mov a, #10
3985 14         336            dec a
3986 12336B     336            lcall ?Set_Cursor_2 ; Select column and row
3989 D0E0       336            pop acc
398B C0E0       337            push acc
398D 742E       337            mov a, #'.'
398F 123323     337            lcall ?WriteData
3992 D0E0       337            pop acc
3994 C0E0       338            push acc
3996 7407       338            mov a, #7
3998 14         338            dec a
3999 12336B     338            lcall ?Set_Cursor_2 ; Select column and row
399C D0E0       338            pop acc
399E C0E0       339            push acc
39A0 7420       339            mov a, #0x20
39A2 123323     339            lcall ?WriteData
39A5 D0E0       339            pop acc
39A7 C0E0       340            push acc
39A9 740F       340            mov a, #15
39AB 14         340            dec a
39AC 12336B     340            lcall ?Set_Cursor_2 ; Select column and row
39AF D0E0       340            pop acc
39B1 C0E0       341            push acc
39B3 74DF       341            mov a, #0xDF
39B5 123323     341            lcall ?WriteData
39B8 D0E0       341            pop acc
39BA C0E0       342            push acc
39BC 7410       342            mov a, #16
39BE 14         342            dec a
39BF 12336B     342            lcall ?Set_Cursor_2 ; Select column and row
39C2 D0E0       342            pop acc
39C4 C0E0       343            push acc
39C6 7443       343            mov a, #'C'
39C8 123323     343            lcall ?WriteData
39CB D0E0       343            pop acc
39CD 22         344            ret
39CE            345   
39CE            346   Display_temp_BCD: ;4 dig 
39CE C0E0       347            push acc
39D0 E53D       348            mov a, bcd+1
39D2 B40003     349            cjne a, #0, Display_temp_BCD2
39D5 023A2D     350            ljmp Display_temp_BCD3
39D8            351   Display_temp_BCD2:
39D8 C0E0       352            push acc
39DA 7401       352            mov a, #1
39DC 14         352            dec a
39DD 12336B     352            lcall ?Set_Cursor_2 ; Select column and row
39E0 D0E0       352            pop acc
39E2 C083       353            push dph
39E4 C082       353            push dpl
39E6 C0E0       353            push acc
39E8 903290     353            mov dptr, #temp_message
39EB 123360     353            lcall ?Send_Constant_String
39EE D0E0       353            pop acc
39F0 D082       353            pop dpl
39F2 D083       353            pop dph
39F4 C0E0       354            push acc
39F6 740B       354            mov a, #11
39F8 14         354            dec a
39F9 12336B     354            lcall ?Set_Cursor_2 ; Select column and row
39FC D0E0       354            pop acc
39FE            354   
39FE C000       355            push ar0
3A00 A83D       355            mov r0, bcd+1
3A02 123372     355            lcall ?Display_BCD
3A05 D000       355            pop ar0
3A07 C0E0       356            push acc
3A09 740B       356            mov a, #11
3A0B 14         356            dec a
3A0C 12336B     356            lcall ?Set_Cursor_2 ; Select column and row
3A0F D0E0       356            pop acc
3A11 C0E0       357            push acc
3A13 7420       357            mov a, #0x20
3A15 123323     357            lcall ?WriteData
3A18 D0E0       357            pop acc
3A1A C0E0       358            push acc
3A1C 740D       358            mov a, #13
3A1E 14         358            dec a
3A1F 12336B     358            lcall ?Set_Cursor_2 ; Select column and row
3A22 D0E0       358            pop acc
3A24 C000       359            push ar0
3A26 A83C       359            mov r0, bcd+0
3A28 123372     359            lcall ?Display_BCD
3A2B D000       359            pop ar0
3A2D            360   Display_temp_BCD3:
3A2D C0E0       361            push acc
3A2F 740C       361            mov a, #12
3A31 14         361            dec a
3A32 12336B     361            lcall ?Set_Cursor_2 ; Select column and row
3A35 D0E0       361            pop acc
3A37 C0E0       362            push acc
3A39 7420       362            mov a, #0x20
3A3B 123323     362            lcall ?WriteData
3A3E D0E0       362            pop acc
3A40            363   Display_temp_BCD_done:
3A40 C0E0       364            push acc
3A42 740F       364            mov a, #15
3A44 14         364            dec a
3A45 12336B     364            lcall ?Set_Cursor_2 ; Select column and row
3A48 D0E0       364            pop acc
3A4A C0E0       365            push acc
3A4C 74DF       365            mov a, #0xDF
3A4E 123323     365            lcall ?WriteData
3A51 D0E0       365            pop acc                 ; deg symbol
3A53 C0E0       366            push acc
3A55 7410       366            mov a, #16
3A57 14         366            dec a
3A58 12336B     366            lcall ?Set_Cursor_2 ; Select column and row
3A5B D0E0       366            pop acc
3A5D C0E0       367            push acc
3A5F 7443       367            mov a, #'C'
3A61 123323     367            lcall ?WriteData
3A64 D0E0       367            pop acc
3A66 D0E0       368            pop acc
3A68 22         369            ret
3A69            370   
3A69            371   
3A69            372   ; /* READ ADC */
3A69            373   Read_ADC:
3A69 C2EF       374            clr ADCF
3A6B D2EE       375            setb ADCS ;  ADC start trigger signal
3A6D 30EFFD     376       jnb ADCF, $ ; Wait for conversion complete
3A70            377       
3A70            378       ; Read the ADC result and store in [R1, R0]
3A70 E5C2       379       mov a, ADCRL
3A72 540F       380       anl a, #0x0f
3A74 F8         381       mov R0, a
3A75 E5C3       382       mov a, ADCRH   
3A77 C4         383       swap a
3A78 C0E0       384       push acc
3A7A 540F       385       anl a, #0x0f
3A7C F9         386       mov R1, a
3A7D D0E0       387       pop acc
3A7F 54F0       388       anl a, #0xf0
3A81 48         389       orl a, R0
3A82 F8         390       mov R0, A
3A83 22         391            ret
3A84            392   
3A84            393   Main:
3A84 75817F     394       mov SP, #0x7F        ; Set the stack pointer to the begining of idata
3A87            395       
3A87 1237A9     396       lcall InitAll
3A8A 12332D     397       lcall LCD_4BIT
3A8D            398   
3A8D            399            ; Initialize all variables
3A8D D201       400            setb seconds_flag
3A8F 755600     401            mov FSM1_state, #0
3A92 755900     402            mov seconds, #0
3A95 755C00     403            mov ReflowTemp, #0
3A98 755D00     404            mov ReflowTime, #0
3A9B 755E00     405            mov SoakTime, #0
3A9E            406   
3A9E            407       ; initial messages in LCD
3A9E C0E0       408            push acc
3AA0 7401       408            mov a, #1
3AA2 14         408            dec a
3AA3 12336D     408            lcall ?Set_Cursor_1 ; Select column and row
3AA6 D0E0       408            pop acc
3AA8 C083       409            push dph
3AAA C082       409            push dpl
3AAC C0E0       409            push acc
3AAE 90326E     409            mov dptr, #test_message
3AB1 123360     409            lcall ?Send_Constant_String
3AB4 D0E0       409            pop acc
3AB6 D082       409            pop dpl
3AB8 D083       409            pop dph
3ABA C0E0       410            push acc
3ABC 7401       410            mov a, #1
3ABE 14         410            dec a
3ABF 12336B     410            lcall ?Set_Cursor_2 ; Select column and row
3AC2 D0E0       410            pop acc
3AC4 C083       411            push dph
3AC6 C082       411            push dpl
3AC8 C0E0       411            push acc
3ACA 90327F     411            mov dptr, #value_message
3ACD 123360     411            lcall ?Send_Constant_String
3AD0 D0E0       411            pop acc
3AD2 D082       411            pop dpl
3AD4 D083       411            pop dph
3AD6            412   
3AD6            413            ;mov data_out, #0b00000001
3AD6            414   
3AD6            415   ;Forever: ;avaliable: r2, r3
3AD6            416   FSM_sys:
3AD6            417   ; /* TEMP_READ: READS TEMPERATURE */
3AD6            418   ; Note:     Before converting to be stored tempC, 
3AD6            419   ;           all values are stored as 32 bit numbers 
3AD6            420   ;           with 3 decimal points. (in milli-celcius)
3AD6            421   ;           
3AD6            422   ; Example:  2.07 V would be represented by the number
3AD6            423   ;           20700. (The real value * 1000).
3AD6            424   TEMP_READ:
3AD6 023B09     425            ljmp read_led
3AD9            426   
3AD9            427   Avg_ADC:                                                 ; function for ADC noise reduction
3AD9 753000     428            mov x+0, #low (0 % 0x10000) 
3ADC 753100     428            mov x+1, #high(0 % 0x10000) 
3ADF 753200     428            mov x+2, #low (0 / 0x10000) 
3AE2 753300     428            mov x+3, #high(0 / 0x10000) 
3AE5 7DFF       429       mov R5, #255
3AE7            430   sum_loop_avg:
3AE7 123A69     431       lcall Read_ADC
3AEA 753700     432       mov y+3, #0
3AED 753600     433       mov y+2, #0
3AF0 8935       434       mov y+1, R1
3AF2 8834       435       mov y+0, R0
3AF4 12348E     436       lcall add32
3AF7 DDEE       437       djnz R5, sum_loop_avg
3AF9 7534FF     438            mov y+0, #low (255 % 0x10000) 
3AFC 753500     438            mov y+1, #high(255 % 0x10000) 
3AFF 753600     438            mov y+2, #low (255 / 0x10000) 
3B02 753700     438            mov y+3, #high(255 / 0x10000) 
3B05 1235D0     439       lcall div32
3B08 22         440       ret
3B09            441   
3B09            442   read_led:
3B09 53E8F0     443       anl ADCCON0, #0xf0          ; read led voltage
3B0C 43E800     444       orl ADCCON0, #LED_PORT
3B0F 123AD9     445       lcall Avg_ADC
3B12 8841       446       mov VLED_ADC+0, R0          ; save reading to VLED_ADC
3B14 8942       447            mov VLED_ADC+1, R1
3B16            448   
3B16            449   read_lm335:
3B16 53E8F0     450       anl ADCCON0, #0xf0          ; *** LM335 ***
3B19 43E805     451       orl ADCCON0, #LM335_PORT
3B1C 123AD9     452       lcall Avg_ADC
3B1F 8830       453       mov x+0, R0                              ; load lm335 reading to x
3B21 8931       454            mov x+1, R1
3B23 753200     455            mov x+2, #0                     
3B26 753300     456            mov x+3, #0
3B29 7534A0     457            mov y+0, #low (260000 % 0x10000) 
3B2C 7535F7     457            mov y+1, #high(260000 % 0x10000) 
3B2F 753603     457            mov y+2, #low (260000 / 0x10000) 
3B32 753700     457            mov y+3, #high(260000 / 0x10000)               ; load const vled ref into y      
3B35 123543     458       lcall mul32
3B38 854134     459       mov y+0, VLED_ADC+0              ; import vled reading into y
3B3B 854235     460            mov y+1, VLED_ADC+1         
3B3E 753600     461            mov y+2, #0                     
3B41 753700     462            mov y+3, #0
3B44 1235D0     463       lcall div32
3B47 753468     464            mov y+0, #low (273000 % 0x10000) 
3B4A 75352A     464            mov y+1, #high(273000 % 0x10000) 
3B4D 753604     464            mov y+2, #low (273000 / 0x10000) 
3B50 753700     464            mov y+3, #high(273000 / 0x10000)                            ; adjust to 273.000 C offset
3B53 1234AF     465            lcall sub32                     ; result of lm335 temp remains in x
3B56 85304E     466            mov temp_lm+0, x+0          ; store 3 decimal lm335 value for later
3B59 85314F     467       mov temp_lm+1, x+1                           
3B5C 853250     468       mov temp_lm+2, x+2
3B5F 853351     469       mov temp_lm+3, x+3
3B62            470   
3B62            471   read_opamp:
3B62 53E8F0     472            anl ADCCON0, #0xf0          ; *** OPAMP ***
3B65 43E807     473       orl ADCCON0, #OPAMP_PORT     ; 
3B68 123AD9     474            lcall Avg_ADC
3B6B 8830       475            mov x+0, R0                         ; load opamp reading to x
3B6D 8931       476            mov x+1, R1
3B6F 753200     477            mov x+2, #0                     
3B72 753300     478            mov x+3, #0
3B75 753428     479            mov y+0, #low (2600 % 0x10000) 
3B78 75350A     479            mov y+1, #high(2600 % 0x10000) 
3B7B 753600     479            mov y+2, #low (2600 / 0x10000) 
3B7E 753700     479            mov y+3, #high(2600 / 0x10000)                 ; load const vled ref (2070 mV) into y      
3B81 123543     480       lcall mul32
3B84 854134     481       mov y+0, VLED_ADC+0              ; import led adc reading into y
3B87 854235     482            mov y+1, VLED_ADC+1                
3B8A 753600     483            mov y+2, #0                     
3B8D 753700     484            mov y+3, #0
3B90 1235D0     485       lcall div32                 ; x value now stores OPAMP V in mV
3B93 7534E8     486            mov y+0, #low (1000 % 0x10000) 
3B96 753503     486            mov y+1, #high(1000 % 0x10000) 
3B99 753600     486            mov y+2, #low (1000 / 0x10000) 
3B9C 753700     486            mov y+3, #high(1000 / 0x10000)                                  
3B9F 123543     487            lcall mul32                                     ; turn mV to uV
3BA2 75341B     488            mov y+0, #low (V2C_DIVISOR % 0x10000) 
3BA5 753504     488            mov y+1, #high(V2C_DIVISOR % 0x10000) 
3BA8 753600     488            mov y+2, #low (V2C_DIVISOR / 0x10000) 
3BAB 753700     488            mov y+3, #high(V2C_DIVISOR / 0x10000) 
3BAE 1235D0     489            lcall div32                                     ; deg C reading now in x        
3BB1 7534E8     490            mov y+0, #low (1000 % 0x10000) 
3BB4 753503     490            mov y+1, #high(1000 % 0x10000) 
3BB7 753600     490            mov y+2, #low (1000 / 0x10000) 
3BBA 753700     490            mov y+3, #high(1000 / 0x10000) 
3BBD 123543     491            lcall mul32                                     ; conv to mV again to add to lm335 data
3BC0            492   
3BC0            493   add_lm335_to_opamp:
3BC0 854E34     494       mov y+0, temp_lm+0           ; load lm335 temp to y
3BC3 854F35     495       mov y+1, temp_lm+1
3BC6 855036     496       mov y+2, temp_lm+2
3BC9 855137     497       mov y+3, temp_lm+3
3BCC 12348E     498       lcall add32                  ; lm335 + opamp = real temp
3BCF 853046     499       mov temp_mc+0, x+0          ; store result in temp_mc (for python)
3BD2 853147     500       mov temp_mc+1, x+1                           
3BD5 853248     501       mov temp_mc+2, x+2
3BD8 853349     502       mov temp_mc+3, x+3
3BDB            503            
3BDB            504   export_to_main:                                  ; exports temp reading to rest of code
3BDB 854630     505            mov x+0, temp_mc+0          
3BDE 854731     506       mov x+1, temp_mc+1
3BE1 854832     507       mov x+2, temp_mc+2
3BE4 854933     508       mov x+3, temp_mc+3
3BE7 7534E8     509            mov y+0, #low (1000 % 0x10000) 
3BEA 753503     509            mov y+1, #high(1000 % 0x10000) 
3BED 753600     509            mov y+2, #low (1000 / 0x10000) 
3BF0 753700     509            mov y+3, #high(1000 / 0x10000) 
3BF3 1235D0     510       lcall div32
3BF6 853045     511       mov tempc, x+0              ; Both tempc and x now stores temp (C)           
3BF9            512   
3BF9            513   export_to_bcd:                                   ; sends temp reading in C to bcd
3BF9 1233C9     514            lcall hex2bcd
3BFC 1239CE     515            lcall Display_temp_BCD
3BFF            516   
3BFF            517   Export:                                                  ; Data export to python
3BFF 7AFA       518            mov R2, #250                            ; Wait 500 ms between conversions
3C01 123913     519            lcall waitms
3C04 7AFA       520            mov R2, #250
3C06 123913     521            lcall waitms                            ; Sends binary contents of 
3C09 1238AF     522       lcall SendBin                                ; temp_mc and data_out to python
3C0C            523   
3C0C            524            ; /* FSM1 STATE CHANGE CONTROLS */
3C0C 023C0F     525            ljmp FSM1
3C0F            526   
3C0F            527   ; REQUIREMENTS
3C0F            528   ; Start/Stop button, to do this, make routine which displays "stopped" for a little bit
3C0F            529   ; Temperature display, implemented already
3C0F            530   ; Running time display, implement in main
3C0F            531   ; 
3C0F            532   
3C0F            533   
3C0F            534   FSM1:
3C0F E556       535            mov a, FSM1_state
3C11 C0E0       536            push acc
3C13 7401       536            mov a, #1
3C15 14         536            dec a
3C16 12336D     536            lcall ?Set_Cursor_1 ; Select column and row
3C19 D0E0       536            pop acc
3C1B C083       537            push dph
3C1D C082       537            push dpl
3C1F C0E0       537            push acc
3C21 9032C3     537            mov dptr, #state_message
3C24 123360     537            lcall ?Send_Constant_String
3C27 D0E0       537            pop acc
3C29 D082       537            pop dpl
3C2B D083       537            pop dph
3C2D            538   
3C2D            539   FSM1_state0:
3C2D B40024     540            cjne a, #0, FSM1_state1 ; if FSM1_state (currently stored in a) is not equal to zero (ie. state zero), go to state 1
3C30 755A00     541            mov pwm, #0
3C33 C0E0       542            push acc
3C35 740E       542            mov a, #14
3C37 14         542            dec a
3C38 12336D     542            lcall ?Set_Cursor_1 ; Select column and row
3C3B D0E0       542            pop acc
3C3D C000       543            push ar0
3C3F 7800       543            mov r0, #0x00
3C41 123372     543            lcall ?Display_BCD
3C44 D000       543            pop ar0
3C46 C201       544            clr seconds_flag
3C48            545            ; check for push button input
3C48 208406     546            jb START_BUTTON, FSM1_state0_done
3C4B 3084FD     547            jnb START_BUTTON, $ ; Wait for key release
3C4E 755601     548            mov FSM1_state, #1
3C51            549   
3C51            550   FSM1_state0_done:
3C51 023AD6     551            ljmp FSM_sys
3C54            552   
3C54            553   FSM1_state1:
3C54 B40126     554            cjne a, #1, FSM1_state2
3C57 755A64     555            mov pwm, #100
3C5A C0E0       556            push acc
3C5C 740E       556            mov a, #14
3C5E 14         556            dec a
3C5F 12336D     556            lcall ?Set_Cursor_1 ; Select column and row
3C62 D0E0       556            pop acc
3C64 C000       557            push ar0
3C66 7801       557            mov r0, #0x01
3C68 123372     557            lcall ?Display_BCD
3C6B D000       557            pop ar0
3C6D 755900     558            mov seconds, #0
3C70 7496       559            mov a, #150
3C72 C3         560            clr c
3C73 9545       561            subb a, tempc
3C75 5003       562            jnc FSM1_state1_done
3C77 755602     563            mov FSM1_state, #2
3C7A            564   
3C7A            565   FSM1_state1_done:
3C7A 023AD6     566            ljmp FSM_sys
3C7D            567   
3C7D            568   FSM1_state2:
3C7D B4022E     569            cjne a, #2, FSM1_state3
3C80 755A14     570            mov pwm, #20
3C83 C0E0       571            push acc
3C85 740E       571            mov a, #14
3C87 14         571            dec a
3C88 12336D     571            lcall ?Set_Cursor_1 ; Select column and row
3C8B D0E0       571            pop acc
3C8D C000       572            push ar0
3C8F 7802       572            mov r0, #0x02
3C91 123372     572            lcall ?Display_BCD
3C94 D000       572            pop ar0
3C96 30010A     573            jnb seconds_flag, FSM_state2_funk
3C99            574            ;mov a, #60
3C99 E55E       575            mov a, SoakTime
3C9B C3         576            clr c
3C9C 9559       577            subb a, seconds                 ; Want time to be greater than 60 seconds
3C9E 400B       578            jc FSM1_state2_done
3CA0 755603     579            mov FSM1_state, #3
3CA3            580   
3CA3            581   FSM_state2_funk:
3CA3 755900     582            mov seconds, #0         ; Set seconds so we can count up to the required time 
3CA6 D201       583            setb seconds_flag       ; seconds flag so we don't reset seconds_flag multiple times
3CA8 023C7D     584            ljmp FSM1_state2        
3CAB            585   
3CAB            586   FSM1_state2_done:
3CAB 023AD6     587            ljmp FSM_sys
3CAE            588   
3CAE            589   FSM1_state3:
3CAE B40325     590            cjne a, #3, FSM1_state4
3CB1 755A64     591            mov pwm, #100
3CB4 C0E0       592            push acc
3CB6 740E       592            mov a, #14
3CB8 14         592            dec a
3CB9 12336D     592            lcall ?Set_Cursor_1 ; Select column and row
3CBC D0E0       592            pop acc
3CBE C000       593            push ar0
3CC0 7803       593            mov r0, #0x03
3CC2 123372     593            lcall ?Display_BCD
3CC5 D000       593            pop ar0
3CC7            594            ;mov a, #220
3CC7 E55C       595            mov a, ReflowTemp
3CC9 C201       596            clr seconds_flag
3CCB C3         597            clr c
3CCC 9545       598            subb a, tempc
3CCE 5003       599            jnc FSM1_state3_done
3CD0 755604     600            mov FSM1_state, #4
3CD3            601   
3CD3            602   FSM1_state3_done:
3CD3 023AD6     603            ljmp FSM_sys
3CD6            604   
3CD6            605   FSM1_state4:
3CD6 B4042E     606            cjne a, #4, FSM1_state5
3CD9 755A14     607            mov pwm, #20 
3CDC C0E0       608            push acc
3CDE 740E       608            mov a, #14
3CE0 14         608            dec a
3CE1 12336D     608            lcall ?Set_Cursor_1 ; Select column and row
3CE4 D0E0       608            pop acc
3CE6 C000       609            push ar0
3CE8 7804       609            mov r0, #0x04
3CEA 123372     609            lcall ?Display_BCD
3CED D000       609            pop ar0
3CEF 30010A     610            jnb seconds_flag, FSM1_state4_funk
3CF2            611            ;mov a, #45
3CF2 E55D       612            mov a, ReflowTime
3CF4 C3         613            clr c 
3CF5 9559       614            subb a, seconds ; when seconds is greater than 45, there will be a carry bit
3CF7 400B       615            jc FSM1_state4_done
3CF9 755605     616            mov FSM1_state, #5
3CFC            617   
3CFC            618   FSM1_state4_funk:
3CFC 755900     619            mov seconds, #0
3CFF D201       620            setb seconds_flag
3D01 023CD6     621            ljmp FSM1_state4
3D04            622   
3D04            623   FSM1_state4_done:
3D04 023AD6     624            ljmp FSM_sys
3D07            625   
3D07            626   FSM1_state5:
3D07 B40523     627            cjne a, #5, FSM1_abort_state            ; if the state is not in 0-5, then it must be 10 (aka the abort state)
3D0A 755A00     628            mov pwm, #0
3D0D C0E0       629            push acc
3D0F 740E       629            mov a, #14
3D11 14         629            dec a
3D12 12336D     629            lcall ?Set_Cursor_1 ; Select column and row
3D15 D0E0       629            pop acc
3D17 C000       630            push ar0
3D19 7804       630            mov r0, #0x04
3D1B 123372     630            lcall ?Display_BCD
3D1E D000       630            pop ar0
3D20 743C       631            mov a, #60
3D22 C3         632            clr c
3D23 9545       633            subb a, tempc
3D25 4003       634            jc FSM1_state5_done
3D27 755600     635            mov FSM1_state, #0
3D2A            636   
3D2A            637   FSM1_state5_done:
3D2A 023AD6     638            ljmp FSM_sys
3D2D            639   
3D2D            640   FSM1_abort_state:                                                ; When the abort state is triggered, turn everything off and remain in this state utill you reset
3D2D 755A00     641            mov pwm, #0
3D30 C0E0       642            push acc
3D32 7401       642            mov a, #1
3D34 14         642            dec a
3D35 12336D     642            lcall ?Set_Cursor_1 ; Select column and row
3D38 D0E0       642            pop acc
3D3A C083       643            push dph
3D3C C082       643            push dpl
3D3E C0E0       643            push acc
3D40 9032B2     643            mov dptr, #abort_message
3D43 123360     643            lcall ?Send_Constant_String
3D46 D0E0       643            pop acc
3D48 D082       643            pop dpl
3D4A D083       643            pop dph
3D4C            644   
3D4C 023D2D     645            ljmp FSM1_abort_state
3D4F            646   
3D4F            647   END
