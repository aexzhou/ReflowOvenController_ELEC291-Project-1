                  2   $LIST
0000              4   
0000              5   ;  N76E003 pinout:
0000              6   ;                               -------
0000              7   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000              8   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000              9   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             10   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             11   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             12   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             13   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             14   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             15   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             16   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             17   ;                               -------
0000             18   ;
0000             19   
0000             20   CLK                 EQU 16600000 ; Microcontroller system frequency in Hz
0000             21   BAUD                EQU 115200 ; Baud rate of UART in bps
0000             22   TIMER1_RELOAD       EQU (0x100-(CLK/(16*BAUD)))
0000             23   TIMER0_RELOAD_1MS   EQU (0x10000-(CLK/1000))
0000             24   
0000             25   org 0000H
0000 0205C8      26      ljmp Main
0003             27   ;                     1234567890123456    <- This helps determine the location of the counter
0003 2A2A2A2A    28   test_message:     db '****LOADING*****', 0
     4C4F4144
     494E472A
     2A2A2A2A
     00
0014 54454D50    29   value_message:    db 'TEMP:      ', 0
     3A202020
     20202000
0020 43454C43    30   cel_message:       db 'CELCIUS  READING',0
     49555320
     20524541
     44494E47
     00
0031 46415245    31   fah_message:      db 'FARENHET READING',0
     4E484554
     20524541
     44494E47
     00
0042             32   CSEG
0042             33   
0042             34   ; /* LCD HARDWIRING */
0042             35   LCD_RS equ P1.3
0042             36   LCD_E  equ P1.4
0042             37   LCD_D4 equ P0.0
0042             38   LCD_D5 equ P0.1
0042             39   LCD_D6 equ P0.2
0042             40   LCD_D7 equ P0.3
0042             41   UNIT   equ P1.5
                 43   	$LIST
010A             45   
010A             46   ; /* MATH.INC STUFFS */
0030             47   DSEG at 30H
0030             48   x:   ds 4
0034             49   y:   ds 4
0038             50   z:   ds 1
0039             51   
0039             52   bcd: ds 5
003E             53   
003E             54   
003E             55   VLED_ADC: ds 2
0040             56   dtemp:  ds 2
0042             57   temp1: ds 1
0043             58   BCD_counter: ds 1
0044             59   
0000             60   BSEG
0000             61   mf: dbit 1
0001             62   cel: dbit 1
0002             63   
                546   $LIST
                 65   $LIST
037A             67   
037A             68   
037A             69   
037A             70   
037A             71   
037A             72   ; /* Configure the serial port and baud rate */
037A             73   InitSerialPort:
037A 75AC00      74            mov     P3M1,#0x00  ; Configure all the pins for biderectional I/O
037D 75AD00      75            mov     P3M2,#0x00
0380 75B300      76            mov     P1M1,#0x00
0383 75B400      77            mov     P1M2,#0x00
0386 75B100      78            mov     P0M1,#0x00
0389 75B200      79            mov     P0M2,#0x00
038C             80       ; Since the reset button bounces, we need to wait a bit before
038C             81       ; sending messages, otherwise we risk displaying gibberish!
038C             82       ;mov R1, #200
038C             83       ;mov R0, #104
038C             84       ;djnz R0, $   ; 4 cycles->4*60.285ns*104=25us
038C             85       ;djnz R1, $-4 ; 25us*200=5.0ms
038C 7A05        86       mov R2, #5
038E 120446      87       lcall waitms
0391             88       ; Now we can proceed with the configuration of the serial port
0391 438E10      89            orl     CKCON, #0x10 ; CLK is the input for timer 1
0394 438780      90            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
0397 759852      91            mov     SCON, #0x52
039A 53C4DF      92            anl     T3CON, #0b11011111
039D 53890F      93            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
03A0 438920      94            orl     TMOD, #0x20 ; Timer 1 Mode 2
03A3 758DF7      95            mov     TH1, #TIMER1_RELOAD
03A6 D28E        96            setb TR1
03A8 22          97       ret
03A9             98   
03A9             99   ; /* Send a character using the serial port */
03A9            100   putchar:
03A9 3099FD     101       jnb TI, putchar
03AC C299       102       clr TI
03AE F599       103       mov SBUF, a
03B0 22         104       ret
03B1            105   
03B1            106   
03B1            107   ; Send a constant-zero-terminated string using the serial port
03B1            108   SendString:
03B1 E4         109       clr A
03B2 93         110       movc A, @A+DPTR
03B3 6006       111       jz SendStringDone
03B5 1203A9     112       lcall putchar
03B8 A3         113       inc DPTR
03B9 80F6       114       sjmp SendString
03BB            115   SendStringDone:
03BB 22         116       ret
03BC            117   
03BC            118   SendBin:
03BC E4         119            clr A
03BD E530       120            mov a, x+0
03BF 1203A9     121            lcall putchar
03C2            122   
03C2 E4         123            clr A
03C3 E531       124            mov a, x+1
03C5 1203A9     125            lcall putchar
03C8            126   
03C8 E4         127            clr A
03C9 E532       128            mov a, x+2
03CB 1203A9     129            lcall putchar
03CE            130   
03CE E4         131            clr A
03CF E533       132            mov a, x+3
03D1 1203A9     133            lcall putchar
03D4            134   
03D4 E4         135            clr A
03D5 E538       136            mov a, z
03D7 1203A9     137            lcall putchar
03DA 22         138            ret
03DB            139   
03DB            140   ASCII_CHAR: 
03DB 30313233   141            db '0123456789ABCDEF'
     34353637
     38394142
     43444546
03EB            142   
03EB            143   Hello_World:
03EB 48656C6C   144       DB  'Hello, World!', '\r', '\n', 0
     6F2C2057
     6F726C64
     210D0A00
03FB            145   New_Line:
03FB 0D0A00     146            DB '\r', '\n', 0
03FE            147   
03FE            148   Init_Rest:
03FE 438E10     149            orl     CKCON, #0x10 ; CLK is the input for timer 1
0401 438780     150            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
0404 759852     151            mov     SCON, #0x52
0407 53C4DF     152            anl     T3CON, #0b11011111
040A 53890F     153            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
040D 438920     154            orl     TMOD, #0x20 ; Timer 1 Mode 2
0410 758DF7     155            mov     TH1, #TIMER1_RELOAD ; TH1=TIMER1_RELOAD;
0413 D28E       156            setb TR1
0415            157            
0415            158            ; Using timer 0 for delay functions.  Initialize here:
0415 C28C       159            clr     TR0 ; Stop timer 0
0417 438E08     160            orl     CKCON,#0x08 ; CLK is the input for timer 0
041A 5389F0     161            anl     TMOD,#0xF0 ; Clear the configuration bits for timer 0
041D 438901     162            orl     TMOD,#0x01 ; Timer 0 in Mode 1: 16-bit timer
0420            163            
0420            164            ; Initialize the pin used by the ADC (P1.1) as input.
0420 43B302     165            orl     P1M1, #0b00000010
0423 53B4FD     166            anl     P1M2, #0b11111101
0426            167            
0426            168            ; Initialize and start the ADC:
0426 53E8F0     169            anl ADCCON0, #0xF0
0429 43E807     170            orl ADCCON0, #0x07 ; Select channel 7
042C            171            ; AINDIDS select if some pins are analog inputs or digital I/O:
042C 75F600     172            mov AINDIDS, #0x00 ; Disable all analog inputs
042F 43F680     173            orl AINDIDS, #0b10000000 ; P1.1 is analog input
0432 43E101     174            orl ADCCON1, #0x01 ; Enable ADC
0435            175   
0435            176            
0435            177            
0435 22         178            ret
0436            179   
0436            180   ; /* 1ms DELAY FUNCTIONS */
0436            181   wait_1ms:
0436 C28C       182            clr     TR0 ; Stop timer 0
0438 C28D       183            clr     TF0 ; Clear overflow flag
043A 758CBF     184            mov     TH0, #high(TIMER0_RELOAD_1MS)
043D 758A28     185            mov     TL0,#low(TIMER0_RELOAD_1MS)
0440 D28C       186            setb TR0
0442 308DFD     187            jnb     TF0, $ ; Wait for overflow
0445 22         188            ret
0446            189   waitms:
0446 120436     190            lcall wait_1ms
0449 DAFB       191            djnz R2, waitms
044B 22         192            ret
044C            193   
044C            194   Display_formated_BCD: ;4 dig 
044C C0E0       195            push acc
044E 7401       195            mov a, #1
0450 14         195            dec a
0451 1200DC     195            lcall ?Set_Cursor_1 ; Select column and row
0454 D0E0       195            pop acc
0456 C083       196            push dph
0458 C082       196            push dpl
045A C0E0       196            push acc
045C 900020     196            mov dptr, #cel_message
045F 1200CF     196            lcall ?Send_Constant_String
0462 D0E0       196            pop acc
0464 D082       196            pop dpl
0466 D083       196            pop dph
0468 C0E0       197            push acc
046A 7407       197            mov a, #7
046C 14         197            dec a
046D 1200DA     197            lcall ?Set_Cursor_2 ; Select column and row
0470 D0E0       197            pop acc
0472            197   
0472 C000       198            push ar0
0474 A83B       198            mov r0, bcd+2
0476 1200E1     198            lcall ?Display_BCD
0479 D000       198            pop ar0
047B C0E0       199            push acc
047D 7409       199            mov a, #9
047F 14         199            dec a
0480 1200DA     199            lcall ?Set_Cursor_2 ; Select column and row
0483 D0E0       199            pop acc
0485 C000       200            push ar0
0487 A83A       200            mov r0, bcd+1
0489 1200E1     200            lcall ?Display_BCD
048C D000       200            pop ar0
048E C0E0       201            push acc
0490 740A       201            mov a, #10
0492 14         201            dec a
0493 1200DA     201            lcall ?Set_Cursor_2 ; Select column and row
0496 D0E0       201            pop acc
0498 C000       202            push ar0
049A A83A       202            mov r0, bcd+1
049C 1200E1     202            lcall ?Display_BCD
049F D000       202            pop ar0
04A1            203            
04A1 C0E0       204            push acc
04A3 740C       204            mov a, #12
04A5 14         204            dec a
04A6 1200DA     204            lcall ?Set_Cursor_2 ; Select column and row
04A9 D0E0       204            pop acc
04AB C000       205            push ar0
04AD A839       205            mov r0, bcd+0
04AF 1200E1     205            lcall ?Display_BCD
04B2 D000       205            pop ar0
04B4 C0E0       206            push acc
04B6 740A       206            mov a, #10
04B8 14         206            dec a
04B9 1200DA     206            lcall ?Set_Cursor_2 ; Select column and row
04BC D0E0       206            pop acc
04BE C0E0       207            push acc
04C0 742E       207            mov a, #'.'
04C2 120092     207            lcall ?WriteData
04C5 D0E0       207            pop acc
04C7 C0E0       208            push acc
04C9 7407       208            mov a, #7
04CB 14         208            dec a
04CC 1200DA     208            lcall ?Set_Cursor_2 ; Select column and row
04CF D0E0       208            pop acc
04D1 C0E0       209            push acc
04D3 7420       209            mov a, #0x20
04D5 120092     209            lcall ?WriteData
04D8 D0E0       209            pop acc
04DA C0E0       210            push acc
04DC 740F       210            mov a, #15
04DE 14         210            dec a
04DF 1200DA     210            lcall ?Set_Cursor_2 ; Select column and row
04E2 D0E0       210            pop acc
04E4 C0E0       211            push acc
04E6 74DF       211            mov a, #0xDF
04E8 120092     211            lcall ?WriteData
04EB D0E0       211            pop acc
04ED C0E0       212            push acc
04EF 7410       212            mov a, #16
04F1 14         212            dec a
04F2 1200DA     212            lcall ?Set_Cursor_2 ; Select column and row
04F5 D0E0       212            pop acc
04F7 C0E0       213            push acc
04F9 7443       213            mov a, #'C'
04FB 120092     213            lcall ?WriteData
04FE D0E0       213            pop acc
0500            214   
0500 22         215            ret
0501            216   
0501            217   Display_formated_BCD_F: ;4 dig 
0501 C0E0       218            push acc
0503 7401       218            mov a, #1
0505 14         218            dec a
0506 1200DC     218            lcall ?Set_Cursor_1 ; Select column and row
0509 D0E0       218            pop acc
050B C083       219            push dph
050D C082       219            push dpl
050F C0E0       219            push acc
0511 900031     219            mov dptr, #fah_message
0514 1200CF     219            lcall ?Send_Constant_String
0517 D0E0       219            pop acc
0519 D082       219            pop dpl
051B D083       219            pop dph
051D C0E0       220            push acc
051F 7407       220            mov a, #7
0521 14         220            dec a
0522 1200DA     220            lcall ?Set_Cursor_2 ; Select column and row
0525 D0E0       220            pop acc
0527            220   
0527 C000       221            push ar0
0529 A83B       221            mov r0, bcd+2
052B 1200E1     221            lcall ?Display_BCD
052E D000       221            pop ar0
0530 C0E0       222            push acc
0532 7409       222            mov a, #9
0534 14         222            dec a
0535 1200DA     222            lcall ?Set_Cursor_2 ; Select column and row
0538 D0E0       222            pop acc
053A C000       223            push ar0
053C A83A       223            mov r0, bcd+1
053E 1200E1     223            lcall ?Display_BCD
0541 D000       223            pop ar0
0543 C0E0       224            push acc
0545 740A       224            mov a, #10
0547 14         224            dec a
0548 1200DA     224            lcall ?Set_Cursor_2 ; Select column and row
054B D0E0       224            pop acc
054D C000       225            push ar0
054F A83A       225            mov r0, bcd+1
0551 1200E1     225            lcall ?Display_BCD
0554 D000       225            pop ar0
0556            226            
0556 C0E0       227            push acc
0558 740C       227            mov a, #12
055A 14         227            dec a
055B 1200DA     227            lcall ?Set_Cursor_2 ; Select column and row
055E D0E0       227            pop acc
0560 C000       228            push ar0
0562 A839       228            mov r0, bcd+0
0564 1200E1     228            lcall ?Display_BCD
0567 D000       228            pop ar0
0569 C0E0       229            push acc
056B 740A       229            mov a, #10
056D 14         229            dec a
056E 1200DA     229            lcall ?Set_Cursor_2 ; Select column and row
0571 D0E0       229            pop acc
0573 C0E0       230            push acc
0575 742E       230            mov a, #'.'
0577 120092     230            lcall ?WriteData
057A D0E0       230            pop acc
057C C0E0       231            push acc
057E 7407       231            mov a, #7
0580 14         231            dec a
0581 1200DA     231            lcall ?Set_Cursor_2 ; Select column and row
0584 D0E0       231            pop acc
0586            232            ;Display_char(#0x20)
0586 C0E0       233            push acc
0588 740F       233            mov a, #15
058A 14         233            dec a
058B 1200DA     233            lcall ?Set_Cursor_2 ; Select column and row
058E D0E0       233            pop acc
0590 C0E0       234            push acc
0592 74DF       234            mov a, #0xDF
0594 120092     234            lcall ?WriteData
0597 D0E0       234            pop acc
0599 C0E0       235            push acc
059B 7410       235            mov a, #16
059D 14         235            dec a
059E 1200DA     235            lcall ?Set_Cursor_2 ; Select column and row
05A1 D0E0       235            pop acc
05A3 C0E0       236            push acc
05A5 7446       236            mov a, #'F'
05A7 120092     236            lcall ?WriteData
05AA D0E0       236            pop acc
05AC            237   
05AC 22         238            ret
05AD            239   
05AD            240   
05AD            241   ; /* READ ADC */
05AD            242   Read_ADC:
05AD C2EF       243            clr ADCF
05AF D2EE       244            setb ADCS ;  ADC start trigger signal
05B1 30EFFD     245       jnb ADCF, $ ; Wait for conversion complete
05B4            246       
05B4            247       ; Read the ADC result and store in [R1, R0]
05B4 E5C2       248       mov a, ADCRL
05B6 540F       249       anl a, #0x0f
05B8 F8         250       mov R0, a
05B9 E5C3       251       mov a, ADCRH   
05BB C4         252       swap a
05BC C0E0       253       push acc
05BE 540F       254       anl a, #0x0f
05C0 F9         255       mov R1, a
05C1 D0E0       256       pop acc
05C3 54F0       257       anl a, #0xf0
05C5 48         258       orl a, R0
05C6 F8         259       mov R0, A
05C7 22         260            ret
05C8            261   
05C8            262   Main:
05C8 75817F     263       mov SP, #0x7F ; Set the stack pointer to the begining of idata
05CB            264       
05CB 12037A     265       lcall InitSerialPort
05CE 1203FE     266       lcall Init_Rest
05D1 12009C     267       lcall LCD_4BIT
05D4            268   
05D4            269       ; initial messages in LCD
05D4 C0E0       270            push acc
05D6 7401       270            mov a, #1
05D8 14         270            dec a
05D9 1200DC     270            lcall ?Set_Cursor_1 ; Select column and row
05DC D0E0       270            pop acc
05DE C083       271            push dph
05E0 C082       271            push dpl
05E2 C0E0       271            push acc
05E4 900003     271            mov dptr, #test_message
05E7 1200CF     271            lcall ?Send_Constant_String
05EA D0E0       271            pop acc
05EC D082       271            pop dpl
05EE D083       271            pop dph
05F0 C0E0       272            push acc
05F2 7401       272            mov a, #1
05F4 14         272            dec a
05F5 1200DA     272            lcall ?Set_Cursor_2 ; Select column and row
05F8 D0E0       272            pop acc
05FA C083       273            push dph
05FC C082       273            push dpl
05FE C0E0       273            push acc
0600 900014     273            mov dptr, #value_message
0603 1200CF     273            lcall ?Send_Constant_String
0606 D0E0       273            pop acc
0608 D082       273            pop dpl
060A D083       273            pop dph
060C D201       274            setb cel
060E            275   
060E 753801     276            mov z, #0b00000001
0611            277   
0611            278   Forever: ;avaliable: r2, r3
0611            279   
0611            280   button:
0611 20951C     281            jb UNIT, button_skip ; if the 'CLEAR' button is not pressed skip
0614 C002       282            push AR2
0616 7A32       282            mov R2, #50
0618 12004C     282            lcall ?Wait_Milli_Seconds
061B D002       282            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
061D 209510     283            jb UNIT, button_skip  ; if the 'CLEAR' button is not pressed skip
0620 3095FD     284            jnb UNIT, $             ; Wait for button release.  The '$' means: jump to same instruction.
0623 B201       285            cpl cel
0625 200105     286            jb cel, celyes
0628 753802     287            mov z, #0b00000010
062B 8003       288            sjmp button_skip
062D            289   celyes:
062D 753801     290            mov z, #0b00000001
0630            291   button_skip:
0630            292   
0630            293   
0630            294            ; /* CALIBRATE */ 
0630 53E8F0     295            anl ADCCON0, #0xF0 ; Read the 2.08V LED voltage connected to AIN0 on pin 6
0633 43E800     296            orl ADCCON0, #0x00 ; Select channel 0
0636 1205AD     297       lcall Read_ADC
0639            298       
0639 883E       299            mov VLED_ADC+0, R0 ; Save result for later use
063B 893F       300            mov VLED_ADC+1, R1
063D            301   
063D 53E8F0     302            anl ADCCON0, #0xF0 ; Read the signal connected to AIN7
0640 43E807     303            orl ADCCON0, #0x07 ; Select channel 7
0643 1205AD     304            lcall Read_ADC
0646            305   
0646 200103     306            jb cel, Celcius
0649 02068F     307            ljmp Fah
064C            308   
064C            309   Celcius: 
064C 8830       310            mov x+0, R0                     ; x <- adc(ch) 
064E 8931       311            mov x+1, R1
0650 753200     312            mov x+2, #0                     ; pad w/0
0653 753300     313            mov x+3, #0
0656 753498     314            mov y+0, #low (207000 % 0x10000) 
0659 753528     314            mov y+1, #high(207000 % 0x10000) 
065C 753603     314            mov y+2, #low (207000 / 0x10000) 
065F 753700     314            mov y+3, #high(207000 / 0x10000)                        ; y <- (x.xxx (vled) * 1000) * 100
0662 120284     315            lcall mul32                             
0665 853E34     316       mov y+0, VLED_ADC+0          ; y <- adc(led)
0668 853F35     317            mov y+1, VLED_ADC+1
066B 753600     318            mov y+2, #0                     
066E 753700     319            mov y+3, #0 
0671 120311     320            lcall div32                             ; x <- adc(ch) * vled * 100 / adc(led)
0674 7534FE     321            mov y+0, #low (273150 % 0x10000) 
0677 75352A     321            mov y+1, #high(273150 % 0x10000) 
067A 753604     321            mov y+2, #low (273150 / 0x10000) 
067D 753700     321            mov y+3, #high(273150 / 0x10000)                        ; y <- (2.7315 * 1000) * 100
0680 1201F0     322            lcall sub32     
0683            323   
0683 12010A     324            lcall hex2bcd ; Convert to BCD and display
0686 12044C     325            lcall Display_formated_BCD
0689 120193     326       lcall bcd2hex ;hex number now stored in x
068C            327   
068C 0206FF     328            ljmp Export                     
068F            329   
068F            330   Fah:
068F 8830       331            mov x+0, R0                     ; x <- adc(ch) 
0691 8931       332            mov x+1, R1
0693 753200     333            mov x+2, #0                     ; pad w/0
0696 753300     334            mov x+3, #0
0699 753498     335            mov y+0, #low (207000 % 0x10000) 
069C 753528     335            mov y+1, #high(207000 % 0x10000) 
069F 753603     335            mov y+2, #low (207000 / 0x10000) 
06A2 753700     335            mov y+3, #high(207000 / 0x10000)                        ; y <- (x.xxx (vled) * 1000) * 100
06A5 120284     336            lcall mul32                                     
06A8 853E34     337       mov y+0, VLED_ADC+0          ; y <- adc(led)
06AB 853F35     338            mov y+1, VLED_ADC+1
06AE 753600     339            mov y+2, #0                     
06B1 753700     340            mov y+3, #0 
06B4 120311     341            lcall div32                             ; x <- adc(ch) * vled * 100 / adc(led)
06B7 7534FE     342            mov y+0, #low (273150 % 0x10000) 
06BA 75352A     342            mov y+1, #high(273150 % 0x10000) 
06BD 753604     342            mov y+2, #low (273150 / 0x10000) 
06C0 753700     342            mov y+3, #high(273150 / 0x10000)                        ; y <- (2.7315 * 1000) * 100
06C3 1201F0     343            lcall sub32
06C6            344   
06C6 753409     345            mov y+0, #low (9 % 0x10000) 
06C9 753500     345            mov y+1, #high(9 % 0x10000) 
06CC 753600     345            mov y+2, #low (9 / 0x10000) 
06CF 753700     345            mov y+3, #high(9 / 0x10000) 
06D2 120284     346            lcall mul32
06D5 753405     347            mov y+0, #low (5 % 0x10000) 
06D8 753500     347            mov y+1, #high(5 % 0x10000) 
06DB 753600     347            mov y+2, #low (5 / 0x10000) 
06DE 753700     347            mov y+3, #high(5 / 0x10000) 
06E1 120311     348            lcall div32     
06E4 753400     349            mov y+0, #low (32000 % 0x10000) 
06E7 75357D     349            mov y+1, #high(32000 % 0x10000) 
06EA 753600     349            mov y+2, #low (32000 / 0x10000) 
06ED 753700     349            mov y+3, #high(32000 / 0x10000) 
06F0 1201CF     350            lcall add32
06F3            351            
06F3            352            
06F3 12010A     353            lcall hex2bcd ; Convert to BCD and display
06F6 120501     354            lcall Display_formated_BCD_F
06F9 120193     355       lcall bcd2hex ;hex number now stored in x
06FC            356   
06FC 0206FF     357            ljmp Export     
06FF            358   
06FF            359   Export:  
06FF 7AFA       360            mov R2, #250 ; Wait 500 ms between conversions
0701 120446     361            lcall waitms
0704 7AFA       362            mov R2, #250
0706 120446     363            lcall waitms
0709            364   
0709            365            ;mov dptr, #x
0709 1203BC     366       lcall SendBin
070C            367            ;mov dptr, #New_Line
070C            368            ;lcall SendString
070C 020611     369       ljmp Forever
070F            370   
070F            371   END
