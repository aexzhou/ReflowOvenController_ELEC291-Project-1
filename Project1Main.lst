                  2   $LIST
0000              4   
0000              5   ;  N76E003 pinout:
0000              6   ;                               -------
0000              7   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000              8   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000              9   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             10   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             11   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             12   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             13   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             14   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             15   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             16   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             17   ;                               -------
0000             18   ;
0000             19   
0000             20   CLK                 EQU 16600000                                                 ; Microcontroller system frequency in Hz
0000             21   BAUD                EQU 115200                                                   ; Baud rate of UART in bps
0000             22   TIMER1_RELOAD       EQU (0x100-(CLK/(16*BAUD)))
0000             23   TIMER0_RELOAD_1MS   EQU (0x10000-(CLK/1000))
0000             24   TIMER2_RATE              EQU 100                                                         ; 1/100 = 10ms
0000             25   TIMER2_RELOAD            EQU (65536-(CLK/(16*TIMER2_RATE)))
0000             26   GAIN                             EQU 25
0000             27   ;V2C_DIVISOR                     EQU (GAIN*41)
0000             28   V2C_DIVISOR                      EQU 1051
0000             29   
0000             30   ; /*** PORT DEFINITIONS ***/
0000             31   LCD_RS                   equ P1.3
0000             32   LCD_E                    equ P1.4
0000             33   LCD_D4                   equ P0.0
0000             34   LCD_D5                   equ P0.1
0000             35   LCD_D6                   equ P0.2
0000             36   LCD_D7                   equ P0.3
0000             37   PWM_OUT                  equ P1.0
0000             38   START_BUTTON     equ P0.4
0000             39   ; Analog Input Port Numbering
0000             40   LED_PORT                 equ 0x00                        ; AIN port numbers
0000             41   LM335_PORT               equ 0x05
0000             42   OPAMP_PORT               equ 0x07
0000             43   AINCONFIG                equ 0b10100001          ; bits 1 = toggled analog in
0000             44   
0000             45   ; /*** VECTORS ***/
0000             46   org 0000H
0000 023BBB      47            ljmp Main
0003             48   
002B             49   org 002BH                                        ; timer 2 enable
002B 023962      50            ljmp Timer2_ISR
002E             51   
3000             52   org 3000H                                        ; lookup table stored at APROM address starting 0x4000
3000             53   ;        $NOLIST
                 -1    	$include(thermodata.inc)
3000              1   ; Contains mV offset for Thermocouple
3000              2   ; Stored in APROM location: 0x3000
3000              3   thermodata:
3000 00000027     4       DW  0, 39, 79, 119, 158, 198, 238, 277, 317, 357, 397, 437, 477, 517, 557, 597 
     004F0077
     009E00C6
     00EE0115
     013D0165
     018D01B5
     01DD0205
     022D0255
3020 027D02A5     5       DW  637, 677, 718, 758, 798, 838, 879, 919, 960, 1000, 1041, 1081, 1122, 1163, 1203, 1244
     02CE02F6
     031E0346
     036F0397
     03C003E8
     04110439
     0462048B
     04B304DC
3040 0505052E     6       DW  1285, 1326, 1366, 1407, 1448, 1489, 1530, 1571, 1612, 1653, 1694, 1735, 1776, 1817, 1858, 1899
     0556057F
     05A805D1
     05FA0623
     064C0675
     069E06C7
     06F00719
     0742076B
3060 079507BE     7       DW  1941, 1982, 2023, 2064, 2106, 2147, 2188, 2230, 2271, 2312, 2354, 2395, 2436, 2478, 2519, 2561 
     07E70810
     083A0863
     088C08B6
     08DF0908
     0932095B
     098409AE
     09D70A01
3080 0A2A0A54     8       DW  2602, 2644, 2685, 2727, 2768, 2810, 2851, 2893, 2934, 2976, 3017, 3059, 3100, 3142, 3184, 3225
     0A7D0AA7
     0AD00AFA
     0B230B4D
     0B760BA0
     0BC90BF3
     0C1C0C46
     0C700C99
30A0 0CC30CEC     9       DW  3267, 3308, 3350, 3391, 3433, 3474, 3516, 3557, 3599, 3640, 3682, 3723, 3765, 3806, 3848, 3889 
     0D160D3F
     0D690D92
     0DBC0DE5
     0E0F0E38
     0E620E8B
     0EB50EDE
     0F080F31
30C0 0F5B0F84    10       DW  3931, 3972, 4013, 4055, 4096, 4138, 4179, 4220, 4262, 4303, 4344, 4385, 4427, 4468, 4509, 4550 
     0FAD0FD7
     1000102A
     1053107C
     10A610CF
     10F81121
     114B1174
     119D11C6
30E0 11EF1219    11       DW  4591, 4633, 4674, 4715, 4756, 4797, 4838, 4879, 4920, 4961, 5002, 5043, 5084, 5124, 5165, 5206
     1242126B
     129412BD
     12E6130F
     13381361
     138A13B3
     13DC1404
     142D1456
3100 147F14A8    12       DW  5247, 5288, 5328, 5369, 5410, 5450, 5491, 5532, 5572, 5613, 5653, 5694, 5735, 5775, 5815, 5856
     14D014F9
     1522154A
     1573159C
     15C415ED
     1615163E
     1667168F
     16B716E0
3120 17081731    13       DW  5896, 5937, 5977, 6017, 6058, 6098, 6138, 6179, 6219, 6259, 6299, 6339, 6380, 6420, 6460, 6500
     17591781
     17AA17D2
     17FA1823
     184B1873
     189B18C3
     18EC1914
     193C1964
3140 198C19B4    14       DW  6540, 6580, 6620, 6660, 6701, 6741, 6781, 6821, 6861, 6901, 6941, 6981, 7021, 7060, 7100, 7140
     19DC1A04
     1A2D1A55
     1A7D1AA5
     1ACD1AF5
     1B1D1B45
     1B6D1B94
     1BBC1BE4
3160 1C0C1C34    15       DW  7180, 7220, 7260, 7300, 7340, 7380, 7420, 7460, 7500, 7540, 7579, 7619, 7659, 7699, 7739, 7779
     1C5C1C84
     1CAC1CD4
     1CFC1D24
     1D4C1D74
     1D9B1DC3
     1DEB1E13
     1E3B1E63
3180 1E8B1EB3    16       DW  7819, 7859, 7899, 7939, 7979, 8019, 8059, 8099, 8138, 8178, 8218, 8258, 8298, 8338, 8378, 8418
     1EDB1F03
     1F2B1F53
     1F7B1FA3
     1FCA1FF2
     201A2042
     206A2092
     20BA20E2
31A0 210A2133    17       DW  8458, 8499, 8539, 8579, 8619, 8659, 8699, 8739, 8779, 8819, 8860, 8900, 8940, 8980, 9020, 9061
     215B2183
     21AB21D3
     21FB2223
     224B2273
     229C22C4
     22EC2314
     233C2365
31C0 238D23B5    18       DW  9101, 9141, 9181, 9222, 9262, 9302, 9343, 9383, 9423, 9464, 9504, 9545, 9585, 9626, 9666, 9707
     23DD2406
     242E2456
     247F24A7
     24CF24F8
     25202549
     2571259A
     25C225EB
31E0 2613263C    19       DW  9747, 9788, 9828, 9869, 9909, 9950, 9991, 10031, 10072, 10113, 10153, 10194, 10235, 10276, 10316, 10357 
     2664268D
     26B526DE
     2707272F
     27582781
     27A927D2
     27FB2824
     284C2875
3200 289E28C7    20       DW  10398, 10439, 10480, 10520, 10561, 10602, 10643, 10684, 10725, 10766, 10807, 10848, 10889, 10930, 10971, 11012 
     28F02918
     2941296A
     299329BC
     29E52A0E
     2A372A60
     2A892AB2
     2ADB2B04
3220 2B2D2B56    21       DW  11053, 11094, 11135, 11176, 11217, 11259, 11300, 11341, 11382, 11423, 11465, 11506, 11547, 11588, 11630, 11671
     2B7F2BA8
     2BD12BFB
     2C242C4D
     2C762C9F
     2CC92CF2
     2D1B2D44
     2D6E2D97
3240 2DC02DE9    22       DW  11712, 11753, 11795, 11836, 11877, 11919, 11960, 12001, 12043, 12084, 12126, 12167, 12209, 12250, 12291, 12333
     2E132E3C
     2E652E8F
     2EB82EE1
     2F0B2F34
     2F5E2F87
     2FB12FDA
     3003302D
3260 30563080    23       DW  12374, 12416, 12457, 12499, 12540, 12582, 12624
     30A930D3
     30FC3126
     3150
326E             24   
326E             55   ;        $List
326E             56   
326E             57   ; /*** DIRECT ACCESS VARIABLES @RAM 0x30 -> 0x7F ***/
0030             58   DSEG at 30H
0030             59   x:                       ds 4            ; for math
0034             60   y:                       ds 4
0038             61   data_out:        ds 4            ; for python
003C             62   bcd:                     ds 5            ; for display
0041             63   
0041             64   VLED_ADC:                ds 2            ; for temperature 
0043             65   dtemp:                   ds 2
0045             66   tempc:                   ds 1
0046             67   temp_mc:                 ds 4
004A             68   OPAMP_temp:      ds 4
004E             69   temp_lm:                 ds 4
0052             70   temp_offset:     ds 2
0054             71   mV_offset:       ds 2
0056             72   
0056             73   FSM1_state:      ds 1            ; fsm states
0057             74   
0057             75   pwm_counter:     ds 1            ; time check and pwm
0058             76   count10ms:               ds 1
0059             77   seconds:                 ds 1
005A             78   pwm:                     ds 1
005B             79   abort_time:              ds 1
005C             80   
005C             81   ReflowTemp:      ds 1            ; reflow profile parameters
005D             82   ReflowTime:              ds 1
005E             83   SoakTime:                ds 1
005F             84   
005F             85   Val_test:                ds 4
0063             86   Val_temp:                ds 4
0067             87   
0067             88   ; /*** SINGLE BIT VARIABLES @RAM 0x20 -> 0x2F ***/
0000             89   BSEG 
0000             90   mf:                      dbit 1
0001             91   seconds_flag:    dbit 1
0002             92   s_flag:                  dbit 1
0003             93   
0003             94   ; /*** CODE SEGMENT ***/
326E             95   CSEG
326E             96   ;                     1234567890123456    <- This helps determine the location of the counter
326E 2A2A2A2A    97   test_message:     db '****LOADING*****', 0
     4C4F4144
     494E472A
     2A2A2A2A
     00
327F 54454D50    98   value_message:    db 'TEMP:           ', 0
     3A202020
     20202020
     20202020
     00
3290 4F56454E    99   temp_message:      db 'OVEN TEMP:      ', 0
     2054454D
     503A2020
     20202020
     00
32A1 46415245   100   fah_message:      db 'FARENHET READING', 0
     4E484554
     20524541
     44494E47
     00
32B2 41424F52   101   abort_message:     db 'ABORTABORTABORT ', 0
     5441424F
     52544142
     4F525420
     00
32C3 43757272   102   state_message:     db 'Current State:  ', 0
     656E7420
     53746174
     653A2020
     00
32D4            103   
33C9            122   $LIST
                546   $LIST
37A9            141   $LIST
38DD            111   $LIST
                109   $LIST
38DD            111   
38DD            112   
38DD            113   InitAll:
38DD            114            ; /*** SERIAL PORT INITIALIZATION ***/
38DD 75AC00     115            mov     P3M1,#0x00                      ; Configure all the pins for biderectional I/O
38E0 75AD00     116            mov     P3M2,#0x00
38E3 75B300     117            mov     P1M1,#0x00
38E6 75B400     118            mov     P1M2,#0x00
38E9 75B100     119            mov     P0M1,#0x00
38EC 75B200     120            mov     P0M2,#0x00
38EF            121       ; Since the reset button bounces, we need to wait a bit before
38EF            122       ; sending messages, otherwise we risk displaying gibberish!
38EF            123       ;mov R1, #200
38EF            124       ;mov R0, #104
38EF            125       ;djnz R0, $                                  ; 4 cycles->4*60.285ns*104=25us
38EF            126       ;djnz R1, $-4                                ; 25us*200=5.0ms
38EF 7A05       127       mov R2, #5
38F1 123A4A     128       lcall waitms
38F4            129       ; Now we can proceed with the configuration of the serial port
38F4 438E10     130            orl     CKCON, #0x10                    ; CLK is the input for timer 1
38F7 438780     131            orl     PCON, #0x80                     ; Bit SMOD=1, double baud rate
38FA 759852     132            mov     SCON, #0x52
38FD 53C4DF     133            anl     T3CON, #0b11011111
3900 53890F     134            anl     TMOD, #0x0F                             ; Clear the configuration bits for timer 1
3903 438920     135            orl     TMOD, #0x20                     ; Timer 1 Mode 2
3906 758DF7     136            mov     TH1, #TIMER1_RELOAD
3909 D28E       137            setb TR1
390B            138   
390B            139            ; /*** INITIALIZE THE REST ***/
390B 438E10     140            orl     CKCON, #0x10                    ; CLK is the input for timer 1
390E 438780     141            orl     PCON, #0x80                     ; Bit SMOD=1, double baud rate
3911 759852     142            mov     SCON, #0x52
3914 53C4DF     143            anl     T3CON, #0b11011111
3917 53890F     144            anl     TMOD, #0x0F                     ; Clear the configuration bits for timer 1
391A 438920     145            orl     TMOD, #0x20                     ; Timer 1 Mode 2
391D 758DF7     146            mov     TH1, #TIMER1_RELOAD     ; TH1=TIMER1_RELOAD;
3920 D28E       147            setb TR1
3922            148            
3922            149            ; Using timer 0 for delay functions.  Initialize here:
3922 C28C       150            clr     TR0                                     ; Stop timer 0
3924 438E08     151            orl     CKCON,#0x08                     ; CLK is the input for timer 0
3927 5389F0     152            anl     TMOD,#0xF0                              ; Clear the configuration bits for timer 0
392A 438901     153            orl     TMOD,#0x01                              ; Timer 0 in Mode 1: 16-bit timer
392D            154            
392D            155            ; Initialize the pin used by the ADC (P1.1) as input.
392D 43B302     156            orl     P1M1, #0b00000010
3930 53B4FD     157            anl     P1M2, #0b11111101
3933            158            
3933            159            ; Initialize and start the ADC:
3933 53E8F0     160            anl ADCCON0, #0xF0
3936 43E807     161            orl ADCCON0, #0x07                      ; Select channel 7
3939            162            ; AINDIDS select if some pins are analog inputs or digital I/O:
3939 75F600     163            mov AINDIDS, #0x00                      ; Disable all analog inputs
393C 43F640     164            orl AINDIDS, #0b1000000         ; P1.1 is analog input
393F 43E101     165            orl ADCCON1, #0x01                      ; Enable ADC
3942 755200     166            mov temp_offset, #0x00
3945            167   
3945            168   
3945            169   ;----------------------------------------------------------------;
3945            170   ;                                        TIMER 2 INITIALIZATION
3945            171   ;----------------------------------------------------------------;
3945            172   
3945 75C800     173            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
3948 75CDD7     174            mov TH2, #high(TIMER2_RELOAD)
394B 75CC79     175            mov TL2, #low(TIMER2_RELOAD)
394E            176            ; Set the reload value
394E 75C9A0     177            mov T2MOD, #0b1010_0000 ; Enable timer 2 autoreload, and clock divider is 16
3951 75CBD7     178            mov RCMP2H, #high(TIMER2_RELOAD)
3954 75CA79     179            mov RCMP2L, #low(TIMER2_RELOAD)
3957            180            ; Init the free running 10 ms counter to zero
3957 755700     181            mov pwm_counter, #0
395A            182            ; Enable the timer and interrupts
395A 439B80     183            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
395D D2CA       184       setb TR2  ; Enable timer 2
395F            185   
395F D2AF       186            setb EA ; Enable global interrupts
3961 22         187       ret
3962            188   
3962            189   
3962            190   ;---------------------------------;
3962            191   ; ISR for Timer 2                 ;
3962            192   ;---------------------------------;
3962            193   Timer2_ISR:
3962 C2CF       194            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
3964 C0D0       195            push psw
3966 C0E0       196            push acc
3968            197            
3968 0557       198            inc pwm_counter
396A C3         199            clr c
396B E55A       200            mov a, pwm
396D 9557       201            subb a, pwm_counter ; If pwm_counter <= pwm then c=1
396F B3         202            cpl c
3970 9290       203            mov PWM_OUT, c
3972            204            
3972 E557       205            mov a, pwm_counter
3974 B46435     206            cjne a, #100, Timer2_ISR_done
3977            207            ; executes every second
3977 755700     208            mov pwm_counter, #0
397A 0559       209            inc seconds ; It is super easy to keep a seconds count here
397C D202       210            setb s_flag
397E E556       211            mov a, FSM1_state
3980 B40003     212            cjne a, #0, Abort_Check0                        ; For abort check, the abort should not trigger if you are in state 0
3983 0239AC     213            ljmp Timer2_ISR_done
3986            214   
3986            215   Abort_Check0:
3986            216   ; Check if temperature is above 240. If so, abort
3986 C3         217            clr c
3987 E545       218            mov a, tempc
3989 94F0       219            subb a, #240                                            ; if a is greater than 240, there will be no carry bit so we need to abort
398B 4006       220            jc Abort_Check1                                                 ; if temperature is below 240, continue to next check
398D            221            ; abort routine
398D 75560A     222            mov FSM1_state, #10
3990 0239AC     223       ljmp Timer2_ISR_done                ; if temp is above 240, abort condition has already been triggered, skip ahead to done
3993            224   
3993            225   Abort_Check1:
3993            226   ; Check if temperature is below 50. If so, check for how long
3993 E545       227            mov a, tempc
3995 C3         228            clr c
3996 9432       229            subb a, #50                                                     ; if tempc (stored in a) is less than 50, there will be a carry bit
3998 500F       230            jnc Timer2_ISR_abort_done                       ; skip the abort checks if temperature is above 50
399A            231   
399A            232   Abort_Check2:
399A            233   ; Check if has been 60 seconds (at below 50 degrees)
399A 055B       234            inc abort_time
399C E55B       235            mov a, abort_time
399E C3         236            clr c
399F 943C       237            subb a, #60                                                     ; if abort_time is less than 60, there will be a carry bit
39A1 4009       238            jc Timer2_ISR_done                                      ; if there is a carry 
39A3 75560A     239            mov FSM1_state, #10
39A6 0239AC     240            ljmp Timer2_ISR_done
39A9            241   
39A9            242   Timer2_ISR_abort_done:
39A9 755B00     243            mov abort_time, #0
39AC            244   
39AC            245   Timer2_ISR_done:
39AC D0E0       246            pop acc
39AE D0D0       247            pop psw
39B0 32         248            reti
39B1            249   
39B1            250   line1:
39B1 50574D20   251            DB 'PWM Example     '
     4578616D
     706C6520
     20202020
39C1 00         252            DB 0
39C2            253   line2:
39C2 43686B20   254            DB 'Chk pin 15:P1.0 '
     70696E20
     31353A50
     312E3020
39D2 00         255            DB 0
39D3            256   
39D3            257   ; /* Send a character using the serial port */
39D3            258   putchar:
39D3 3099FD     259       jnb TI, putchar
39D6 C299       260       clr TI
39D8 F599       261       mov SBUF, a
39DA 22         262       ret
39DB            263   
39DB            264   ; Send a constant-zero-terminated string using the serial port
39DB            265   SendString:
39DB E4         266       clr A
39DC 93         267       movc A, @A+DPTR
39DD 6006       268       jz SendStringDone
39DF 1239D3     269       lcall putchar
39E2 A3         270       inc DPTR
39E3 80F6       271       sjmp SendString
39E5            272   SendStringDone:
39E5 22         273       ret
39E6            274   
39E6            275   ; Sends binary data to Python via putchar
39E6            276   SendBin:                                         
39E6 E4         277            clr A                                   ; Sends temp_mc
39E7 E546       278            mov a, temp_mc+0
39E9 1239D3     279            lcall putchar
39EC E4         280            clr A
39ED E547       281            mov a, temp_mc+1
39EF 1239D3     282            lcall putchar
39F2 E4         283            clr A
39F3 E548       284            mov a, temp_mc+2
39F5 1239D3     285            lcall putchar
39F8 E4         286            clr A
39F9 E549       287            mov a, temp_mc+3
39FB 1239D3     288            lcall putchar
39FE            289   
39FE E4         290            clr A                                   ; Sends data_out
39FF E538       291            mov a, data_out+0
3A01 1239D3     292            lcall putchar
3A04 E4         293            clr A
3A05 E539       294            mov a, data_out+1
3A07 1239D3     295            lcall putchar
3A0A E4         296            clr A                                   ; Sends data_out
3A0B E53A       297            mov a, data_out+2
3A0D 1239D3     298            lcall putchar
3A10 E4         299            clr A
3A11 E53B       300            mov a, data_out+3
3A13 1239D3     301            lcall putchar
3A16 22         302            ret
3A17            303   
3A17            304   ASCII_CHAR: 
3A17 30313233   305            db '0123456789ABCDEF'
     34353637
     38394142
     43444546
3A27            306   
3A27            307   Hello_World:
3A27 48656C6C   308       DB  'Hello, World!', '\r', '\n', 0
     6F2C2057
     6F726C64
     210D0A00
3A37            309   New_Line:
3A37 0D0A00     310            DB '\r', '\n', 0
3A3A            311   
3A3A            312   ; /* 1ms DELAY FUNCTIONS */
3A3A            313   wait_1ms:
3A3A C28C       314            clr     TR0 ; Stop timer 0
3A3C C28D       315            clr     TF0 ; Clear overflow flag
3A3E 758CBF     316            mov     TH0, #high(TIMER0_RELOAD_1MS)
3A41 758A28     317            mov     TL0,#low(TIMER0_RELOAD_1MS)
3A44 D28C       318            setb TR0
3A46 308DFD     319            jnb     TF0, $ ; Wait for overflow
3A49 22         320            ret
3A4A            321   waitms:
3A4A 123A3A     322            lcall wait_1ms
3A4D DAFB       323            djnz R2, waitms
3A4F 22         324            ret
3A50            325   
3A50            326   Display_formated_BCD: ;4 dig 
3A50 C0E0       327            push acc
3A52 7401       327            mov a, #1
3A54 14         327            dec a
3A55 12336D     327            lcall ?Set_Cursor_1 ; Select column and row
3A58 D0E0       327            pop acc
3A5A C083       328            push dph
3A5C C082       328            push dpl
3A5E C0E0       328            push acc
3A60 903290     328            mov dptr, #temp_message
3A63 123360     328            lcall ?Send_Constant_String
3A66 D0E0       328            pop acc
3A68 D082       328            pop dpl
3A6A D083       328            pop dph
3A6C C0E0       329            push acc
3A6E 7407       329            mov a, #7
3A70 14         329            dec a
3A71 12336B     329            lcall ?Set_Cursor_2 ; Select column and row
3A74 D0E0       329            pop acc
3A76 C000       330            push ar0
3A78 A83E       330            mov r0, bcd+2
3A7A 123372     330            lcall ?Display_BCD
3A7D D000       330            pop ar0
3A7F C0E0       331            push acc
3A81 7409       331            mov a, #9
3A83 14         331            dec a
3A84 12336B     331            lcall ?Set_Cursor_2 ; Select column and row
3A87 D0E0       331            pop acc
3A89 C000       332            push ar0
3A8B A83D       332            mov r0, bcd+1
3A8D 123372     332            lcall ?Display_BCD
3A90 D000       332            pop ar0
3A92 C0E0       333            push acc
3A94 740A       333            mov a, #10
3A96 14         333            dec a
3A97 12336B     333            lcall ?Set_Cursor_2 ; Select column and row
3A9A D0E0       333            pop acc
3A9C            333   
3A9C C000       334            push ar0
3A9E A83D       334            mov r0, bcd+1
3AA0 123372     334            lcall ?Display_BCD
3AA3 D000       334            pop ar0
3AA5            335            
3AA5 C0E0       336            push acc
3AA7 740C       336            mov a, #12
3AA9 14         336            dec a
3AAA 12336B     336            lcall ?Set_Cursor_2 ; Select column and row
3AAD D0E0       336            pop acc
3AAF C000       337            push ar0
3AB1 A83C       337            mov r0, bcd+0
3AB3 123372     337            lcall ?Display_BCD
3AB6 D000       337            pop ar0
3AB8 C0E0       338            push acc
3ABA 740A       338            mov a, #10
3ABC 14         338            dec a
3ABD 12336B     338            lcall ?Set_Cursor_2 ; Select column and row
3AC0 D0E0       338            pop acc
3AC2 C0E0       339            push acc
3AC4 742E       339            mov a, #'.'
3AC6 123323     339            lcall ?WriteData
3AC9 D0E0       339            pop acc
3ACB C0E0       340            push acc
3ACD 7407       340            mov a, #7
3ACF 14         340            dec a
3AD0 12336B     340            lcall ?Set_Cursor_2 ; Select column and row
3AD3 D0E0       340            pop acc
3AD5 C0E0       341            push acc
3AD7 7420       341            mov a, #0x20
3AD9 123323     341            lcall ?WriteData
3ADC D0E0       341            pop acc
3ADE C0E0       342            push acc
3AE0 740F       342            mov a, #15
3AE2 14         342            dec a
3AE3 12336B     342            lcall ?Set_Cursor_2 ; Select column and row
3AE6 D0E0       342            pop acc
3AE8 C0E0       343            push acc
3AEA 74DF       343            mov a, #0xDF
3AEC 123323     343            lcall ?WriteData
3AEF D0E0       343            pop acc
3AF1 C0E0       344            push acc
3AF3 7410       344            mov a, #16
3AF5 14         344            dec a
3AF6 12336B     344            lcall ?Set_Cursor_2 ; Select column and row
3AF9 D0E0       344            pop acc
3AFB C0E0       345            push acc
3AFD 7443       345            mov a, #'C'
3AFF 123323     345            lcall ?WriteData
3B02 D0E0       345            pop acc
3B04 22         346            ret
3B05            347   
3B05            348   Display_temp_BCD: ;4 dig 
3B05 C0E0       349            push acc
3B07 E53D       350            mov a, bcd+1
3B09 B40003     351            cjne a, #0, Display_temp_BCD2
3B0C 023B64     352            ljmp Display_temp_BCD3
3B0F            353   Display_temp_BCD2:
3B0F C0E0       354            push acc
3B11 7401       354            mov a, #1
3B13 14         354            dec a
3B14 12336B     354            lcall ?Set_Cursor_2 ; Select column and row
3B17 D0E0       354            pop acc
3B19 C083       355            push dph
3B1B C082       355            push dpl
3B1D C0E0       355            push acc
3B1F 903290     355            mov dptr, #temp_message
3B22 123360     355            lcall ?Send_Constant_String
3B25 D0E0       355            pop acc
3B27 D082       355            pop dpl
3B29 D083       355            pop dph
3B2B C0E0       356            push acc
3B2D 740B       356            mov a, #11
3B2F 14         356            dec a
3B30 12336B     356            lcall ?Set_Cursor_2 ; Select column and row
3B33 D0E0       356            pop acc
3B35            356   
3B35 C000       357            push ar0
3B37 A83D       357            mov r0, bcd+1
3B39 123372     357            lcall ?Display_BCD
3B3C D000       357            pop ar0
3B3E C0E0       358            push acc
3B40 740B       358            mov a, #11
3B42 14         358            dec a
3B43 12336B     358            lcall ?Set_Cursor_2 ; Select column and row
3B46 D0E0       358            pop acc
3B48 C0E0       359            push acc
3B4A 7420       359            mov a, #0x20
3B4C 123323     359            lcall ?WriteData
3B4F D0E0       359            pop acc
3B51 C0E0       360            push acc
3B53 740D       360            mov a, #13
3B55 14         360            dec a
3B56 12336B     360            lcall ?Set_Cursor_2 ; Select column and row
3B59 D0E0       360            pop acc
3B5B C000       361            push ar0
3B5D A83C       361            mov r0, bcd+0
3B5F 123372     361            lcall ?Display_BCD
3B62 D000       361            pop ar0
3B64            362   Display_temp_BCD3:
3B64 C0E0       363            push acc
3B66 740C       363            mov a, #12
3B68 14         363            dec a
3B69 12336B     363            lcall ?Set_Cursor_2 ; Select column and row
3B6C D0E0       363            pop acc
3B6E C0E0       364            push acc
3B70 7420       364            mov a, #0x20
3B72 123323     364            lcall ?WriteData
3B75 D0E0       364            pop acc
3B77            365   Display_temp_BCD_done:
3B77 C0E0       366            push acc
3B79 740F       366            mov a, #15
3B7B 14         366            dec a
3B7C 12336B     366            lcall ?Set_Cursor_2 ; Select column and row
3B7F D0E0       366            pop acc
3B81 C0E0       367            push acc
3B83 74DF       367            mov a, #0xDF
3B85 123323     367            lcall ?WriteData
3B88 D0E0       367            pop acc                 ; deg symbol
3B8A C0E0       368            push acc
3B8C 7410       368            mov a, #16
3B8E 14         368            dec a
3B8F 12336B     368            lcall ?Set_Cursor_2 ; Select column and row
3B92 D0E0       368            pop acc
3B94 C0E0       369            push acc
3B96 7443       369            mov a, #'C'
3B98 123323     369            lcall ?WriteData
3B9B D0E0       369            pop acc
3B9D D0E0       370            pop acc
3B9F 22         371            ret
3BA0            372   
3BA0            373   
3BA0            374   ; /* READ ADC */
3BA0            375   Read_ADC:
3BA0 C2EF       376            clr ADCF
3BA2 D2EE       377            setb ADCS ;  ADC start trigger signal
3BA4 30EFFD     378       jnb ADCF, $ ; Wait for conversion complete
3BA7            379       
3BA7            380       ; Read the ADC result and store in [R1, R0]
3BA7 E5C2       381       mov a, ADCRL
3BA9 540F       382       anl a, #0x0f
3BAB F8         383       mov R0, a
3BAC E5C3       384       mov a, ADCRH   
3BAE C4         385       swap a
3BAF C0E0       386       push acc
3BB1 540F       387       anl a, #0x0f
3BB3 F9         388       mov R1, a
3BB4 D0E0       389       pop acc
3BB6 54F0       390       anl a, #0xf0
3BB8 48         391       orl a, R0
3BB9 F8         392       mov R0, A
3BBA 22         393            ret
3BBB            394   
3BBB            395   Main:
3BBB 75817F     396       mov SP, #0x7F        ; Set the stack pointer to the begining of idata
3BBE            397       
3BBE 1238DD     398       lcall InitAll
3BC1 12332D     399       lcall LCD_4BIT
3BC4            400   
3BC4            401            ; Initialize all variables
3BC4 D201       402            setb seconds_flag
3BC6 755600     403            mov FSM1_state, #0
3BC9 755900     404            mov seconds, #0
3BCC 755C00     405            mov ReflowTemp, #0
3BCF 755D00     406            mov ReflowTime, #0
3BD2 755E00     407            mov SoakTime, #0
3BD5            408   
3BD5            409       ; initial messages in LCD
3BD5 C0E0       410            push acc
3BD7 7401       410            mov a, #1
3BD9 14         410            dec a
3BDA 12336D     410            lcall ?Set_Cursor_1 ; Select column and row
3BDD D0E0       410            pop acc
3BDF C083       411            push dph
3BE1 C082       411            push dpl
3BE3 C0E0       411            push acc
3BE5 90326E     411            mov dptr, #test_message
3BE8 123360     411            lcall ?Send_Constant_String
3BEB D0E0       411            pop acc
3BED D082       411            pop dpl
3BEF D083       411            pop dph
3BF1 C0E0       412            push acc
3BF3 7401       412            mov a, #1
3BF5 14         412            dec a
3BF6 12336B     412            lcall ?Set_Cursor_2 ; Select column and row
3BF9 D0E0       412            pop acc
3BFB C083       413            push dph
3BFD C082       413            push dpl
3BFF C0E0       413            push acc
3C01 90327F     413            mov dptr, #value_message
3C04 123360     413            lcall ?Send_Constant_String
3C07 D0E0       413            pop acc
3C09 D082       413            pop dpl
3C0B D083       413            pop dph
3C0D            414   
3C0D            415            ;mov data_out, #0b00000001
3C0D            416   
3C0D            417   ;Forever: ;avaliable: r2, r3
3C0D            418   FSM_sys:
3C0D            419   ; /* TEMP_READ: READS TEMPERATURE */
3C0D            420   ; Note:     Before converting to be stored tempC, 
3C0D            421   ;           all values are stored as 32 bit numbers 
3C0D            422   ;           with 3 decimal points. (in milli-celcius)
3C0D            423   ;           
3C0D            424   ; Example:  2.07 V would be represented by the number
3C0D            425   ;           20700. (The real value * 1000).
3C0D            426   ; TEMP_READ:
3C0D            427   ;        ljmp read_led
3C0D            428   
3C0D            429   ; Avg_ADC:                                               ; function for ADC noise reduction
3C0D            430   ;     Load_X(0)
3C0D            431   ;     mov R5, #255
3C0D            432   ; sum_loop_avg:
3C0D            433   ;     lcall Read_ADC
3C0D            434   ;     mov y+3, #0
3C0D            435   ;     mov y+2, #0
3C0D            436   ;     mov y+1, R1
3C0D            437   ;     mov y+0, R0
3C0D            438   ;     lcall add32
3C0D            439   ;     djnz R5, sum_loop_avg
3C0D            440   ;     Load_y(255)
3C0D            441   ;     lcall div32
3C0D            442   ;     ret
3C0D            443   
3C0D            444   ; read_led:
3C0D            445   ;     anl ADCCON0, #0xf0          ; read led voltage
3C0D            446   ;     orl ADCCON0, #LED_PORT
3C0D            447   ;     lcall Avg_ADC
3C0D            448   ;     mov VLED_ADC+0, R0          ; save reading to VLED_ADC
3C0D            449   ;        mov VLED_ADC+1, R1
3C0D            450   
3C0D            451   ; read_lm335:
3C0D            452   ;     anl ADCCON0, #0xf0          ; *** LM335 ***
3C0D            453   ;     orl ADCCON0, #LM335_PORT
3C0D            454   ;     lcall Avg_ADC
3C0D            455   ;     mov x+0, R0                            ; load lm335 reading to x
3C0D            456   ;        mov x+1, R1
3C0D            457   ;        mov x+2, #0                     
3C0D            458   ;        mov x+3, #0
3C0D            459   ;     Load_y(260000)              ; load const vled ref into y      
3C0D            460   ;     lcall mul32
3C0D            461   ;     mov y+0, VLED_ADC+0            ; import vled reading into y
3C0D            462   ;        mov y+1, VLED_ADC+1         
3C0D            463   ;        mov y+2, #0                     
3C0D            464   ;        mov y+3, #0
3C0D            465   ;     lcall div32
3C0D            466   ;     Load_y(273000)                         ; adjust to 273.000 C offset
3C0D            467   ;        lcall sub32                     ; result of lm335 temp remains in x
3C0D            468   ;        mov temp_lm+0, x+0          ; store 3 decimal lm335 value for later
3C0D            469   ;     mov temp_lm+1, x+1                                 
3C0D            470   ;     mov temp_lm+2, x+2
3C0D            471   ;     mov temp_lm+3, x+3
3C0D            472   
3C0D            473   ; read_opamp:
3C0D            474   ;        anl ADCCON0, #0xf0          ; *** OPAMP ***
3C0D            475   ;     orl ADCCON0, #OPAMP_PORT   ; 
3C0D            476   ;        lcall Avg_ADC
3C0D            477   ;        mov x+0, R0                         ; load opamp reading to x
3C0D            478   ;        mov x+1, R1
3C0D            479   ;        mov x+2, #0                     
3C0D            480   ;        mov x+3, #0
3C0D            481   ;     Load_y(2600)                ; load const vled ref (2070 mV) into y      
3C0D            482   ;     lcall mul32
3C0D            483   ;     mov y+0, VLED_ADC+0            ; import led adc reading into y
3C0D            484   ;        mov y+1, VLED_ADC+1                
3C0D            485   ;        mov y+2, #0                     
3C0D            486   ;        mov y+3, #0
3C0D            487   ;     lcall div32                 ; x value now stores OPAMP V in mV
3C0D            488   ;        Load_y(1000)                            
3C0D            489   ;        lcall mul32                                     ; turn mV to uV
3C0D            490   ;        Load_y(V2C_DIVISOR)
3C0D            491   ;        lcall div32                                     ; deg C reading now in x        
3C0D            492   ;        Load_y(1000)
3C0D            493   ;        lcall mul32                                     ; conv to mV again to add to lm335 data
3C0D            494   
3C0D            495   ; add_lm335_to_opamp:
3C0D            496   ;     mov y+0, temp_lm+0         ; load lm335 temp to y
3C0D            497   ;     mov y+1, temp_lm+1
3C0D            498   ;     mov y+2, temp_lm+2
3C0D            499   ;     mov y+3, temp_lm+3
3C0D            500   ;     lcall add32                        ; lm335 + opamp = real temp
3C0D            501   ;     mov temp_mc+0, x+0          ; store result in temp_mc (for python)
3C0D            502   ;     mov temp_mc+1, x+1                                 
3C0D            503   ;     mov temp_mc+2, x+2
3C0D            504   ;     mov temp_mc+3, x+3
3C0D            505            
3C0D            506   ; export_to_main:                                        ; exports temp reading to rest of code
3C0D            507   ;        mov x+0, temp_mc+0          
3C0D            508   ;     mov x+1, temp_mc+1
3C0D            509   ;     mov x+2, temp_mc+2
3C0D            510   ;     mov x+3, temp_mc+3
3C0D            511   ;     Load_y(1000)
3C0D            512   ;     lcall div32
3C0D            513   ;     mov tempc, x+0              ; Both tempc and x now stores temp (C)                 
3C0D 1237DD     514   lcall TEMP_READ
3C10            515   
3C10            516   
3C10            517   
3C10            518   export_to_bcd:                                   ; sends temp reading in C to bcd
3C10 1233C9     519            lcall hex2bcd
3C13 123B05     520            lcall Display_temp_BCD
3C16            521   
3C16            522   Export:                                                  ; Data export to python
3C16 7AFA       523            mov R2, #250                            ; Wait 500 ms between conversions
3C18 123A4A     524            lcall waitms
3C1B 7AFA       525            mov R2, #250
3C1D 123A4A     526            lcall waitms                            ; Sends binary contents of 
3C20 1239E6     527       lcall SendBin                                ; temp_mc and data_out to python
3C23            528   
3C23            529            ; /* FSM1 STATE CHANGE CONTROLS */
3C23 023C26     530            ljmp FSM1
3C26            531   
3C26            532   ; REQUIREMENTS
3C26            533   ; Start/Stop button, to do this, make routine which displays "stopped" for a little bit
3C26            534   ; Temperature display, implemented already
3C26            535   ; Running time display, implement in main
3C26            536   ; 
3C26            537   
3C26            538   
3C26            539   FSM1:
3C26 E556       540            mov a, FSM1_state
3C28 C0E0       541            push acc
3C2A 7401       541            mov a, #1
3C2C 14         541            dec a
3C2D 12336D     541            lcall ?Set_Cursor_1 ; Select column and row
3C30 D0E0       541            pop acc
3C32 C083       542            push dph
3C34 C082       542            push dpl
3C36 C0E0       542            push acc
3C38 9032C3     542            mov dptr, #state_message
3C3B 123360     542            lcall ?Send_Constant_String
3C3E D0E0       542            pop acc
3C40 D082       542            pop dpl
3C42 D083       542            pop dph
3C44            543   
3C44            544   FSM1_state0:
3C44 B40024     545            cjne a, #0, FSM1_state1 ; if FSM1_state (currently stored in a) is not equal to zero (ie. state zero), go to state 1
3C47 755A00     546            mov pwm, #0
3C4A C0E0       547            push acc
3C4C 740E       547            mov a, #14
3C4E 14         547            dec a
3C4F 12336D     547            lcall ?Set_Cursor_1 ; Select column and row
3C52 D0E0       547            pop acc
3C54 C000       548            push ar0
3C56 7800       548            mov r0, #0x00
3C58 123372     548            lcall ?Display_BCD
3C5B D000       548            pop ar0
3C5D C201       549            clr seconds_flag
3C5F            550            ; check for push button input
3C5F 208406     551            jb START_BUTTON, FSM1_state0_done
3C62 3084FD     552            jnb START_BUTTON, $ ; Wait for key release
3C65 755601     553            mov FSM1_state, #1
3C68            554   
3C68            555   FSM1_state0_done:
3C68 023C0D     556            ljmp FSM_sys
3C6B            557   
3C6B            558   FSM1_state1:
3C6B B40126     559            cjne a, #1, FSM1_state2
3C6E 755A64     560            mov pwm, #100
3C71 C0E0       561            push acc
3C73 740E       561            mov a, #14
3C75 14         561            dec a
3C76 12336D     561            lcall ?Set_Cursor_1 ; Select column and row
3C79 D0E0       561            pop acc
3C7B C000       562            push ar0
3C7D 7801       562            mov r0, #0x01
3C7F 123372     562            lcall ?Display_BCD
3C82 D000       562            pop ar0
3C84 755900     563            mov seconds, #0
3C87 7496       564            mov a, #150
3C89 C3         565            clr c
3C8A 9545       566            subb a, tempc
3C8C 5003       567            jnc FSM1_state1_done
3C8E 755602     568            mov FSM1_state, #2
3C91            569   
3C91            570   FSM1_state1_done:
3C91 023C0D     571            ljmp FSM_sys
3C94            572   
3C94            573   FSM1_state2:
3C94 B4022E     574            cjne a, #2, FSM1_state3
3C97 755A14     575            mov pwm, #20
3C9A C0E0       576            push acc
3C9C 740E       576            mov a, #14
3C9E 14         576            dec a
3C9F 12336D     576            lcall ?Set_Cursor_1 ; Select column and row
3CA2 D0E0       576            pop acc
3CA4 C000       577            push ar0
3CA6 7802       577            mov r0, #0x02
3CA8 123372     577            lcall ?Display_BCD
3CAB D000       577            pop ar0
3CAD 30010A     578            jnb seconds_flag, FSM_state2_funk
3CB0            579            ;mov a, #60
3CB0 E55E       580            mov a, SoakTime
3CB2 C3         581            clr c
3CB3 9559       582            subb a, seconds                 ; Want time to be greater than 60 seconds
3CB5 400B       583            jc FSM1_state2_done
3CB7 755603     584            mov FSM1_state, #3
3CBA            585   
3CBA            586   FSM_state2_funk:
3CBA 755900     587            mov seconds, #0         ; Set seconds so we can count up to the required time 
3CBD D201       588            setb seconds_flag       ; seconds flag so we don't reset seconds_flag multiple times
3CBF 023C94     589            ljmp FSM1_state2        
3CC2            590   
3CC2            591   FSM1_state2_done:
3CC2 023C0D     592            ljmp FSM_sys
3CC5            593   
3CC5            594   FSM1_state3:
3CC5 B40325     595            cjne a, #3, FSM1_state4
3CC8 755A64     596            mov pwm, #100
3CCB C0E0       597            push acc
3CCD 740E       597            mov a, #14
3CCF 14         597            dec a
3CD0 12336D     597            lcall ?Set_Cursor_1 ; Select column and row
3CD3 D0E0       597            pop acc
3CD5 C000       598            push ar0
3CD7 7803       598            mov r0, #0x03
3CD9 123372     598            lcall ?Display_BCD
3CDC D000       598            pop ar0
3CDE            599            ;mov a, #220
3CDE E55C       600            mov a, ReflowTemp
3CE0 C201       601            clr seconds_flag
3CE2 C3         602            clr c
3CE3 9545       603            subb a, tempc
3CE5 5003       604            jnc FSM1_state3_done
3CE7 755604     605            mov FSM1_state, #4
3CEA            606   
3CEA            607   FSM1_state3_done:
3CEA 023C0D     608            ljmp FSM_sys
3CED            609   
3CED            610   FSM1_state4:
3CED B4042E     611            cjne a, #4, FSM1_state5
3CF0 755A14     612            mov pwm, #20 
3CF3 C0E0       613            push acc
3CF5 740E       613            mov a, #14
3CF7 14         613            dec a
3CF8 12336D     613            lcall ?Set_Cursor_1 ; Select column and row
3CFB D0E0       613            pop acc
3CFD C000       614            push ar0
3CFF 7804       614            mov r0, #0x04
3D01 123372     614            lcall ?Display_BCD
3D04 D000       614            pop ar0
3D06 30010A     615            jnb seconds_flag, FSM1_state4_funk
3D09            616            ;mov a, #45
3D09 E55D       617            mov a, ReflowTime
3D0B C3         618            clr c 
3D0C 9559       619            subb a, seconds ; when seconds is greater than 45, there will be a carry bit
3D0E 400B       620            jc FSM1_state4_done
3D10 755605     621            mov FSM1_state, #5
3D13            622   
3D13            623   FSM1_state4_funk:
3D13 755900     624            mov seconds, #0
3D16 D201       625            setb seconds_flag
3D18 023CED     626            ljmp FSM1_state4
3D1B            627   
3D1B            628   FSM1_state4_done:
3D1B 023C0D     629            ljmp FSM_sys
3D1E            630   
3D1E            631   FSM1_state5:
3D1E B40523     632            cjne a, #5, FSM1_abort_state            ; if the state is not in 0-5, then it must be 10 (aka the abort state)
3D21 755A00     633            mov pwm, #0
3D24 C0E0       634            push acc
3D26 740E       634            mov a, #14
3D28 14         634            dec a
3D29 12336D     634            lcall ?Set_Cursor_1 ; Select column and row
3D2C D0E0       634            pop acc
3D2E C000       635            push ar0
3D30 7804       635            mov r0, #0x04
3D32 123372     635            lcall ?Display_BCD
3D35 D000       635            pop ar0
3D37 743C       636            mov a, #60
3D39 C3         637            clr c
3D3A 9545       638            subb a, tempc
3D3C 4003       639            jc FSM1_state5_done
3D3E 755600     640            mov FSM1_state, #0
3D41            641   
3D41            642   FSM1_state5_done:
3D41 023C0D     643            ljmp FSM_sys
3D44            644   
3D44            645   FSM1_abort_state:                                                ; When the abort state is triggered, turn everything off and remain in this state utill you reset
3D44 755A00     646            mov pwm, #0
3D47 C0E0       647            push acc
3D49 7401       647            mov a, #1
3D4B 14         647            dec a
3D4C 12336D     647            lcall ?Set_Cursor_1 ; Select column and row
3D4F D0E0       647            pop acc
3D51 C083       648            push dph
3D53 C082       648            push dpl
3D55 C0E0       648            push acc
3D57 9032B2     648            mov dptr, #abort_message
3D5A 123360     648            lcall ?Send_Constant_String
3D5D D0E0       648            pop acc
3D5F D082       648            pop dpl
3D61 D083       648            pop dph
3D63            649   
3D63 023D44     650            ljmp FSM1_abort_state
3D66            651   
3D66            652   END
