                  2   $LIST
0000              4   
0000              5   ;  N76E003 pinout:
0000              6   ;                               -------
0000              7   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000              8   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000              9   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             10   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             11   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             12   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             13   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             14   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             15   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             16   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             17   ;                               -------
0000             18   ;
0000             19   
0000             20   CLK                 EQU 16600000                                                 ; Microcontroller system frequency in Hz
0000             21   BAUD                EQU 115200                                                   ; Baud rate of UART in bps
0000             22   TIMER1_RELOAD       EQU (0x100-(CLK/(16*BAUD)))
0000             23   TIMER0_RELOAD_1MS   EQU (0x10000-(CLK/1000))
0000             24   TIMER2_RATE              EQU 100                                                         ; 1/100 = 10ms
0000             25   TIMER2_RELOAD            EQU (65536-(CLK/(16*TIMER2_RATE)))
0000             26   GAIN                             EQU 330
0000             27   V2C_DIVISOR                      EQU (330*41)
0000             28   
0000             29   ; /*** PORT DEFINITIONS ***/
0000             30   LCD_RS                   equ P1.3
0000             31   LCD_E                    equ P1.4
0000             32   LCD_D4                   equ P0.0
0000             33   LCD_D5                   equ P0.1
0000             34   LCD_D6                   equ P0.2
0000             35   LCD_D7                   equ P0.3
0000             36   PWM_OUT                  equ P1.0
0000             37   START_BUTTON     equ P0.4
0000             38   ; Analog Input Port Numbering
0000             39   LED_PORT                 equ 0x00                        ; AIN port numbers
0000             40   LM335_PORT               equ 0x05
0000             41   OPAMP_PORT               equ 0x07
0000             42   
0000             43   ; /*** VECTORS ***/
0000             44   org 0000H
0000 02391B      45            ljmp Main
0003             46   
002B             47   org 002BH                                        ; timer 2 enable
002B 023760      48            ljmp Timer2_ISR
002E             49   
3000             50   org 3000H                                        ; lookup table stored at APROM address starting 0x4000
3000             51   ;        $NOLIST
                 -1    	$include(thermodata.inc)
3000              1   ; Contains mV offset for Thermocouple
3000              2   ; Stored in APROM location: 0x3000
3000              3   thermodata:
3000 00000027     4       DW  0, 39, 79, 119, 158, 198, 238, 277, 317, 357, 397, 437, 477, 517, 557, 597 
     004F0077
     009E00C6
     00EE0115
     013D0165
     018D01B5
     01DD0205
     022D0255
3020 027D02A5     5       DW  637, 677, 718, 758, 798, 838, 879, 919, 960, 1000, 1041, 1081, 1122, 1163, 1203, 1244
     02CE02F6
     031E0346
     036F0397
     03C003E8
     04110439
     0462048B
     04B304DC
3040 0505052E     6       DW  1285, 1326, 1366, 1407, 1448, 1489, 1530, 1571, 1612, 1653, 1694, 1735, 1776, 1817, 1858, 1899
     0556057F
     05A805D1
     05FA0623
     064C0675
     069E06C7
     06F00719
     0742076B
3060 079507BE     7       DW  1941, 1982, 2023, 2064, 2106, 2147, 2188, 2230, 2271, 2312, 2354, 2395, 2436, 2478, 2519, 2561 
     07E70810
     083A0863
     088C08B6
     08DF0908
     0932095B
     098409AE
     09D70A01
3080 0A2A0A54     8       DW  2602, 2644, 2685, 2727, 2768, 2810, 2851, 2893, 2934, 2976, 3017, 3059, 3100, 3142, 3184, 3225
     0A7D0AA7
     0AD00AFA
     0B230B4D
     0B760BA0
     0BC90BF3
     0C1C0C46
     0C700C99
30A0 0CC30CEC     9       DW  3267, 3308, 3350, 3391, 3433, 3474, 3516, 3557, 3599, 3640, 3682, 3723, 3765, 3806, 3848, 3889 
     0D160D3F
     0D690D92
     0DBC0DE5
     0E0F0E38
     0E620E8B
     0EB50EDE
     0F080F31
30C0 0F5B0F84    10       DW  3931, 3972, 4013, 4055, 4096, 4138, 4179, 4220, 4262, 4303, 4344, 4385, 4427, 4468, 4509, 4550 
     0FAD0FD7
     1000102A
     1053107C
     10A610CF
     10F81121
     114B1174
     119D11C6
30E0 11EF1219    11       DW  4591, 4633, 4674, 4715, 4756, 4797, 4838, 4879, 4920, 4961, 5002, 5043, 5084, 5124, 5165, 5206
     1242126B
     129412BD
     12E6130F
     13381361
     138A13B3
     13DC1404
     142D1456
3100 147F14A8    12       DW  5247, 5288, 5328, 5369, 5410, 5450, 5491, 5532, 5572, 5613, 5653, 5694, 5735, 5775, 5815, 5856
     14D014F9
     1522154A
     1573159C
     15C415ED
     1615163E
     1667168F
     16B716E0
3120 17081731    13       DW  5896, 5937, 5977, 6017, 6058, 6098, 6138, 6179, 6219, 6259, 6299, 6339, 6380, 6420, 6460, 6500
     17591781
     17AA17D2
     17FA1823
     184B1873
     189B18C3
     18EC1914
     193C1964
3140 198C19B4    14       DW  6540, 6580, 6620, 6660, 6701, 6741, 6781, 6821, 6861, 6901, 6941, 6981, 7021, 7060, 7100, 7140
     19DC1A04
     1A2D1A55
     1A7D1AA5
     1ACD1AF5
     1B1D1B45
     1B6D1B94
     1BBC1BE4
3160 1C0C1C34    15       DW  7180, 7220, 7260, 7300, 7340, 7380, 7420, 7460, 7500, 7540, 7579, 7619, 7659, 7699, 7739, 7779
     1C5C1C84
     1CAC1CD4
     1CFC1D24
     1D4C1D74
     1D9B1DC3
     1DEB1E13
     1E3B1E63
3180 1E8B1EB3    16       DW  7819, 7859, 7899, 7939, 7979, 8019, 8059, 8099, 8138, 8178, 8218, 8258, 8298, 8338, 8378, 8418
     1EDB1F03
     1F2B1F53
     1F7B1FA3
     1FCA1FF2
     201A2042
     206A2092
     20BA20E2
31A0 210A2133    17       DW  8458, 8499, 8539, 8579, 8619, 8659, 8699, 8739, 8779, 8819, 8860, 8900, 8940, 8980, 9020, 9061
     215B2183
     21AB21D3
     21FB2223
     224B2273
     229C22C4
     22EC2314
     233C2365
31C0 238D23B5    18       DW  9101, 9141, 9181, 9222, 9262, 9302, 9343, 9383, 9423, 9464, 9504, 9545, 9585, 9626, 9666, 9707
     23DD2406
     242E2456
     247F24A7
     24CF24F8
     25202549
     2571259A
     25C225EB
31E0 2613263C    19       DW  9747, 9788, 9828, 9869, 9909, 9950, 9991, 10031, 10072, 10113, 10153, 10194, 10235, 10276, 10316, 10357 
     2664268D
     26B526DE
     2707272F
     27582781
     27A927D2
     27FB2824
     284C2875
3200 289E28C7    20       DW  10398, 10439, 10480, 10520, 10561, 10602, 10643, 10684, 10725, 10766, 10807, 10848, 10889, 10930, 10971, 11012 
     28F02918
     2941296A
     299329BC
     29E52A0E
     2A372A60
     2A892AB2
     2ADB2B04
3220 2B2D2B56    21       DW  11053, 11094, 11135, 11176, 11217, 11259, 11300, 11341, 11382, 11423, 11465, 11506, 11547, 11588, 11630, 11671
     2B7F2BA8
     2BD12BFB
     2C242C4D
     2C762C9F
     2CC92CF2
     2D1B2D44
     2D6E2D97
3240 2DC02DE9    22       DW  11712, 11753, 11795, 11836, 11877, 11919, 11960, 12001, 12043, 12084, 12126, 12167, 12209, 12250, 12291, 12333
     2E132E3C
     2E652E8F
     2EB82EE1
     2F0B2F34
     2F5E2F87
     2FB12FDA
     3003302D
3260 30563080    23       DW  12374, 12416, 12457, 12499, 12540, 12582, 12624
     30A930D3
     30FC3126
     3150
326E             24   
326E             53   ;        $List
326E             54   
326E             55   ; /*** DIRECT ACCESS VARIABLES @RAM 0x30 -> 0x7F ***/
0030             56   DSEG at 30H
0030             57   x:                       ds 4            ; for math
0034             58   y:                       ds 4
0038             59   data_out:        ds 4            ; for python
003C             60   bcd:                     ds 5            ; for display
0041             61   
0041             62   VLED_ADC:                ds 2            ; for temperature 
0043             63   dtemp:                   ds 2
0045             64   tempc:                   ds 1
0046             65   temp_mc:                 ds 4
004A             66   OPAMP_temp:      ds 4
004E             67   temp_lm:                 ds 4
0052             68   temp_offset:     ds 2
0054             69   mV_offset:       ds 2
0056             70   
0056             71   FSM1_state:      ds 1            ; fsm states
0057             72   
0057             73   pwm_counter:     ds 1            ; time check and pwm
0058             74   count10ms:               ds 1
0059             75   seconds:                 ds 1
005A             76   pwm:                     ds 1
005B             77   abort_time:              ds 1
005C             78   
005C             79   ReflowTemp:      ds 1            ; reflow profile parameters
005D             80   ReflowTime:              ds 1
005E             81   SoakTime:                ds 1
005F             82   
005F             83   Val_test:                ds 4
0063             84   Val_temp:                ds 4
0067             85   
0067             86   ; /*** SINGLE BIT VARIABLES @RAM 0x20 -> 0x2F ***/
0000             87   BSEG 
0000             88   mf:                      dbit 1
0001             89   seconds_flag:    dbit 1
0002             90   s_flag:                  dbit 1
0003             91   
0003             92   ; /*** CODE SEGMENT ***/
326E             93   CSEG
326E             94   ;                     1234567890123456    <- This helps determine the location of the counter
326E 2A2A2A2A    95   test_message:     db '****LOADING*****', 0
     4C4F4144
     494E472A
     2A2A2A2A
     00
327F 54454D50    96   value_message:    db 'TEMP:      ', 0
     3A202020
     20202000
328B 43454C43    97   cel_message:       db 'CELCIUS  READING',0
     49555320
     20524541
     44494E47
     00
329C 46415245    98   fah_message:      db 'FARENHET READING',0
     4E484554
     20524541
     44494E47
     00
32AD 41424F52    99   abort_message:     db 'ABORTABORTABORT ', 0
     5441424F
     52544142
     4F525420
     00
32BE            100   
33B3            122   $LIST
                546   $LIST
36DB             76   $LIST
                105   $LIST
36DB            107   
36DB            108   
36DB            109   InitAll:
36DB            110            ; /*** SERIAL PORT INITIALIZATION ***/
36DB 75AC00     111            mov     P3M1,#0x00                      ; Configure all the pins for biderectional I/O
36DE 75AD00     112            mov     P3M2,#0x00
36E1 75B300     113            mov     P1M1,#0x00
36E4 75B400     114            mov     P1M2,#0x00
36E7 75B100     115            mov     P0M1,#0x00
36EA 75B200     116            mov     P0M2,#0x00
36ED            117       ; Since the reset button bounces, we need to wait a bit before
36ED            118       ; sending messages, otherwise we risk displaying gibberish!
36ED            119       ;mov R1, #200
36ED            120       ;mov R0, #104
36ED            121       ;djnz R0, $                                  ; 4 cycles->4*60.285ns*104=25us
36ED            122       ;djnz R1, $-4                                ; 25us*200=5.0ms
36ED 7A05       123       mov R2, #5
36EF 123845     124       lcall waitms
36F2            125       ; Now we can proceed with the configuration of the serial port
36F2 438E10     126            orl     CKCON, #0x10                    ; CLK is the input for timer 1
36F5 438780     127            orl     PCON, #0x80                     ; Bit SMOD=1, double baud rate
36F8 759852     128            mov     SCON, #0x52
36FB 53C4DF     129            anl     T3CON, #0b11011111
36FE 53890F     130            anl     TMOD, #0x0F                             ; Clear the configuration bits for timer 1
3701 438920     131            orl     TMOD, #0x20                     ; Timer 1 Mode 2
3704 758DF7     132            mov     TH1, #TIMER1_RELOAD
3707 D28E       133            setb TR1
3709            134   
3709            135            ; /*** INITIALIZE THE REST ***/
3709 438E10     136            orl     CKCON, #0x10                    ; CLK is the input for timer 1
370C 438780     137            orl     PCON, #0x80                     ; Bit SMOD=1, double baud rate
370F 759852     138            mov     SCON, #0x52
3712 53C4DF     139            anl     T3CON, #0b11011111
3715 53890F     140            anl     TMOD, #0x0F                     ; Clear the configuration bits for timer 1
3718 438920     141            orl     TMOD, #0x20                     ; Timer 1 Mode 2
371B 758DF7     142            mov     TH1, #TIMER1_RELOAD     ; TH1=TIMER1_RELOAD;
371E D28E       143            setb TR1
3720            144            
3720            145            ; Using timer 0 for delay functions.  Initialize here:
3720 C28C       146            clr     TR0                                     ; Stop timer 0
3722 438E08     147            orl     CKCON,#0x08                     ; CLK is the input for timer 0
3725 5389F0     148            anl     TMOD,#0xF0                              ; Clear the configuration bits for timer 0
3728 438901     149            orl     TMOD,#0x01                              ; Timer 0 in Mode 1: 16-bit timer
372B            150            
372B            151            ; Initialize the pin used by the ADC (P1.1) as input.
372B 43B302     152            orl     P1M1, #0b00000010
372E 53B4FD     153            anl     P1M2, #0b11111101
3731            154            
3731            155            ; Initialize and start the ADC:
3731 53E8F0     156            anl ADCCON0, #0xF0
3734 43E807     157            orl ADCCON0, #0x07                      ; Select channel 7
3737            158            ; AINDIDS select if some pins are analog inputs or digital I/O:
3737 75F600     159            mov AINDIDS, #0x00                      ; Disable all analog inputs
373A 43F680     160            orl AINDIDS, #0b10000000        ; P1.1 is analog input
373D 43E101     161            orl ADCCON1, #0x01                      ; Enable ADC
3740 755200     162            mov temp_offset, #0x00
3743            163   
3743            164   
3743            165   ;----------------------------------------------------------------;
3743            166   ;                                        TIMER 2 INITIALIZATION
3743            167   ;----------------------------------------------------------------;
3743            168   
3743 75C800     169            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
3746 75CDD7     170            mov TH2, #high(TIMER2_RELOAD)
3749 75CC79     171            mov TL2, #low(TIMER2_RELOAD)
374C            172            ; Set the reload value
374C 75C9A0     173            mov T2MOD, #0b1010_0000 ; Enable timer 2 autoreload, and clock divider is 16
374F 75CBD7     174            mov RCMP2H, #high(TIMER2_RELOAD)
3752 75CA79     175            mov RCMP2L, #low(TIMER2_RELOAD)
3755            176            ; Init the free running 10 ms counter to zero
3755 755700     177            mov pwm_counter, #0
3758            178            ; Enable the timer and interrupts
3758 439B80     179            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
375B D2CA       180       setb TR2  ; Enable timer 2
375D            181   
375D D2AF       182            setb EA ; Enable global interrupts
375F 22         183       ret
3760            184   
3760            185   
3760            186   ;---------------------------------;
3760            187   ; ISR for Timer 2                 ;
3760            188   ;---------------------------------;
3760            189   Timer2_ISR:
3760 C2CF       190            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
3762 C0D0       191            push psw
3764 C0E0       192            push acc
3766            193            
3766 0557       194            inc pwm_counter
3768 C3         195            clr c
3769 E55A       196            mov a, pwm
376B 9557       197            subb a, pwm_counter ; If pwm_counter <= pwm then c=1
376D B3         198            cpl c
376E 9290       199            mov PWM_OUT, c
3770            200            
3770 E557       201            mov a, pwm_counter
3772 B46432     202            cjne a, #100, Timer2_ISR_done
3775            203            ; executes every second
3775 755700     204            mov pwm_counter, #0
3778 0559       205            inc seconds ; It is super easy to keep a seconds count here
377A D202       206            setb s_flag
377C E556       207            mov a, FSM1_state
377E B40003     208            cjne a, #0, Abort_Check0                        ; For abort check, the abort should not trigger if you are in state 0
3781 0237A7     209            ljmp Timer2_ISR_done
3784            210   
3784            211   Abort_Check0:
3784            212   ; Check if temperature is above 240. If so, abort
3784 C3         213            clr c
3785 E545       214            mov a, tempc
3787 94F0       215            subb a, #240                                            ; if a is greater than 240, there will be no carry bit so we need to abort
3789 4006       216            jc Abort_Check1                                                 ; if temperature is below 240, continue to next check
378B            217            ; abort routine
378B 75560A     218            mov FSM1_state, #10
378E 0237A7     219       ljmp Timer2_ISR_done                ; if temp is above 240, abort condition has already been triggered, skip ahead to done
3791            220   
3791            221   Abort_Check1:
3791            222   ; Check if temperature is below 50. If so, check for how long
3791 E545       223            mov a, tempc
3793 C3         224            clr c
3794 9432       225            subb a, #50                                                     ; if tempc (stored in a) is less than 50, there will be a carry bit
3796 500C       226            jnc Timer2_ISR_abort_done                       ; skip the abort checks if temperature is above 50
3798            227   
3798            228   Abort_Check2:
3798            229   ; Check if has been 60 seconds (at below 50 degrees)
3798 055B       230            inc abort_time
379A E55B       231            mov a, abort_time
379C C3         232            clr c
379D 943C       233            subb a, #60                                                     ; if abort_time is less than 60, there will be a carry bit
379F 5006       234            jnc Timer2_ISR_done                                     ; if there is a carry 
37A1 75560A     235            mov FSM1_state, #10
37A4            236   
37A4            237   Timer2_ISR_abort_done:
37A4 755B00     238            mov abort_time, #0
37A7            239   
37A7            240   Timer2_ISR_done:
37A7 D0E0       241            pop acc
37A9 D0D0       242            pop psw
37AB 32         243            reti
37AC            244   
37AC            245   line1:
37AC 50574D20   246            DB 'PWM Example     '
     4578616D
     706C6520
     20202020
37BC 00         247            DB 0
37BD            248   line2:
37BD 43686B20   249            DB 'Chk pin 15:P1.0 '
     70696E20
     31353A50
     312E3020
37CD 00         250            DB 0
37CE            251   
37CE            252   ; /* Send a character using the serial port */
37CE            253   putchar:
37CE 3099FD     254       jnb TI, putchar
37D1 C299       255       clr TI
37D3 F599       256       mov SBUF, a
37D5 22         257       ret
37D6            258   
37D6            259   ; Send a constant-zero-terminated string using the serial port
37D6            260   SendString:
37D6 E4         261       clr A
37D7 93         262       movc A, @A+DPTR
37D8 6006       263       jz SendStringDone
37DA 1237CE     264       lcall putchar
37DD A3         265       inc DPTR
37DE 80F6       266       sjmp SendString
37E0            267   SendStringDone:
37E0 22         268       ret
37E1            269   
37E1            270   ; Sends binary data to Python via putchar
37E1            271   SendBin:                                         
37E1 E4         272            clr A                                   ; Sends temp_mc
37E2 E546       273            mov a, temp_mc+0
37E4 1237CE     274            lcall putchar
37E7 E4         275            clr A
37E8 E547       276            mov a, temp_mc+1
37EA 1237CE     277            lcall putchar
37ED E4         278            clr A
37EE E548       279            mov a, temp_mc+2
37F0 1237CE     280            lcall putchar
37F3 E4         281            clr A
37F4 E549       282            mov a, temp_mc+3
37F6 1237CE     283            lcall putchar
37F9            284   
37F9 E4         285            clr A                                   ; Sends data_out
37FA E538       286            mov a, data_out+0
37FC 1237CE     287            lcall putchar
37FF E4         288            clr A
3800 E539       289            mov a, data_out+1
3802 1237CE     290            lcall putchar
3805 E4         291            clr A                                   ; Sends data_out
3806 E53A       292            mov a, data_out+2
3808 1237CE     293            lcall putchar
380B E4         294            clr A
380C E53B       295            mov a, data_out+3
380E 1237CE     296            lcall putchar
3811 22         297            ret
3812            298   
3812            299   ASCII_CHAR: 
3812 30313233   300            db '0123456789ABCDEF'
     34353637
     38394142
     43444546
3822            301   
3822            302   Hello_World:
3822 48656C6C   303       DB  'Hello, World!', '\r', '\n', 0
     6F2C2057
     6F726C64
     210D0A00
3832            304   New_Line:
3832 0D0A00     305            DB '\r', '\n', 0
3835            306   
3835            307   ; /* 1ms DELAY FUNCTIONS */
3835            308   wait_1ms:
3835 C28C       309            clr     TR0 ; Stop timer 0
3837 C28D       310            clr     TF0 ; Clear overflow flag
3839 758CBF     311            mov     TH0, #high(TIMER0_RELOAD_1MS)
383C 758A28     312            mov     TL0,#low(TIMER0_RELOAD_1MS)
383F D28C       313            setb TR0
3841 308DFD     314            jnb     TF0, $ ; Wait for overflow
3844 22         315            ret
3845            316   waitms:
3845 123835     317            lcall wait_1ms
3848 DAFB       318            djnz R2, waitms
384A 22         319            ret
384B            320   
384B            321   Display_formated_BCD: ;4 dig 
384B C0E0       322            push acc
384D 7401       322            mov a, #1
384F 14         322            dec a
3850 123357     322            lcall ?Set_Cursor_1 ; Select column and row
3853 D0E0       322            pop acc
3855 C083       323            push dph
3857 C082       323            push dpl
3859 C0E0       323            push acc
385B 90328B     323            mov dptr, #cel_message
385E 12334A     323            lcall ?Send_Constant_String
3861 D0E0       323            pop acc
3863 D082       323            pop dpl
3865 D083       323            pop dph
3867 C0E0       324            push acc
3869 7407       324            mov a, #7
386B 14         324            dec a
386C 123355     324            lcall ?Set_Cursor_2 ; Select column and row
386F D0E0       324            pop acc
3871            324   
3871 C000       325            push ar0
3873 A83E       325            mov r0, bcd+2
3875 12335C     325            lcall ?Display_BCD
3878 D000       325            pop ar0
387A C0E0       326            push acc
387C 7409       326            mov a, #9
387E 14         326            dec a
387F 123355     326            lcall ?Set_Cursor_2 ; Select column and row
3882 D0E0       326            pop acc
3884 C000       327            push ar0
3886 A83D       327            mov r0, bcd+1
3888 12335C     327            lcall ?Display_BCD
388B D000       327            pop ar0
388D C0E0       328            push acc
388F 740A       328            mov a, #10
3891 14         328            dec a
3892 123355     328            lcall ?Set_Cursor_2 ; Select column and row
3895 D0E0       328            pop acc
3897 C000       329            push ar0
3899 A83D       329            mov r0, bcd+1
389B 12335C     329            lcall ?Display_BCD
389E D000       329            pop ar0
38A0            330            
38A0 C0E0       331            push acc
38A2 740C       331            mov a, #12
38A4 14         331            dec a
38A5 123355     331            lcall ?Set_Cursor_2 ; Select column and row
38A8 D0E0       331            pop acc
38AA C000       332            push ar0
38AC A83C       332            mov r0, bcd+0
38AE 12335C     332            lcall ?Display_BCD
38B1 D000       332            pop ar0
38B3 C0E0       333            push acc
38B5 740A       333            mov a, #10
38B7 14         333            dec a
38B8 123355     333            lcall ?Set_Cursor_2 ; Select column and row
38BB D0E0       333            pop acc
38BD C0E0       334            push acc
38BF 742E       334            mov a, #'.'
38C1 12330D     334            lcall ?WriteData
38C4 D0E0       334            pop acc
38C6 C0E0       335            push acc
38C8 7407       335            mov a, #7
38CA 14         335            dec a
38CB 123355     335            lcall ?Set_Cursor_2 ; Select column and row
38CE D0E0       335            pop acc
38D0 C0E0       336            push acc
38D2 7420       336            mov a, #0x20
38D4 12330D     336            lcall ?WriteData
38D7 D0E0       336            pop acc
38D9 C0E0       337            push acc
38DB 740F       337            mov a, #15
38DD 14         337            dec a
38DE 123355     337            lcall ?Set_Cursor_2 ; Select column and row
38E1 D0E0       337            pop acc
38E3 C0E0       338            push acc
38E5 74DF       338            mov a, #0xDF
38E7 12330D     338            lcall ?WriteData
38EA D0E0       338            pop acc
38EC C0E0       339            push acc
38EE 7410       339            mov a, #16
38F0 14         339            dec a
38F1 123355     339            lcall ?Set_Cursor_2 ; Select column and row
38F4 D0E0       339            pop acc
38F6 C0E0       340            push acc
38F8 7443       340            mov a, #'C'
38FA 12330D     340            lcall ?WriteData
38FD D0E0       340            pop acc
38FF 22         341            ret
3900            342   
3900            343   
3900            344   ; /* READ ADC */
3900            345   Read_ADC:
3900 C2EF       346            clr ADCF
3902 D2EE       347            setb ADCS ;  ADC start trigger signal
3904 30EFFD     348       jnb ADCF, $ ; Wait for conversion complete
3907            349       
3907            350       ; Read the ADC result and store in [R1, R0]
3907 E5C2       351       mov a, ADCRL
3909 540F       352       anl a, #0x0f
390B F8         353       mov R0, a
390C E5C3       354       mov a, ADCRH   
390E C4         355       swap a
390F C0E0       356       push acc
3911 540F       357       anl a, #0x0f
3913 F9         358       mov R1, a
3914 D0E0       359       pop acc
3916 54F0       360       anl a, #0xf0
3918 48         361       orl a, R0
3919 F8         362       mov R0, A
391A 22         363            ret
391B            364   
391B            365   Main:
391B 75817F     366       mov SP, #0x7F        ; Set the stack pointer to the begining of idata
391E            367       
391E 1236DB     368       lcall InitAll
3921 123317     369       lcall LCD_4BIT
3924            370   
3924            371            ; Initialize all variables
3924 D201       372            setb seconds_flag
3926 755600     373            mov FSM1_state, #0
3929 755900     374            mov seconds, #0
392C 755C00     375            mov ReflowTemp, #0
392F 755D00     376            mov ReflowTime, #0
3932 755E00     377            mov SoakTime, #0
3935            378   
3935            379       ; initial messages in LCD
3935 C0E0       380            push acc
3937 7401       380            mov a, #1
3939 14         380            dec a
393A 123357     380            lcall ?Set_Cursor_1 ; Select column and row
393D D0E0       380            pop acc
393F C083       381            push dph
3941 C082       381            push dpl
3943 C0E0       381            push acc
3945 90326E     381            mov dptr, #test_message
3948 12334A     381            lcall ?Send_Constant_String
394B D0E0       381            pop acc
394D D082       381            pop dpl
394F D083       381            pop dph
3951 C0E0       382            push acc
3953 7401       382            mov a, #1
3955 14         382            dec a
3956 123355     382            lcall ?Set_Cursor_2 ; Select column and row
3959 D0E0       382            pop acc
395B C083       383            push dph
395D C082       383            push dpl
395F C0E0       383            push acc
3961 90327F     383            mov dptr, #value_message
3964 12334A     383            lcall ?Send_Constant_String
3967 D0E0       383            pop acc
3969 D082       383            pop dpl
396B D083       383            pop dph
396D            384   
396D            385            ;mov data_out, #0b00000001
396D            386   
396D            387   ;Forever: ;avaliable: r2, r3
396D            388   FSM_sys:
396D            389   ; /* TEMP_READ: READS TEMPERATURE */
396D            390   ; Note:     Before converting to be stored tempC, 
396D            391   ;           all values are stored as 32 bit numbers 
396D            392   ;           with 3 decimal points. (in milli-celcius)
396D            393   ;           
396D            394   ; Example:  2.07 V would be represented by the number
396D            395   ;           20700. (The real value * 1000).
396D            396   TEMP_READ:
396D 0239A0     397            ljmp read_led
3970            398   
3970            399   Avg_ADC:                                                 ; function for ADC noise reduction
3970 753000     400            mov x+0, #low (0 % 0x10000) 
3973 753100     400            mov x+1, #high(0 % 0x10000) 
3976 753200     400            mov x+2, #low (0 / 0x10000) 
3979 753300     400            mov x+3, #high(0 / 0x10000) 
397C 7DFF       401       mov R5, #255
397E            402   sum_loop_avg:
397E 123900     403       lcall Read_ADC
3981 753700     404       mov y+3, #0
3984 753600     405       mov y+2, #0
3987 8935       406       mov y+1, R1
3989 8834       407       mov y+0, R0
398B 123478     408       lcall add32
398E DDEE       409       djnz R5, sum_loop_avg
3990 7534FF     410            mov y+0, #low (255 % 0x10000) 
3993 753500     410            mov y+1, #high(255 % 0x10000) 
3996 753600     410            mov y+2, #low (255 / 0x10000) 
3999 753700     410            mov y+3, #high(255 / 0x10000) 
399C 1235BA     411       lcall div32
399F 22         412       ret
39A0            413   
39A0            414   read_led:
39A0 53E8F0     415       anl ADCCON0, #0xf0          ; read led voltage
39A3 43E800     416       orl ADCCON0, #LED_PORT
39A6 123970     417       lcall Avg_ADC
39A9 8841       418       mov VLED_ADC+0, R0          ; save reading to VLED_ADC
39AB 8942       419            mov VLED_ADC+1, R1
39AD            420   
39AD            421   read_lm335:
39AD 53E8F0     422       anl ADCCON0, #0xf0          ; *** LM335 ***
39B0 43E805     423       orl ADCCON0, #LM335_PORT
39B3 123970     424       lcall Avg_ADC
39B6 8830       425       mov x+0, R0                              ; load lm335 reading to x
39B8 8931       426            mov x+1, R1
39BA 753200     427            mov x+2, #0                     
39BD 753300     428            mov x+3, #0
39C0 7534E0     429            mov y+0, #low (204000 % 0x10000) 
39C3 75351C     429            mov y+1, #high(204000 % 0x10000) 
39C6 753603     429            mov y+2, #low (204000 / 0x10000) 
39C9 753700     429            mov y+3, #high(204000 / 0x10000)               ; load const vled ref into y      
39CC 12352D     430       lcall mul32
39CF 854134     431       mov y+0, VLED_ADC+0              ; import vled reading into y
39D2 854235     432            mov y+1, VLED_ADC+1         
39D5 753600     433            mov y+2, #0                     
39D8 753700     434            mov y+3, #0
39DB 1235BA     435       lcall div32
39DE 753468     436            mov y+0, #low (273000 % 0x10000) 
39E1 75352A     436            mov y+1, #high(273000 % 0x10000) 
39E4 753604     436            mov y+2, #low (273000 / 0x10000) 
39E7 753700     436            mov y+3, #high(273000 / 0x10000)                            ; adjust to 273.000 C offset
39EA 123499     437            lcall sub32                     ; result of lm335 temp remains in x
39ED 85304E     438            mov temp_lm+0, x+0          ; store 3 decimal lm335 value for later
39F0 85314F     439       mov temp_lm+1, x+1                           
39F3 853250     440       mov temp_lm+2, x+2
39F6 853351     441       mov temp_lm+3, x+3
39F9            442   
39F9            443   read_opamp:
39F9 53E8F0     444            anl ADCCON0, #0xf0          ; *** OPAMP ***
39FC 43E807     445       orl ADCCON0, #OPAMP_PORT     ; GAIN = 330 
39FF 123970     446            lcall Avg_ADC
3A02 8830       447            mov x+0, R0                         ; load opamp reading to x
3A04 8931       448            mov x+1, R1
3A06 753200     449            mov x+2, #0                     
3A09 753300     450            mov x+3, #0
3A0C 8838       451            mov data_out+0, R0                      
3A0E 8939       452            mov data_out+1, R1
3A10 753A00     453            mov data_out+2, #0
3A13 753B00     454            mov data_out+3, #0
3A16 753416     455            mov y+0, #low (2070 % 0x10000) 
3A19 753508     455            mov y+1, #high(2070 % 0x10000) 
3A1C 753600     455            mov y+2, #low (2070 / 0x10000) 
3A1F 753700     455            mov y+3, #high(2070 / 0x10000)                 ; load const vled ref (2070 mV) into y      
3A22 12352D     456       lcall mul32
3A25 854134     457       mov y+0, VLED_ADC+0              ; import led adc reading into y
3A28 854235     458            mov y+1, VLED_ADC+1         
3A2B 753600     459            mov y+2, #0                     
3A2E 753700     460            mov y+3, #0
3A31 1235BA     461       lcall div32                 ; x value now stores OPAMP V in mV
3A34 7534E8     462            mov y+0, #low (1000 % 0x10000) 
3A37 753503     462            mov y+1, #high(1000 % 0x10000) 
3A3A 753600     462            mov y+2, #low (1000 / 0x10000) 
3A3D 753700     462            mov y+3, #high(1000 / 0x10000)                                  
3A40 12352D     463            lcall mul32                                     ; turn mV to uV
3A43            464            ; mov data_out+0, x+0                   ; use for reverse checking
3A43            465            ; mov data_out+1, x+1
3A43 7534DA     466            mov y+0, #low (V2C_DIVISOR % 0x10000) 
3A46 753534     466            mov y+1, #high(V2C_DIVISOR % 0x10000) 
3A49 753600     466            mov y+2, #low (V2C_DIVISOR / 0x10000) 
3A4C 753700     466            mov y+3, #high(V2C_DIVISOR / 0x10000) 
3A4F 1235BA     467            lcall div32                                     ; deg C reading now in x
3A52 853052     468            mov temp_offset+0, x+0          ; use for reverse checking
3A55 853153     469            mov temp_offset+1, x+1
3A58            470            
3A58 7534E8     471            mov y+0, #low (1000 % 0x10000) 
3A5B 753503     471            mov y+1, #high(1000 % 0x10000) 
3A5E 753600     471            mov y+2, #low (1000 / 0x10000) 
3A61 753700     471            mov y+3, #high(1000 / 0x10000) 
3A64 12352D     472            lcall mul32                                     ; conv to mV again to add to lm335 data
3A67            473   
3A67            474   add_lm335_to_opamp:
3A67 854E34     475       mov y+0, temp_lm+0           ; load lm335 temp to y
3A6A 854F35     476       mov y+1, temp_lm+1
3A6D 855036     477       mov y+2, temp_lm+2
3A70 855137     478       mov y+3, temp_lm+3
3A73 123478     479       lcall add32                  ; lm335 + opamp = real temp
3A76 853046     480       mov temp_mc+0, x+0          ; store result in temp_mc (for python)
3A79 853147     481       mov temp_mc+1, x+1                           
3A7C 853248     482       mov temp_mc+2, x+2
3A7F 853349     483       mov temp_mc+3, x+3
3A82            484   
3A82 854E46     485            mov temp_mc+0, temp_lm+0
3A85 854F47     486       mov temp_mc+1, temp_lm+1                             
3A88 855048     487       mov temp_mc+2, temp_lm+2
3A8B 855149     488       mov temp_mc+3, temp_lm+3
3A8E            489   
3A8E            490   export_to_bcd:
3A8E 1233B3     491            lcall hex2bcd                           ; Convert val stored in x to BCD in "bcd"
3A91 12384B     492            lcall Display_formated_BCD      
3A94            493            
3A94            494   export_to_main:
3A94 854630     495            mov x+0, temp_mc+0          
3A97 854731     496       mov x+1, temp_mc+1
3A9A 854832     497       mov x+2, temp_mc+2
3A9D 854933     498       mov x+3, temp_mc+3
3AA0 7534E8     499            mov y+0, #low (1000 % 0x10000) 
3AA3 753503     499            mov y+1, #high(1000 % 0x10000) 
3AA6 753600     499            mov y+2, #low (1000 / 0x10000) 
3AA9 753700     499            mov y+3, #high(1000 / 0x10000) 
3AAC 1235BA     500       lcall div32
3AAF 853045     501       mov tempc, x+0              ; Both tempc and x now stores temp (C)           
3AB2            502   
3AB2            503   Export:                                                  ; Data export to python
3AB2 7AFA       504            mov R2, #250                            ; Wait 500 ms between conversions
3AB4 123845     505            lcall waitms
3AB7 7AFA       506            mov R2, #250
3AB9 123845     507            lcall waitms                            ; Sends binary contents of 
3ABC            508   
3ABC 1237E1     509       lcall SendBin                                ; temp_mc and data_out to python
3ABF            510   
3ABF            511            ; /* FSM1 STATE CHANGE CONTROLS */
3ABF 023AC2     512            ljmp FSM1
3AC2            513   
3AC2            514   ; REQUIREMENTS
3AC2            515   ; Start/Stop button, to do this, make routine which displays "stopped" for a little bit
3AC2            516   ; Temperature display, implemented already
3AC2            517   ; Running time display, implement in main
3AC2            518   ; 
3AC2            519   
3AC2            520   
3AC2            521   FSM1:
3AC2 E556       522            mov a, FSM1_state
3AC4            523   
3AC4            524   FSM1_state0:
3AC4 B40011     525            cjne a, #0, FSM1_state1 ; if FSM1_state (currently stored in a) is not equal to zero (ie. state zero), go to state 1
3AC7 755A00     526            mov pwm, #0
3ACA C201       527            clr seconds_flag
3ACC            528            ; check for push button input
3ACC 208406     529            jb START_BUTTON, FSM1_state0_done
3ACF 3084FD     530            jnb START_BUTTON, $ ; Wait for key release
3AD2 755601     531            mov FSM1_state, #1
3AD5            532   
3AD5            533   FSM1_state0_done:
3AD5 02396D     534            ljmp FSM_sys
3AD8            535   
3AD8            536   FSM1_state1:
3AD8 B40113     537            cjne a, #1, FSM1_state2
3ADB 755A64     538            mov pwm, #100
3ADE 755900     539            mov seconds, #0
3AE1 7496       540            mov a, #150
3AE3 C3         541            clr c
3AE4 9545       542            subb a, tempc
3AE6 5003       543            jnc FSM1_state1_done
3AE8 755602     544            mov FSM1_state, #2
3AEB            545   
3AEB            546   FSM1_state1_done:
3AEB 02396D     547            ljmp FSM_sys
3AEE            548   
3AEE            549   FSM1_state2:
3AEE B4021B     550            cjne a, #2, FSM1_state3
3AF1 755A14     551            mov pwm, #20
3AF4 30010A     552            jnb seconds_flag, FSM_state2_funk
3AF7            553            ;mov a, #60
3AF7 E55E       554            mov a, SoakTime
3AF9 C3         555            clr c
3AFA 9559       556            subb a, seconds                 ; Want time to be greater than 60 seconds
3AFC 400B       557            jc FSM1_state2_done
3AFE 755603     558            mov FSM1_state, #3
3B01            559   
3B01            560   FSM_state2_funk:
3B01 755900     561            mov seconds, #0         ; Set seconds so we can count up to the required time 
3B04 D201       562            setb seconds_flag       ; seconds flag so we don't reset seconds_flag multiple times
3B06 023AEE     563            ljmp FSM1_state2        
3B09            564   
3B09            565   FSM1_state2_done:
3B09 02396D     566            ljmp FSM_sys
3B0C            567   
3B0C            568   FSM1_state3:
3B0C B40312     569            cjne a, #3, FSM1_state4
3B0F 755A64     570            mov pwm, #100
3B12            571            ;mov a, #220
3B12 E55C       572            mov a, ReflowTemp
3B14 C201       573            clr seconds_flag
3B16 C3         574            clr c
3B17 9545       575            subb a, tempc
3B19 5003       576            jnc FSM1_state3_done
3B1B 755604     577            mov FSM1_state, #4
3B1E            578   
3B1E            579   FSM1_state3_done:
3B1E 02396D     580            ljmp FSM_sys
3B21            581   
3B21            582   FSM1_state4:
3B21 B4041B     583            cjne a, #4, FSM1_state5
3B24 755A14     584            mov pwm, #20 
3B27 30010A     585            jnb seconds_flag, FSM1_state4_funk
3B2A            586            ;mov a, #45
3B2A E55D       587            mov a, ReflowTime
3B2C C3         588            clr c 
3B2D 9559       589            subb a, seconds ; when seconds is greater than 45, there will be a carry bit
3B2F 400B       590            jc FSM1_state4_done
3B31 755605     591            mov FSM1_state, #5
3B34            592   
3B34            593   FSM1_state4_funk:
3B34 755900     594            mov seconds, #0
3B37 D201       595            setb seconds_flag
3B39 023B21     596            ljmp FSM1_state4
3B3C            597   
3B3C            598   FSM1_state4_done:
3B3C 02396D     599            ljmp FSM_sys
3B3F            600   
3B3F            601   FSM1_state5:
3B3F B40510     602            cjne a, #5, FSM1_abort_state            ; if the state is not in 0-5, then it must be 10 (aka the abort state)
3B42 755A00     603            mov pwm, #0
3B45 743C       604            mov a, #60
3B47 C3         605            clr c
3B48 9545       606            subb a, tempc
3B4A 4003       607            jc FSM1_state5_done
3B4C 755600     608            mov FSM1_state, #0
3B4F            609   
3B4F            610   FSM1_state5_done:
3B4F 02396D     611            ljmp FSM_sys
3B52            612   
3B52            613   FSM1_abort_state:                                                ; When the abort state is triggered, turn everything off and remain in this state utill you reset
3B52 755A00     614            mov pwm, #0
3B55 C0E0       615            push acc
3B57 7401       615            mov a, #1
3B59 14         615            dec a
3B5A 123357     615            lcall ?Set_Cursor_1 ; Select column and row
3B5D D0E0       615            pop acc
3B5F C083       616            push dph
3B61 C082       616            push dpl
3B63 C0E0       616            push acc
3B65 9032AD     616            mov dptr, #abort_message
3B68 12334A     616            lcall ?Send_Constant_String
3B6B D0E0       616            pop acc
3B6D D082       616            pop dpl
3B6F D083       616            pop dph
3B71            617   
3B71 023B52     618            ljmp FSM1_abort_state
3B74            619   
3B74            620   END
