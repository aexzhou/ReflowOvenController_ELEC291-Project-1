                  2   $LIST
0000              4   
0000              5   ;  N76E003 pinout:
0000              6   ;                               -------
0000              7   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000              8   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000              9   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             10   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             11   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             12   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             13   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             14   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             15   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             16   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             17   ;                               -------
0000             18   ;
0000             19   
0000             20   CLK                 EQU 16600000                                                 ; Microcontroller system frequency in Hz
0000             21   BAUD                EQU 115200                                                   ; Baud rate of UART in bps
0000             22   TIMER1_RELOAD       EQU (0x100-(CLK/(16*BAUD)))
0000             23   TIMER0_RELOAD_1MS   EQU (0x10000-(CLK/1000))
0000             24   TIMER2_RATE              EQU 100                                                         ; 1/100 = 10ms
0000             25   TIMER2_RELOAD            EQU (65536-(CLK/(16*TIMER2_RATE)))
0000             26   
0000             27   ; /*** PORT DEFINITIONS ***/
0000             28   LCD_RS                   equ P1.3
0000             29   LCD_E                    equ P1.4
0000             30   LCD_D4                   equ P0.0
0000             31   LCD_D5                   equ P0.1
0000             32   LCD_D6                   equ P0.2
0000             33   LCD_D7                   equ P0.3
0000             34   PWM_OUT                  equ P1.0
0000             35   START_BUTTON     equ P0.4
0000             36   ; Analog Input Port Numbering
0000             37   LED_PORT                 equ 0x00                        ; AIN port numbers
0000             38   LM335_PORT               equ 0x05
0000             39   OPAMP_PORT               equ 0x07
0000             40   
0000             41   ; /*** VECTORS ***/
0000             42   org 0000H
0000 02390F      43            ljmp Main
0003             44   
002B             45   org 002BH                                        ; timer 2 enable
002B 023760      46            ljmp Timer2_ISR
002E             47   
3000             48   org 3000H                                        ; lookup table stored at APROM address starting 0x4000
3000             49   ;        $NOLIST
                 -1    	$include(thermodata.inc)
3000              1   ; Contains mV offset for Thermocouple
3000              2   ; Stored in APROM location: 0x3000
3000              3   thermodata:
3000 00000027     4       DW  0, 39, 79, 119, 158, 198, 238, 277, 317, 357, 397, 437, 477, 517, 557, 597 
     004F0077
     009E00C6
     00EE0115
     013D0165
     018D01B5
     01DD0205
     022D0255
3020 027D02A5     5       DW  637, 677, 718, 758, 798, 838, 879, 919, 960, 1000, 1041, 1081, 1122, 1163, 1203, 1244
     02CE02F6
     031E0346
     036F0397
     03C003E8
     04110439
     0462048B
     04B304DC
3040 0505052E     6       DW  1285, 1326, 1366, 1407, 1448, 1489, 1530, 1571, 1612, 1653, 1694, 1735, 1776, 1817, 1858, 1899
     0556057F
     05A805D1
     05FA0623
     064C0675
     069E06C7
     06F00719
     0742076B
3060 079507BE     7       DW  1941, 1982, 2023, 2064, 2106, 2147, 2188, 2230, 2271, 2312, 2354, 2395, 2436, 2478, 2519, 2561 
     07E70810
     083A0863
     088C08B6
     08DF0908
     0932095B
     098409AE
     09D70A01
3080 0A2A0A54     8       DW  2602, 2644, 2685, 2727, 2768, 2810, 2851, 2893, 2934, 2976, 3017, 3059, 3100, 3142, 3184, 3225
     0A7D0AA7
     0AD00AFA
     0B230B4D
     0B760BA0
     0BC90BF3
     0C1C0C46
     0C700C99
30A0 0CC30CEC     9       DW  3267, 3308, 3350, 3391, 3433, 3474, 3516, 3557, 3599, 3640, 3682, 3723, 3765, 3806, 3848, 3889 
     0D160D3F
     0D690D92
     0DBC0DE5
     0E0F0E38
     0E620E8B
     0EB50EDE
     0F080F31
30C0 0F5B0F84    10       DW  3931, 3972, 4013, 4055, 4096, 4138, 4179, 4220, 4262, 4303, 4344, 4385, 4427, 4468, 4509, 4550 
     0FAD0FD7
     1000102A
     1053107C
     10A610CF
     10F81121
     114B1174
     119D11C6
30E0 11EF1219    11       DW  4591, 4633, 4674, 4715, 4756, 4797, 4838, 4879, 4920, 4961, 5002, 5043, 5084, 5124, 5165, 5206
     1242126B
     129412BD
     12E6130F
     13381361
     138A13B3
     13DC1404
     142D1456
3100 147F14A8    12       DW  5247, 5288, 5328, 5369, 5410, 5450, 5491, 5532, 5572, 5613, 5653, 5694, 5735, 5775, 5815, 5856
     14D014F9
     1522154A
     1573159C
     15C415ED
     1615163E
     1667168F
     16B716E0
3120 17081731    13       DW  5896, 5937, 5977, 6017, 6058, 6098, 6138, 6179, 6219, 6259, 6299, 6339, 6380, 6420, 6460, 6500
     17591781
     17AA17D2
     17FA1823
     184B1873
     189B18C3
     18EC1914
     193C1964
3140 198C19B4    14       DW  6540, 6580, 6620, 6660, 6701, 6741, 6781, 6821, 6861, 6901, 6941, 6981, 7021, 7060, 7100, 7140
     19DC1A04
     1A2D1A55
     1A7D1AA5
     1ACD1AF5
     1B1D1B45
     1B6D1B94
     1BBC1BE4
3160 1C0C1C34    15       DW  7180, 7220, 7260, 7300, 7340, 7380, 7420, 7460, 7500, 7540, 7579, 7619, 7659, 7699, 7739, 7779
     1C5C1C84
     1CAC1CD4
     1CFC1D24
     1D4C1D74
     1D9B1DC3
     1DEB1E13
     1E3B1E63
3180 1E8B1EB3    16       DW  7819, 7859, 7899, 7939, 7979, 8019, 8059, 8099, 8138, 8178, 8218, 8258, 8298, 8338, 8378, 8418
     1EDB1F03
     1F2B1F53
     1F7B1FA3
     1FCA1FF2
     201A2042
     206A2092
     20BA20E2
31A0 210A2133    17       DW  8458, 8499, 8539, 8579, 8619, 8659, 8699, 8739, 8779, 8819, 8860, 8900, 8940, 8980, 9020, 9061
     215B2183
     21AB21D3
     21FB2223
     224B2273
     229C22C4
     22EC2314
     233C2365
31C0 238D23B5    18       DW  9101, 9141, 9181, 9222, 9262, 9302, 9343, 9383, 9423, 9464, 9504, 9545, 9585, 9626, 9666, 9707
     23DD2406
     242E2456
     247F24A7
     24CF24F8
     25202549
     2571259A
     25C225EB
31E0 2613263C    19       DW  9747, 9788, 9828, 9869, 9909, 9950, 9991, 10031, 10072, 10113, 10153, 10194, 10235, 10276, 10316, 10357 
     2664268D
     26B526DE
     2707272F
     27582781
     27A927D2
     27FB2824
     284C2875
3200 289E28C7    20       DW  10398, 10439, 10480, 10520, 10561, 10602, 10643, 10684, 10725, 10766, 10807, 10848, 10889, 10930, 10971, 11012 
     28F02918
     2941296A
     299329BC
     29E52A0E
     2A372A60
     2A892AB2
     2ADB2B04
3220 2B2D2B56    21       DW  11053, 11094, 11135, 11176, 11217, 11259, 11300, 11341, 11382, 11423, 11465, 11506, 11547, 11588, 11630, 11671
     2B7F2BA8
     2BD12BFB
     2C242C4D
     2C762C9F
     2CC92CF2
     2D1B2D44
     2D6E2D97
3240 2DC02DE9    22       DW  11712, 11753, 11795, 11836, 11877, 11919, 11960, 12001, 12043, 12084, 12126, 12167, 12209, 12250, 12291, 12333
     2E132E3C
     2E652E8F
     2EB82EE1
     2F0B2F34
     2F5E2F87
     2FB12FDA
     3003302D
3260 30563080    23       DW  12374, 12416, 12457, 12499, 12540, 12582, 12624
     30A930D3
     30FC3126
     3150
326E             24   
326E             51   ;        $List
326E             52   
326E             53   ; /*** DIRECT ACCESS VARIABLES @RAM 0x30 -> 0x7F ***/
0030             54   DSEG at 30H
0030             55   x:                       ds 4            ; for math
0034             56   y:                       ds 4
0038             57   data_out:        ds 2            ; for python
003A             58   bcd:                     ds 5            ; for display
003F             59   
003F             60   VLED_ADC:                ds 2            ; for temperature 
0041             61   dtemp:                   ds 2
0043             62   tempc:                   ds 1
0044             63   temp_mc:                 ds 4
0048             64   OPAMP_temp:      ds 4
004C             65   temp_lm:                 ds 4
0050             66   temp_offset:     ds 2
0052             67   mV_offset:       ds 2
0054             68   
0054             69   FSM1_state:      ds 1            ; fsm states
0055             70   
0055             71   pwm_counter:     ds 1            ; time check and pwm
0056             72   count10ms:               ds 1
0057             73   seconds:                 ds 1
0058             74   pwm:                     ds 1
0059             75   abort_time:              ds 1
005A             76   
005A             77   ReflowTemp:      ds 1            ; reflow profile parameters
005B             78   ReflowTime:              ds 1
005C             79   SoakTime:                ds 1
005D             80   
005D             81   Val_test:                ds 4
0061             82   Val_temp:                ds 4
0065             83   
0065             84   ; /*** SINGLE BIT VARIABLES @RAM 0x20 -> 0x2F ***/
0000             85   BSEG 
0000             86   mf:                      dbit 1
0001             87   seconds_flag:    dbit 1
0002             88   s_flag:                  dbit 1
0003             89   
0003             90   ; /*** CODE SEGMENT ***/
326E             91   CSEG
326E             92   ;                     1234567890123456    <- This helps determine the location of the counter
326E 2A2A2A2A    93   test_message:     db '****LOADING*****', 0
     4C4F4144
     494E472A
     2A2A2A2A
     00
327F 54454D50    94   value_message:    db 'TEMP:      ', 0
     3A202020
     20202000
328B 43454C43    95   cel_message:       db 'CELCIUS  READING',0
     49555320
     20524541
     44494E47
     00
329C 46415245    96   fah_message:      db 'FARENHET READING',0
     4E484554
     20524541
     44494E47
     00
32AD 41424F52    97   abort_message:     db 'ABORTABORTABORT ', 0
     5441424F
     52544142
     4F525420
     00
32BE             98   
33B3            122   $LIST
                546   $LIST
36DB             70   $LIST
                103   $LIST
36DB            105   
36DB            106   
36DB            107   InitAll:
36DB            108            ; /*** SERIAL PORT INITIALIZATION ***/
36DB 75AC00     109            mov     P3M1,#0x00                      ; Configure all the pins for biderectional I/O
36DE 75AD00     110            mov     P3M2,#0x00
36E1 75B300     111            mov     P1M1,#0x00
36E4 75B400     112            mov     P1M2,#0x00
36E7 75B100     113            mov     P0M1,#0x00
36EA 75B200     114            mov     P0M2,#0x00
36ED            115       ; Since the reset button bounces, we need to wait a bit before
36ED            116       ; sending messages, otherwise we risk displaying gibberish!
36ED            117       ;mov R1, #200
36ED            118       ;mov R0, #104
36ED            119       ;djnz R0, $                                  ; 4 cycles->4*60.285ns*104=25us
36ED            120       ;djnz R1, $-4                                ; 25us*200=5.0ms
36ED 7A05       121       mov R2, #5
36EF 123839     122       lcall waitms
36F2            123       ; Now we can proceed with the configuration of the serial port
36F2 438E10     124            orl     CKCON, #0x10                    ; CLK is the input for timer 1
36F5 438780     125            orl     PCON, #0x80                     ; Bit SMOD=1, double baud rate
36F8 759852     126            mov     SCON, #0x52
36FB 53C4DF     127            anl     T3CON, #0b11011111
36FE 53890F     128            anl     TMOD, #0x0F                             ; Clear the configuration bits for timer 1
3701 438920     129            orl     TMOD, #0x20                     ; Timer 1 Mode 2
3704 758DF7     130            mov     TH1, #TIMER1_RELOAD
3707 D28E       131            setb TR1
3709            132   
3709            133            ; /*** INITIALIZE THE REST ***/
3709 438E10     134            orl     CKCON, #0x10                    ; CLK is the input for timer 1
370C 438780     135            orl     PCON, #0x80                     ; Bit SMOD=1, double baud rate
370F 759852     136            mov     SCON, #0x52
3712 53C4DF     137            anl     T3CON, #0b11011111
3715 53890F     138            anl     TMOD, #0x0F                     ; Clear the configuration bits for timer 1
3718 438920     139            orl     TMOD, #0x20                     ; Timer 1 Mode 2
371B 758DF7     140            mov     TH1, #TIMER1_RELOAD     ; TH1=TIMER1_RELOAD;
371E D28E       141            setb TR1
3720            142            
3720            143            ; Using timer 0 for delay functions.  Initialize here:
3720 C28C       144            clr     TR0                                     ; Stop timer 0
3722 438E08     145            orl     CKCON,#0x08                     ; CLK is the input for timer 0
3725 5389F0     146            anl     TMOD,#0xF0                              ; Clear the configuration bits for timer 0
3728 438901     147            orl     TMOD,#0x01                              ; Timer 0 in Mode 1: 16-bit timer
372B            148            
372B            149            ; Initialize the pin used by the ADC (P1.1) as input.
372B 43B302     150            orl     P1M1, #0b00000010
372E 53B4FD     151            anl     P1M2, #0b11111101
3731            152            
3731            153            ; Initialize and start the ADC:
3731 53E8F0     154            anl ADCCON0, #0xF0
3734 43E807     155            orl ADCCON0, #0x07                      ; Select channel 7
3737            156            ; AINDIDS select if some pins are analog inputs or digital I/O:
3737 75F600     157            mov AINDIDS, #0x00                      ; Disable all analog inputs
373A 43F680     158            orl AINDIDS, #0b10000000        ; P1.1 is analog input
373D 43E101     159            orl ADCCON1, #0x01                      ; Enable ADC
3740 755000     160            mov temp_offset, #0x00
3743            161   
3743            162   
3743            163   ;----------------------------------------------------------------;
3743            164   ;                                        TIMER 2 INITIALIZATION
3743            165   ;----------------------------------------------------------------;
3743            166   
3743 75C800     167            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
3746 75CDD7     168            mov TH2, #high(TIMER2_RELOAD)
3749 75CC79     169            mov TL2, #low(TIMER2_RELOAD)
374C            170            ; Set the reload value
374C 75C9A0     171            mov T2MOD, #0b1010_0000 ; Enable timer 2 autoreload, and clock divider is 16
374F 75CBD7     172            mov RCMP2H, #high(TIMER2_RELOAD)
3752 75CA79     173            mov RCMP2L, #low(TIMER2_RELOAD)
3755            174            ; Init the free running 10 ms counter to zero
3755 755500     175            mov pwm_counter, #0
3758            176            ; Enable the timer and interrupts
3758 439B80     177            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
375B D2CA       178       setb TR2  ; Enable timer 2
375D            179   
375D D2AF       180            setb EA ; Enable global interrupts
375F 22         181       ret
3760            182   
3760            183   
3760            184   ;---------------------------------;
3760            185   ; ISR for Timer 2                 ;
3760            186   ;---------------------------------;
3760            187   Timer2_ISR:
3760 C2CF       188            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
3762 C0D0       189            push psw
3764 C0E0       190            push acc
3766            191            
3766 0555       192            inc pwm_counter
3768 C3         193            clr c
3769 E558       194            mov a, pwm
376B 9555       195            subb a, pwm_counter ; If pwm_counter <= pwm then c=1
376D B3         196            cpl c
376E 9290       197            mov PWM_OUT, c
3770            198            
3770 E555       199            mov a, pwm_counter
3772 B46432     200            cjne a, #100, Timer2_ISR_done
3775            201            ; executes every second
3775 755500     202            mov pwm_counter, #0
3778 0557       203            inc seconds ; It is super easy to keep a seconds count here
377A D202       204            setb s_flag
377C E554       205            mov a, FSM1_state
377E B40003     206            cjne a, #0, Abort_Check0                        ; For abort check, the abort should not trigger if you are in state 0
3781 0237A7     207            ljmp Timer2_ISR_done
3784            208   
3784            209   Abort_Check0:
3784            210   ; Check if temperature is above 240. If so, abort
3784 C3         211            clr c
3785 E543       212            mov a, tempc
3787 94F0       213            subb a, #240                                            ; if a is greater than 240, there will be no carry bit so we need to abort
3789 4006       214            jc Abort_Check1                                                 ; if temperature is below 240, continue to next check
378B            215            ; abort routine
378B 75540A     216            mov FSM1_state, #10
378E 0237A7     217       ljmp Timer2_ISR_done                ; if temp is above 240, abort condition has already been triggered, skip ahead to done
3791            218   
3791            219   Abort_Check1:
3791            220   ; Check if temperature is below 50. If so, check for how long
3791 E543       221            mov a, tempc
3793 C3         222            clr c
3794 9432       223            subb a, #50                                                     ; if tempc (stored in a) is less than 50, there will be a carry bit
3796 500C       224            jnc Timer2_ISR_abort_done                       ; skip the abort checks if temperature is above 50
3798            225   
3798            226   Abort_Check2:
3798            227   ; Check if has been 60 seconds (at below 50 degrees)
3798 0559       228            inc abort_time
379A E559       229            mov a, abort_time
379C C3         230            clr c
379D 943C       231            subb a, #60                                                     ; if abort_time is less than 60, there will be a carry bit
379F 5006       232            jnc Timer2_ISR_done                                     ; if there is a carry 
37A1 75540A     233            mov FSM1_state, #10
37A4            234   
37A4            235   Timer2_ISR_abort_done:
37A4 755900     236            mov abort_time, #0
37A7            237   
37A7            238   Timer2_ISR_done:
37A7 D0E0       239            pop acc
37A9 D0D0       240            pop psw
37AB 32         241            reti
37AC            242   
37AC            243   line1:
37AC 50574D20   244            DB 'PWM Example     '
     4578616D
     706C6520
     20202020
37BC 00         245            DB 0
37BD            246   line2:
37BD 43686B20   247            DB 'Chk pin 15:P1.0 '
     70696E20
     31353A50
     312E3020
37CD 00         248            DB 0
37CE            249   
37CE            250   ; /* Send a character using the serial port */
37CE            251   putchar:
37CE 3099FD     252       jnb TI, putchar
37D1 C299       253       clr TI
37D3 F599       254       mov SBUF, a
37D5 22         255       ret
37D6            256   
37D6            257   ; Send a constant-zero-terminated string using the serial port
37D6            258   SendString:
37D6 E4         259       clr A
37D7 93         260       movc A, @A+DPTR
37D8 6006       261       jz SendStringDone
37DA 1237CE     262       lcall putchar
37DD A3         263       inc DPTR
37DE 80F6       264       sjmp SendString
37E0            265   SendStringDone:
37E0 22         266       ret
37E1            267   
37E1            268   ; Sends binary data to Python via putchar
37E1            269   SendBin:                                         
37E1 E4         270            clr A                                   ; Sends temp_mc
37E2 E544       271            mov a, temp_mc+0
37E4 1237CE     272            lcall putchar
37E7 E4         273            clr A
37E8 E545       274            mov a, temp_mc+1
37EA 1237CE     275            lcall putchar
37ED E4         276            clr A
37EE E546       277            mov a, temp_mc+2
37F0 1237CE     278            lcall putchar
37F3 E4         279            clr A
37F4 E547       280            mov a, temp_mc+3
37F6 1237CE     281            lcall putchar
37F9            282   
37F9 E4         283            clr A                                   ; Sends data_out
37FA E538       284            mov a, data_out+0
37FC 1237CE     285            lcall putchar
37FF E4         286            clr A
3800 E539       287            mov a, data_out+1
3802 1237CE     288            lcall putchar
3805 22         289            ret
3806            290   
3806            291   ASCII_CHAR: 
3806 30313233   292            db '0123456789ABCDEF'
     34353637
     38394142
     43444546
3816            293   
3816            294   Hello_World:
3816 48656C6C   295       DB  'Hello, World!', '\r', '\n', 0
     6F2C2057
     6F726C64
     210D0A00
3826            296   New_Line:
3826 0D0A00     297            DB '\r', '\n', 0
3829            298   
3829            299   ; /* 1ms DELAY FUNCTIONS */
3829            300   wait_1ms:
3829 C28C       301            clr     TR0 ; Stop timer 0
382B C28D       302            clr     TF0 ; Clear overflow flag
382D 758CBF     303            mov     TH0, #high(TIMER0_RELOAD_1MS)
3830 758A28     304            mov     TL0,#low(TIMER0_RELOAD_1MS)
3833 D28C       305            setb TR0
3835 308DFD     306            jnb     TF0, $ ; Wait for overflow
3838 22         307            ret
3839            308   waitms:
3839 123829     309            lcall wait_1ms
383C DAFB       310            djnz R2, waitms
383E 22         311            ret
383F            312   
383F            313   Display_formated_BCD: ;4 dig 
383F C0E0       314            push acc
3841 7401       314            mov a, #1
3843 14         314            dec a
3844 123357     314            lcall ?Set_Cursor_1 ; Select column and row
3847 D0E0       314            pop acc
3849 C083       315            push dph
384B C082       315            push dpl
384D C0E0       315            push acc
384F 90328B     315            mov dptr, #cel_message
3852 12334A     315            lcall ?Send_Constant_String
3855 D0E0       315            pop acc
3857 D082       315            pop dpl
3859 D083       315            pop dph
385B C0E0       316            push acc
385D 7407       316            mov a, #7
385F 14         316            dec a
3860 123355     316            lcall ?Set_Cursor_2 ; Select column and row
3863 D0E0       316            pop acc
3865            316   
3865 C000       317            push ar0
3867 A83C       317            mov r0, bcd+2
3869 12335C     317            lcall ?Display_BCD
386C D000       317            pop ar0
386E C0E0       318            push acc
3870 7409       318            mov a, #9
3872 14         318            dec a
3873 123355     318            lcall ?Set_Cursor_2 ; Select column and row
3876 D0E0       318            pop acc
3878 C000       319            push ar0
387A A83B       319            mov r0, bcd+1
387C 12335C     319            lcall ?Display_BCD
387F D000       319            pop ar0
3881 C0E0       320            push acc
3883 740A       320            mov a, #10
3885 14         320            dec a
3886 123355     320            lcall ?Set_Cursor_2 ; Select column and row
3889 D0E0       320            pop acc
388B C000       321            push ar0
388D A83B       321            mov r0, bcd+1
388F 12335C     321            lcall ?Display_BCD
3892 D000       321            pop ar0
3894            322            
3894 C0E0       323            push acc
3896 740C       323            mov a, #12
3898 14         323            dec a
3899 123355     323            lcall ?Set_Cursor_2 ; Select column and row
389C D0E0       323            pop acc
389E C000       324            push ar0
38A0 A83A       324            mov r0, bcd+0
38A2 12335C     324            lcall ?Display_BCD
38A5 D000       324            pop ar0
38A7 C0E0       325            push acc
38A9 740A       325            mov a, #10
38AB 14         325            dec a
38AC 123355     325            lcall ?Set_Cursor_2 ; Select column and row
38AF D0E0       325            pop acc
38B1 C0E0       326            push acc
38B3 742E       326            mov a, #'.'
38B5 12330D     326            lcall ?WriteData
38B8 D0E0       326            pop acc
38BA C0E0       327            push acc
38BC 7407       327            mov a, #7
38BE 14         327            dec a
38BF 123355     327            lcall ?Set_Cursor_2 ; Select column and row
38C2 D0E0       327            pop acc
38C4 C0E0       328            push acc
38C6 7420       328            mov a, #0x20
38C8 12330D     328            lcall ?WriteData
38CB D0E0       328            pop acc
38CD C0E0       329            push acc
38CF 740F       329            mov a, #15
38D1 14         329            dec a
38D2 123355     329            lcall ?Set_Cursor_2 ; Select column and row
38D5 D0E0       329            pop acc
38D7 C0E0       330            push acc
38D9 74DF       330            mov a, #0xDF
38DB 12330D     330            lcall ?WriteData
38DE D0E0       330            pop acc
38E0 C0E0       331            push acc
38E2 7410       331            mov a, #16
38E4 14         331            dec a
38E5 123355     331            lcall ?Set_Cursor_2 ; Select column and row
38E8 D0E0       331            pop acc
38EA C0E0       332            push acc
38EC 7443       332            mov a, #'C'
38EE 12330D     332            lcall ?WriteData
38F1 D0E0       332            pop acc
38F3 22         333            ret
38F4            334   
38F4            335   
38F4            336   ; /* READ ADC */
38F4            337   Read_ADC:
38F4 C2EF       338            clr ADCF
38F6 D2EE       339            setb ADCS ;  ADC start trigger signal
38F8 30EFFD     340       jnb ADCF, $ ; Wait for conversion complete
38FB            341       
38FB            342       ; Read the ADC result and store in [R1, R0]
38FB E5C2       343       mov a, ADCRL
38FD 540F       344       anl a, #0x0f
38FF F8         345       mov R0, a
3900 E5C3       346       mov a, ADCRH   
3902 C4         347       swap a
3903 C0E0       348       push acc
3905 540F       349       anl a, #0x0f
3907 F9         350       mov R1, a
3908 D0E0       351       pop acc
390A 54F0       352       anl a, #0xf0
390C 48         353       orl a, R0
390D F8         354       mov R0, A
390E 22         355            ret
390F            356   
390F            357   Main:
390F 75817F     358       mov SP, #0x7F        ; Set the stack pointer to the begining of idata
3912            359       
3912 1236DB     360       lcall InitAll
3915 123317     361       lcall LCD_4BIT
3918            362   
3918            363            ; Initialize all variables
3918 D201       364            setb seconds_flag
391A 755400     365            mov FSM1_state, #0
391D 755700     366            mov seconds, #0
3920 755A00     367            mov ReflowTemp, #0
3923 755B00     368            mov ReflowTime, #0
3926 755C00     369            mov SoakTime, #0
3929            370   
3929            371       ; initial messages in LCD
3929 C0E0       372            push acc
392B 7401       372            mov a, #1
392D 14         372            dec a
392E 123357     372            lcall ?Set_Cursor_1 ; Select column and row
3931 D0E0       372            pop acc
3933 C083       373            push dph
3935 C082       373            push dpl
3937 C0E0       373            push acc
3939 90326E     373            mov dptr, #test_message
393C 12334A     373            lcall ?Send_Constant_String
393F D0E0       373            pop acc
3941 D082       373            pop dpl
3943 D083       373            pop dph
3945 C0E0       374            push acc
3947 7401       374            mov a, #1
3949 14         374            dec a
394A 123355     374            lcall ?Set_Cursor_2 ; Select column and row
394D D0E0       374            pop acc
394F C083       375            push dph
3951 C082       375            push dpl
3953 C0E0       375            push acc
3955 90327F     375            mov dptr, #value_message
3958 12334A     375            lcall ?Send_Constant_String
395B D0E0       375            pop acc
395D D082       375            pop dpl
395F D083       375            pop dph
3961            376   
3961            377            ;mov data_out, #0b00000001
3961            378   
3961            379   ;Forever: ;avaliable: r2, r3
3961            380   FSM_sys:
3961            381   ; /* TEMP_READ: READS TEMPERATURE */
3961            382   ; Note:     Before converting to be stored tempC, 
3961            383   ;           all values are stored as 32 bit numbers 
3961            384   ;           with 3 decimal points. (in milli-celcius)
3961            385   ;           
3961            386   ; Example:  2.07 V would be represented by the number
3961            387   ;           20700. (The real value * 1000).
3961            388   TEMP_READ:
3961 023994     389            ljmp read_led
3964            390   
3964            391   Avg_ADC:
3964 753000     392            mov x+0, #low (0 % 0x10000) 
3967 753100     392            mov x+1, #high(0 % 0x10000) 
396A 753200     392            mov x+2, #low (0 / 0x10000) 
396D 753300     392            mov x+3, #high(0 / 0x10000) 
3970 7DFF       393       mov R5, #255
3972            394   sum_loop_avg:
3972 1238F4     395       lcall Read_ADC
3975 753700     396       mov y+3, #0
3978 753600     397       mov y+2, #0
397B 8935       398       mov y+1, R1
397D 8834       399       mov y+0, R0
397F 123478     400       lcall add32
3982 DDEE       401       djnz R5, sum_loop_avg
3984 7534FF     402            mov y+0, #low (255 % 0x10000) 
3987 753500     402            mov y+1, #high(255 % 0x10000) 
398A 753600     402            mov y+2, #low (255 / 0x10000) 
398D 753700     402            mov y+3, #high(255 / 0x10000) 
3990 1235BA     403       lcall div32
3993 22         404       ret
3994            405   
3994            406   read_led:
3994 53E8F0     407       anl ADCCON0, #0xf0          ; read led voltage
3997 43E800     408       orl ADCCON0, #LED_PORT
399A 123964     409       lcall Avg_ADC
399D 883F       410       mov VLED_ADC+0, R0          ; save reading to VLED_ADC
399F 8940       411            mov VLED_ADC+1, R1
39A1            412   
39A1            413   read_lm335:
39A1 53E8F0     414       anl ADCCON0, #0xf0          ; *** LM335 ***
39A4 43E805     415       orl ADCCON0, #LM335_PORT
39A7 123964     416       lcall Avg_ADC
39AA 8830       417       mov x+0, R0                              ; load lm335 reading to x
39AC 8931       418            mov x+1, R1
39AE 753200     419            mov x+2, #0                     
39B1 753300     420            mov x+3, #0
39B4 753498     421            mov y+0, #low (207000 % 0x10000) 
39B7 753528     421            mov y+1, #high(207000 % 0x10000) 
39BA 753603     421            mov y+2, #low (207000 / 0x10000) 
39BD 753700     421            mov y+3, #high(207000 / 0x10000)                ; load const vled ref into y      
39C0 12352D     422       lcall mul32
39C3 853F34     423       mov y+0, VLED_ADC+0              ; import vled reading into y
39C6 854035     424            mov y+1, VLED_ADC+1         
39C9 753600     425            mov y+2, #0                     
39CC 753700     426            mov y+3, #0
39CF 1235BA     427       lcall div32
39D2 753468     428            mov y+0, #low (273000 % 0x10000) 
39D5 75352A     428            mov y+1, #high(273000 % 0x10000) 
39D8 753604     428            mov y+2, #low (273000 / 0x10000) 
39DB 753700     428            mov y+3, #high(273000 / 0x10000)                            ; adjust to 273.000 C offset
39DE 123499     429            lcall sub32                     ; result of lm335 temp remains in x
39E1 85304C     430            mov temp_lm+0, x+0          ; store 3 decimal lm335 value
39E4 85314D     431       mov temp_lm+1, x+1                           
39E7 85324E     432       mov temp_lm+2, x+2
39EA 85334F     433       mov temp_lm+3, x+3
39ED 7534E8     434            mov y+0, #low (1000 % 0x10000) 
39F0 753503     434            mov y+1, #high(1000 % 0x10000) 
39F3 753600     434            mov y+2, #low (1000 / 0x10000) 
39F6 753700     434            mov y+3, #high(1000 / 0x10000) 
39F9 1235BA     435            lcall div32
39FC 853050     436            mov temp_offset, x+0            ; move to temp offset to retrieve mV value
39FF 853150     437            mov temp_offset, x+1
3A02            438   
3A02            439   read_opamp:
3A02            440   ;test
3A02 755001     441            mov temp_offset+0, #0x01
3A05 755101     442            mov temp_offset+1, #0x01
3A08            443   
3A08 123385     444            lcall Load_Thermodata
3A0B 855230     445            mov x+0, mV_offset+0          
3A0E 855331     446       mov x+1, mV_offset+1
3A11 753200     447       mov x+2, #0
3A14 753300     448       mov x+3, #0
3A17            449   
3A17 855238     450            mov data_out+0, mV_offset+0
3A1A 855339     451            mov data_out+1, mV_offset+1
3A1D            452   
3A1D            453   ;add_lm335_to_opamp:
3A1D            454       ;mov y+0, OPAMP_temp+0       ; load opamp temp to y
3A1D            455       ;mov y+1, OPAMP_temp+1
3A1D            456       ;mov y+2, OPAMP_temp+2
3A1D            457       ;mov y+3, OPAMP_temp+3
3A1D            458       ;lcall add32                         ; lm335 + opamp = real temp
3A1D 853044     459       mov temp_mc+0, x+0          ; store result in temp_mc (for python)
3A20 853145     460       mov temp_mc+1, x+1                           
3A23 853246     461       mov temp_mc+2, x+2
3A26 853347     462       mov temp_mc+3, x+3
3A29            463   
3A29            464   export_to_bcd:
3A29            465            ;lcall hex2bcd                                  ; Convert val stored in x to BCD in "bcd"
3A29            466            ;lcall Display_formated_BCD     
3A29            467            
3A29 85525D     468            mov Val_test+0, mV_offset+0          ; store result in temp_mc (for python)
3A2C 85535E     469       mov Val_test+1, mV_offset+1          
3A2F 755F00     470       mov Val_test+2, #0
3A32 756000     471       mov Val_test+3, #0
3A35 123634     472            lcall Display_Val
3A38            473   
3A38            474   
3A38            475   export_to_main:
3A38 854430     476            mov x+0, temp_mc+0          
3A3B 854531     477       mov x+1, temp_mc+1
3A3E 854632     478       mov x+2, temp_mc+2
3A41 854733     479       mov x+3, temp_mc+3
3A44 7534E8     480            mov y+0, #low (1000 % 0x10000) 
3A47 753503     480            mov y+1, #high(1000 % 0x10000) 
3A4A 753600     480            mov y+2, #low (1000 / 0x10000) 
3A4D 753700     480            mov y+3, #high(1000 / 0x10000) 
3A50 1235BA     481       lcall div32
3A53 853043     482       mov tempc, x+0              ; Both tempc and x now stores temp (C)           
3A56            483   
3A56            484   Export:                                                  ; Data export to python
3A56 7AFA       485            mov R2, #250                            ; Wait 500 ms between conversions
3A58 123839     486            lcall waitms
3A5B 7AFA       487            mov R2, #250
3A5D 123839     488            lcall waitms                            ; Sends binary contents of 
3A60            489   
3A60 1237E1     490       lcall SendBin                                ; temp_mc and data_out to python
3A63            491   
3A63            492            ; /* FSM1 STATE CHANGE CONTROLS */
3A63 023A66     493            ljmp FSM1
3A66            494   
3A66            495   ; REQUIREMENTS
3A66            496   ; Start/Stop button, to do this, make routine which displays "stopped" for a little bit
3A66            497   ; Temperature display, implemented already
3A66            498   ; Running time display, implement in main
3A66            499   ; 
3A66            500   
3A66            501   
3A66            502   FSM1:
3A66 E554       503            mov a, FSM1_state
3A68            504   
3A68            505   FSM1_state0:
3A68 B40011     506            cjne a, #0, FSM1_state1 ; if FSM1_state (currently stored in a) is not equal to zero (ie. state zero), go to state 1
3A6B 755800     507            mov pwm, #0
3A6E C201       508            clr seconds_flag
3A70            509            ; check for push button input
3A70 208406     510            jb START_BUTTON, FSM1_state0_done
3A73 3084FD     511            jnb START_BUTTON, $ ; Wait for key release
3A76 755401     512            mov FSM1_state, #1
3A79            513   
3A79            514   FSM1_state0_done:
3A79 023961     515            ljmp FSM_sys
3A7C            516   
3A7C            517   FSM1_state1:
3A7C B40113     518            cjne a, #1, FSM1_state2
3A7F 755864     519            mov pwm, #100
3A82 755700     520            mov seconds, #0
3A85 7496       521            mov a, #150
3A87 C3         522            clr c
3A88 9543       523            subb a, tempc
3A8A 5003       524            jnc FSM1_state1_done
3A8C 755402     525            mov FSM1_state, #2
3A8F            526   
3A8F            527   FSM1_state1_done:
3A8F 023961     528            ljmp FSM_sys
3A92            529   
3A92            530   FSM1_state2:
3A92 B4021B     531            cjne a, #2, FSM1_state3
3A95 755814     532            mov pwm, #20
3A98 30010A     533            jnb seconds_flag, FSM_state2_funk
3A9B            534            ;mov a, #60
3A9B E55C       535            mov a, SoakTime
3A9D C3         536            clr c
3A9E 9557       537            subb a, seconds                 ; Want time to be greater than 60 seconds
3AA0 400B       538            jc FSM1_state2_done
3AA2 755403     539            mov FSM1_state, #3
3AA5            540   
3AA5            541   FSM_state2_funk:
3AA5 755700     542            mov seconds, #0         ; Set seconds so we can count up to the required time 
3AA8 D201       543            setb seconds_flag       ; seconds flag so we don't reset seconds_flag multiple times
3AAA 023A92     544            ljmp FSM1_state2        
3AAD            545   
3AAD            546   FSM1_state2_done:
3AAD 023961     547            ljmp FSM_sys
3AB0            548   
3AB0            549   FSM1_state3:
3AB0 B40312     550            cjne a, #3, FSM1_state4
3AB3 755864     551            mov pwm, #100
3AB6            552            ;mov a, #220
3AB6 E55A       553            mov a, ReflowTemp
3AB8 C201       554            clr seconds_flag
3ABA C3         555            clr c
3ABB 9543       556            subb a, tempc
3ABD 5003       557            jnc FSM1_state3_done
3ABF 755404     558            mov FSM1_state, #4
3AC2            559   
3AC2            560   FSM1_state3_done:
3AC2 023961     561            ljmp FSM_sys
3AC5            562   
3AC5            563   FSM1_state4:
3AC5 B4041B     564            cjne a, #4, FSM1_state5
3AC8 755814     565            mov pwm, #20 
3ACB 30010A     566            jnb seconds_flag, FSM1_state4_funk
3ACE            567            ;mov a, #45
3ACE E55B       568            mov a, ReflowTime
3AD0 C3         569            clr c 
3AD1 9557       570            subb a, seconds ; when seconds is greater than 45, there will be a carry bit
3AD3 400B       571            jc FSM1_state4_done
3AD5 755405     572            mov FSM1_state, #5
3AD8            573   
3AD8            574   FSM1_state4_funk:
3AD8 755700     575            mov seconds, #0
3ADB D201       576            setb seconds_flag
3ADD 023AC5     577            ljmp FSM1_state4
3AE0            578   
3AE0            579   FSM1_state4_done:
3AE0 023961     580            ljmp FSM_sys
3AE3            581   
3AE3            582   FSM1_state5:
3AE3 B40510     583            cjne a, #5, FSM1_abort_state            ; if the state is not in 0-5, then it must be 10 (aka the abort state)
3AE6 755800     584            mov pwm, #0
3AE9 743C       585            mov a, #60
3AEB C3         586            clr c
3AEC 9543       587            subb a, tempc
3AEE 4003       588            jc FSM1_state5_done
3AF0 755400     589            mov FSM1_state, #0
3AF3            590   
3AF3            591   FSM1_state5_done:
3AF3 023961     592            ljmp FSM_sys
3AF6            593   
3AF6            594   FSM1_abort_state:                                                ; When the abort state is triggered, turn everything off and remain in this state utill you reset
3AF6 755800     595            mov pwm, #0
3AF9 C0E0       596            push acc
3AFB 7401       596            mov a, #1
3AFD 14         596            dec a
3AFE 123357     596            lcall ?Set_Cursor_1 ; Select column and row
3B01 D0E0       596            pop acc
3B03 C083       597            push dph
3B05 C082       597            push dpl
3B07 C0E0       597            push acc
3B09 9032AD     597            mov dptr, #abort_message
3B0C 12334A     597            lcall ?Send_Constant_String
3B0F D0E0       597            pop acc
3B11 D082       597            pop dpl
3B13 D083       597            pop dph
3B15            598   
3B15 023AF6     599            ljmp FSM1_abort_state
3B18            600   
3B18            601   END
