                  2   $LIST
0000              4   
0000              5   ;  N76E003 pinout:
0000              6   ;                               -------
0000              7   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000              8   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000              9   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             10   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             11   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             12   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             13   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             14   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             15   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             16   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             17   ;                               -------
0000             18   ;
0000             19   
0000             20   CLK                 EQU 16600000                                                 ; Microcontroller system frequency in Hz
0000             21   BAUD                EQU 115200                                                   ; Baud rate of UART in bps
0000             22   TIMER1_RELOAD       EQU (0x100-(CLK/(16*BAUD)))
0000             23   TIMER0_RELOAD_1MS   EQU (0x10000-(CLK/1000))
0000             24   TIMER2_RATE              EQU 100                                                         ; 1/100 = 10ms
0000             25   TIMER2_RELOAD            EQU (65536-(CLK/(16*TIMER2_RATE)))
0000             26   GAIN                             EQU 25
0000             27   ;V2C_DIVISOR                     EQU (GAIN*41)
0000             28   V2C_DIVISOR                      EQU 1051
0000             29   
0000             30   ; /*** PORT DEFINITIONS ***/
0000             31   LCD_RS                   equ P1.3
0000             32   LCD_E                    equ P1.4
0000             33   LCD_D4                   equ P0.0
0000             34   LCD_D5                   equ P0.1
0000             35   LCD_D6                   equ P0.2
0000             36   LCD_D7                   equ P0.3
0000             37   PWM_OUT                  equ P1.0
0000             38   START_BUTTON     equ P0.4
0000             39   ; Analog Input Port Numbering
0000             40   LED_PORT                 equ 0x00                        ; AIN port numbers
0000             41   LM335_PORT               equ 0x05
0000             42   OPAMP_PORT               equ 0x07
0000             43   AINCONFIG                equ 0b10100001          ; bits 1 = toggled analog in
0000             44   
0000             45   ; /*** VECTORS ***/
0000             46   org 0000H
0000 0239D3      47            ljmp Main
0003             48   
002B             49   org 002BH                                        ; timer 2 enable
002B 023818      50            ljmp Timer2_ISR
002E             51   
3000             52   org 3000H                                        ; lookup table stored at APROM address starting 0x4000
3000             53   ;        $NOLIST
                 -1    	$include(thermodata.inc)
3000              1   ; Contains mV offset for Thermocouple
3000              2   ; Stored in APROM location: 0x3000
3000              3   thermodata:
3000 00000027     4       DW  0, 39, 79, 119, 158, 198, 238, 277, 317, 357, 397, 437, 477, 517, 557, 597 
     004F0077
     009E00C6
     00EE0115
     013D0165
     018D01B5
     01DD0205
     022D0255
3020 027D02A5     5       DW  637, 677, 718, 758, 798, 838, 879, 919, 960, 1000, 1041, 1081, 1122, 1163, 1203, 1244
     02CE02F6
     031E0346
     036F0397
     03C003E8
     04110439
     0462048B
     04B304DC
3040 0505052E     6       DW  1285, 1326, 1366, 1407, 1448, 1489, 1530, 1571, 1612, 1653, 1694, 1735, 1776, 1817, 1858, 1899
     0556057F
     05A805D1
     05FA0623
     064C0675
     069E06C7
     06F00719
     0742076B
3060 079507BE     7       DW  1941, 1982, 2023, 2064, 2106, 2147, 2188, 2230, 2271, 2312, 2354, 2395, 2436, 2478, 2519, 2561 
     07E70810
     083A0863
     088C08B6
     08DF0908
     0932095B
     098409AE
     09D70A01
3080 0A2A0A54     8       DW  2602, 2644, 2685, 2727, 2768, 2810, 2851, 2893, 2934, 2976, 3017, 3059, 3100, 3142, 3184, 3225
     0A7D0AA7
     0AD00AFA
     0B230B4D
     0B760BA0
     0BC90BF3
     0C1C0C46
     0C700C99
30A0 0CC30CEC     9       DW  3267, 3308, 3350, 3391, 3433, 3474, 3516, 3557, 3599, 3640, 3682, 3723, 3765, 3806, 3848, 3889 
     0D160D3F
     0D690D92
     0DBC0DE5
     0E0F0E38
     0E620E8B
     0EB50EDE
     0F080F31
30C0 0F5B0F84    10       DW  3931, 3972, 4013, 4055, 4096, 4138, 4179, 4220, 4262, 4303, 4344, 4385, 4427, 4468, 4509, 4550 
     0FAD0FD7
     1000102A
     1053107C
     10A610CF
     10F81121
     114B1174
     119D11C6
30E0 11EF1219    11       DW  4591, 4633, 4674, 4715, 4756, 4797, 4838, 4879, 4920, 4961, 5002, 5043, 5084, 5124, 5165, 5206
     1242126B
     129412BD
     12E6130F
     13381361
     138A13B3
     13DC1404
     142D1456
3100 147F14A8    12       DW  5247, 5288, 5328, 5369, 5410, 5450, 5491, 5532, 5572, 5613, 5653, 5694, 5735, 5775, 5815, 5856
     14D014F9
     1522154A
     1573159C
     15C415ED
     1615163E
     1667168F
     16B716E0
3120 17081731    13       DW  5896, 5937, 5977, 6017, 6058, 6098, 6138, 6179, 6219, 6259, 6299, 6339, 6380, 6420, 6460, 6500
     17591781
     17AA17D2
     17FA1823
     184B1873
     189B18C3
     18EC1914
     193C1964
3140 198C19B4    14       DW  6540, 6580, 6620, 6660, 6701, 6741, 6781, 6821, 6861, 6901, 6941, 6981, 7021, 7060, 7100, 7140
     19DC1A04
     1A2D1A55
     1A7D1AA5
     1ACD1AF5
     1B1D1B45
     1B6D1B94
     1BBC1BE4
3160 1C0C1C34    15       DW  7180, 7220, 7260, 7300, 7340, 7380, 7420, 7460, 7500, 7540, 7579, 7619, 7659, 7699, 7739, 7779
     1C5C1C84
     1CAC1CD4
     1CFC1D24
     1D4C1D74
     1D9B1DC3
     1DEB1E13
     1E3B1E63
3180 1E8B1EB3    16       DW  7819, 7859, 7899, 7939, 7979, 8019, 8059, 8099, 8138, 8178, 8218, 8258, 8298, 8338, 8378, 8418
     1EDB1F03
     1F2B1F53
     1F7B1FA3
     1FCA1FF2
     201A2042
     206A2092
     20BA20E2
31A0 210A2133    17       DW  8458, 8499, 8539, 8579, 8619, 8659, 8699, 8739, 8779, 8819, 8860, 8900, 8940, 8980, 9020, 9061
     215B2183
     21AB21D3
     21FB2223
     224B2273
     229C22C4
     22EC2314
     233C2365
31C0 238D23B5    18       DW  9101, 9141, 9181, 9222, 9262, 9302, 9343, 9383, 9423, 9464, 9504, 9545, 9585, 9626, 9666, 9707
     23DD2406
     242E2456
     247F24A7
     24CF24F8
     25202549
     2571259A
     25C225EB
31E0 2613263C    19       DW  9747, 9788, 9828, 9869, 9909, 9950, 9991, 10031, 10072, 10113, 10153, 10194, 10235, 10276, 10316, 10357 
     2664268D
     26B526DE
     2707272F
     27582781
     27A927D2
     27FB2824
     284C2875
3200 289E28C7    20       DW  10398, 10439, 10480, 10520, 10561, 10602, 10643, 10684, 10725, 10766, 10807, 10848, 10889, 10930, 10971, 11012 
     28F02918
     2941296A
     299329BC
     29E52A0E
     2A372A60
     2A892AB2
     2ADB2B04
3220 2B2D2B56    21       DW  11053, 11094, 11135, 11176, 11217, 11259, 11300, 11341, 11382, 11423, 11465, 11506, 11547, 11588, 11630, 11671
     2B7F2BA8
     2BD12BFB
     2C242C4D
     2C762C9F
     2CC92CF2
     2D1B2D44
     2D6E2D97
3240 2DC02DE9    22       DW  11712, 11753, 11795, 11836, 11877, 11919, 11960, 12001, 12043, 12084, 12126, 12167, 12209, 12250, 12291, 12333
     2E132E3C
     2E652E8F
     2EB82EE1
     2F0B2F34
     2F5E2F87
     2FB12FDA
     3003302D
3260 30563080    23       DW  12374, 12416, 12457, 12499, 12540, 12582, 12624
     30A930D3
     30FC3126
     3150
326E             24   
326E             55   ;        $List
326E             56   
326E             57   ; /*** DIRECT ACCESS VARIABLES @RAM 0x30 -> 0x7F ***/
0030             58   DSEG at 30H
0030             59   x:                       ds 4            ; for math
0034             60   y:                       ds 4
0038             61   data_out:        ds 4            ; for python
003C             62   bcd:                     ds 5            ; for display
0041             63   
0041             64   VLED_ADC:                ds 2            ; for temperature 
0043             65   dtemp:                   ds 2
0045             66   tempc:                   ds 1
0046             67   temp_mc:                 ds 4
004A             68   OPAMP_temp:      ds 4
004E             69   temp_lm:                 ds 4
0052             70   temp_offset:     ds 2
0054             71   mV_offset:       ds 2
0056             72   
0056             73   FSM1_state:      ds 1            ; fsm states
0057             74   
0057             75   pwm_counter:     ds 1            ; time check and pwm
0058             76   count10ms:               ds 1
0059             77   seconds:                 ds 1
005A             78   pwm:                     ds 1
005B             79   abort_time:              ds 1
005C             80   
005C             81   ReflowTemp:      ds 1            ; reflow profile parameters
005D             82   ReflowTime:              ds 1
005E             83   SoakTime:                ds 1
005F             84   
005F             85   Val_test:                ds 4
0063             86   Val_temp:                ds 4
0067             87   
0067             88   ; /*** SINGLE BIT VARIABLES @RAM 0x20 -> 0x2F ***/
0000             89   BSEG 
0000             90   mf:                      dbit 1
0001             91   seconds_flag:    dbit 1
0002             92   s_flag:                  dbit 1
0003             93   
0003             94   ; /*** CODE SEGMENT ***/
326E             95   CSEG
326E             96   ;                     1234567890123456    <- This helps determine the location of the counter
326E 2A2A2A2A    97   test_message:     db '****LOADING*****', 0
     4C4F4144
     494E472A
     2A2A2A2A
     00
327F 54454D50    98   value_message:    db 'TEMP:      ', 0
     3A202020
     20202000
328B 43454C43    99   cel_message:       db 'CELCIUS  READING',0
     49555320
     20524541
     44494E47
     00
329C 46415245   100   fah_message:      db 'FARENHET READING',0
     4E484554
     20524541
     44494E47
     00
32AD 41424F52   101   abort_message:     db 'ABORTABORTABORT ', 0
     5441424F
     52544142
     4F525420
     00
007E             41   
007E             42   CSEG
007E             43   
007E             44   ; /* PORT DEFINITIONS */
007E             45   LCD_RS equ P1.3
007E             46   LCD_E  equ P1.4
007E             47   LCD_D4 equ P0.0
007E             48   LCD_D5 equ P0.1
007E             49   LCD_D6 equ P0.2
007E             50   LCD_D7 equ P0.3
007E             51   
007E             52   PWM_OUT equ P1.0
007E             53   START_BUTTON equ P0.4
007E             54   ; Analog Input Port Numbering
007E             55   LED_PORT equ 0x00                        ; AIN port numbers
007E             56   LM335_PORT equ 0x05
007E             57   OPAMP_PORT equ 0x01
007E             58   
                 60   	$LIST
0146             62   
0146             63   ; /* MATH.INC STUFFS */
0030             64   DSEG at 30H
0030             65   x:               ds 4
0034             66   y:               ds 4
0038             67   data_out:   ds 1
0039             68   
0039             69   bcd:             ds 5
003E             70   temp_out:        ds 4
0042             71   
0042             72   VLED_ADC: ds 2
0044             73   dtemp:  ds 2
0046             74   tempc: ds 1
0047             75   temp_mc:         ds 4
004B             76   OPAMP_temp: ds 4
004F             77   
004F             78   ; /* FSM STATES */
004F             79   FSM1_state:  ds 1
0050             80   
0050             81   ; /* TIME CHECK AND PWM */
0050             82   pwm_counter:     ds 1
0051             83   count10ms:               ds 1
0052             84   seconds:                 ds 1
0053             85   pwm:                     ds 1
0054             86   abort_time:              ds 1
0055             87   
0055             88   ; /* Reflow profile parameters */
0055             89   ReflowTemp:      ds 1
0056             90   ReflowTime:              ds 1
0057             91   SoakTime:                ds 1
0058             92   
0000             93   BSEG
0000             94   mf: dbit 1
0001             95   seconds_flag: dbit 1
0002             96   s_flag: dbit 1
0003             97   
0003             98   
                546   $LIST
3793            141   $LIST
                107   $LIST
3793            109   
3793            110   
3793            111   InitAll:
3793            112            ; /*** SERIAL PORT INITIALIZATION ***/
3793 75AC00     113            mov     P3M1,#0x00                      ; Configure all the pins for biderectional I/O
3796 75AD00     114            mov     P3M2,#0x00
3799 75B300     115            mov     P1M1,#0x00
379C 75B400     116            mov     P1M2,#0x00
379F 75B100     117            mov     P0M1,#0x00
37A2 75B200     118            mov     P0M2,#0x00
37A5            119       ; Since the reset button bounces, we need to wait a bit before
37A5            120       ; sending messages, otherwise we risk displaying gibberish!
37A5            121       ;mov R1, #200
37A5            122       ;mov R0, #104
37A5            123       ;djnz R0, $                                  ; 4 cycles->4*60.285ns*104=25us
37A5            124       ;djnz R1, $-4                                ; 25us*200=5.0ms
37A5 7A05       125       mov R2, #5
37A7 1238FD     126       lcall waitms
37AA            127       ; Now we can proceed with the configuration of the serial port
37AA 438E10     128            orl     CKCON, #0x10                    ; CLK is the input for timer 1
37AD 438780     129            orl     PCON, #0x80                     ; Bit SMOD=1, double baud rate
37B0 759852     130            mov     SCON, #0x52
37B3 53C4DF     131            anl     T3CON, #0b11011111
37B6 53890F     132            anl     TMOD, #0x0F                             ; Clear the configuration bits for timer 1
37B9 438920     133            orl     TMOD, #0x20                     ; Timer 1 Mode 2
37BC 758DF7     134            mov     TH1, #TIMER1_RELOAD
37BF D28E       135            setb TR1
37C1            136   
37C1            137            ; /*** INITIALIZE THE REST ***/
37C1 438E10     138            orl     CKCON, #0x10                    ; CLK is the input for timer 1
37C4 438780     139            orl     PCON, #0x80                     ; Bit SMOD=1, double baud rate
37C7 759852     140            mov     SCON, #0x52
37CA 53C4DF     141            anl     T3CON, #0b11011111
37CD 53890F     142            anl     TMOD, #0x0F                     ; Clear the configuration bits for timer 1
37D0 438920     143            orl     TMOD, #0x20                     ; Timer 1 Mode 2
37D3 758DF7     144            mov     TH1, #TIMER1_RELOAD     ; TH1=TIMER1_RELOAD;
37D6 D28E       145            setb TR1
37D8            146            
37D8            147            ; Using timer 0 for delay functions.  Initialize here:
37D8 C28C       148            clr     TR0                                     ; Stop timer 0
37DA 438E08     149            orl     CKCON,#0x08                     ; CLK is the input for timer 0
37DD 5389F0     150            anl     TMOD,#0xF0                              ; Clear the configuration bits for timer 0
37E0 438901     151            orl     TMOD,#0x01                              ; Timer 0 in Mode 1: 16-bit timer
37E3            152            
37E3            153            ; Initialize the pin used by the ADC (P1.1) as input.
37E3 43B302     154            orl     P1M1, #0b00000010
37E6 53B4FD     155            anl     P1M2, #0b11111101
37E9            156            
37E9            157            ; Initialize and start the ADC:
37E9 53E8F0     158            anl ADCCON0, #0xF0
37EC 43E807     159            orl ADCCON0, #0x07                      ; Select channel 7
37EF            160            ; AINDIDS select if some pins are analog inputs or digital I/O:
37EF 75F600     161            mov AINDIDS, #0x00                      ; Disable all analog inputs
37F2 43F640     162            orl AINDIDS, #0b1000000         ; P1.1 is analog input
37F5 43E101     163            orl ADCCON1, #0x01                      ; Enable ADC
37F8 755200     164            mov temp_offset, #0x00
37FB            165   
37FB            166   
37FB            167   ;----------------------------------------------------------------;
37FB            168   ;                                        TIMER 2 INITIALIZATION
37FB            169   ;----------------------------------------------------------------;
37FB            170   
37FB 75C800     171            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
37FE 75CDD7     172            mov TH2, #high(TIMER2_RELOAD)
3801 75CC79     173            mov TL2, #low(TIMER2_RELOAD)
3804            174            ; Set the reload value
3804 75C9A0     175            mov T2MOD, #0b1010_0000 ; Enable timer 2 autoreload, and clock divider is 16
3807 75CBD7     176            mov RCMP2H, #high(TIMER2_RELOAD)
380A 75CA79     177            mov RCMP2L, #low(TIMER2_RELOAD)
380D            178            ; Init the free running 10 ms counter to zero
380D 755700     179            mov pwm_counter, #0
3810            180            ; Enable the timer and interrupts
3810 439B80     181            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
3813 D2CA       182       setb TR2  ; Enable timer 2
3815            183   
3815 D2AF       184            setb EA ; Enable global interrupts
3817 22         185       ret
3818            186   
3818            187   
3818            188   ;---------------------------------;
3818            189   ; ISR for Timer 2                 ;
3818            190   ;---------------------------------;
3818            191   Timer2_ISR:
3818 C2CF       192            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
381A C0D0       193            push psw
381C C0E0       194            push acc
381E            195            
381E 0557       196            inc pwm_counter
3820 C3         197            clr c
3821 E55A       198            mov a, pwm
3823 9557       199            subb a, pwm_counter ; If pwm_counter <= pwm then c=1
3825 B3         200            cpl c
3826 9290       201            mov PWM_OUT, c
3828            202            
3828 E557       203            mov a, pwm_counter
382A B46432     204            cjne a, #100, Timer2_ISR_done
382D            205            ; executes every second
382D 755700     206            mov pwm_counter, #0
3830 0559       207            inc seconds ; It is super easy to keep a seconds count here
3832 D202       208            setb s_flag
3834 E556       209            mov a, FSM1_state
3836 B40003     210            cjne a, #0, Abort_Check0                        ; For abort check, the abort should not trigger if you are in state 0
3839 02385F     211            ljmp Timer2_ISR_done
383C            212   
383C            213   Abort_Check0:
383C            214   ; Check if temperature is above 240. If so, abort
383C C3         215            clr c
383D E545       216            mov a, tempc
383F 94F0       217            subb a, #240                                            ; if a is greater than 240, there will be no carry bit so we need to abort
3841 4006       218            jc Abort_Check1                                                 ; if temperature is below 240, continue to next check
3843            219            ; abort routine
3843 75560A     220            mov FSM1_state, #10
3846 02385F     221       ljmp Timer2_ISR_done                ; if temp is above 240, abort condition has already been triggered, skip ahead to done
3849            222   
3849            223   Abort_Check1:
3849            224   ; Check if temperature is below 50. If so, check for how long
3849 E545       225            mov a, tempc
384B C3         226            clr c
384C 9432       227            subb a, #50                                                     ; if tempc (stored in a) is less than 50, there will be a carry bit
384E 500C       228            jnc Timer2_ISR_abort_done                       ; skip the abort checks if temperature is above 50
3850            229   
3850            230   Abort_Check2:
3850            231   ; Check if has been 60 seconds (at below 50 degrees)
3850 055B       232            inc abort_time
3852 E55B       233            mov a, abort_time
3854 C3         234            clr c
3855 943C       235            subb a, #60                                                     ; if abort_time is less than 60, there will be a carry bit
3857 5006       236            jnc Timer2_ISR_done                                     ; if there is a carry 
3859 75560A     237            mov FSM1_state, #10
385C            238   
385C            239   Timer2_ISR_abort_done:
385C 755B00     240            mov abort_time, #0
385F            241   
385F            242   Timer2_ISR_done:
385F D0E0       243            pop acc
3861 D0D0       244            pop psw
3863 32         245            reti
3864            246   
3864            247   line1:
3864 50574D20   248            DB 'PWM Example     '
     4578616D
     706C6520
     20202020
3874 00         249            DB 0
3875            250   line2:
3875 43686B20   251            DB 'Chk pin 15:P1.0 '
     70696E20
     31353A50
     312E3020
3885 00         252            DB 0
3886            253   
3886            254   ; /* Send a character using the serial port */
3886            255   putchar:
3886 3099FD     256       jnb TI, putchar
3889 C299       257       clr TI
388B F599       258       mov SBUF, a
388D 22         259       ret
388E            260   
388E            261   ; Send a constant-zero-terminated string using the serial port
388E            262   SendString:
388E E4         263       clr A
388F 93         264       movc A, @A+DPTR
3890 6006       265       jz SendStringDone
3892 123886     266       lcall putchar
3895 A3         267       inc DPTR
3896 80F6       268       sjmp SendString
3898            269   SendStringDone:
3898 22         270       ret
3899            271   
3899            272   ; Sends binary data to Python via putchar
3899            273   SendBin:                                         
3899 E4         274            clr A                                   ; Sends temp_mc
389A E546       275            mov a, temp_mc+0
389C 123886     276            lcall putchar
389F E4         277            clr A
38A0 E547       278            mov a, temp_mc+1
38A2 123886     279            lcall putchar
38A5 E4         280            clr A
38A6 E548       281            mov a, temp_mc+2
38A8 123886     282            lcall putchar
38AB E4         283            clr A
38AC E549       284            mov a, temp_mc+3
38AE 123886     285            lcall putchar
38B1            286   
38B1 E4         287            clr A                                   ; Sends data_out
38B2 E538       288            mov a, data_out+0
38B4 123886     289            lcall putchar
38B7 E4         290            clr A
38B8 E539       291            mov a, data_out+1
38BA 123886     292            lcall putchar
38BD E4         293            clr A                                   ; Sends data_out
38BE E53A       294            mov a, data_out+2
38C0 123886     295            lcall putchar
38C3 E4         296            clr A
38C4 E53B       297            mov a, data_out+3
38C6 123886     298            lcall putchar
38C9 22         299            ret
38CA            300   
38CA            301   ASCII_CHAR: 
38CA 30313233   302            db '0123456789ABCDEF'
     34353637
     38394142
     43444546
38DA            303   
38DA            304   Hello_World:
38DA 48656C6C   305       DB  'Hello, World!', '\r', '\n', 0
     6F2C2057
     6F726C64
     210D0A00
<<<<<<< Updated upstream
04F8            289   New_Line:
04F8 0D0A00     290            DB '\r', '\n', 0
04FB            291   
04FB            292   ; /* 1ms DELAY FUNCTIONS */
04FB            293   wait_1ms:
04FB C28C       294            clr     TR0 ; Stop timer 0
04FD C28D       295            clr     TF0 ; Clear overflow flag
04FF 758CBF     296            mov     TH0, #high(TIMER0_RELOAD_1MS)
0502 758A28     297            mov     TL0,#low(TIMER0_RELOAD_1MS)
0505 D28C       298            setb TR0
0507 308DFD     299            jnb     TF0, $ ; Wait for overflow
050A 22         300            ret
050B            301   waitms:
050B 1204FB     302            lcall wait_1ms
050E DAFB       303            djnz R2, waitms
0510 22         304            ret
0511            305   
0511            306   Display_formated_BCD: ;4 dig 
0511 C0E0       307            push acc
0513 7401       307            mov a, #1
0515 14         307            dec a
0516 120118     307            lcall ?Set_Cursor_1 ; Select column and row
0519 D0E0       307            pop acc
051B C083       308            push dph
051D C082       308            push dpl
051F C0E0       308            push acc
0521 90004B     308            mov dptr, #cel_message
0524 12010B     308            lcall ?Send_Constant_String
0527 D0E0       308            pop acc
0529 D082       308            pop dpl
052B D083       308            pop dph
052D C0E0       309            push acc
052F 7407       309            mov a, #7
0531 14         309            dec a
0532 120116     309            lcall ?Set_Cursor_2 ; Select column and row
0535 D0E0       309            pop acc
0537            309   
0537 C000       310            push ar0
0539 A83B       310            mov r0, bcd+2
053B 12011D     310            lcall ?Display_BCD
053E D000       310            pop ar0
0540 C0E0       311            push acc
0542 7409       311            mov a, #9
0544 14         311            dec a
0545 120116     311            lcall ?Set_Cursor_2 ; Select column and row
0548 D0E0       311            pop acc
054A C000       312            push ar0
054C A83A       312            mov r0, bcd+1
054E 12011D     312            lcall ?Display_BCD
0551 D000       312            pop ar0
0553 C0E0       313            push acc
0555 740A       313            mov a, #10
0557 14         313            dec a
0558 120116     313            lcall ?Set_Cursor_2 ; Select column and row
055B D0E0       313            pop acc
055D C000       314            push ar0
055F A83A       314            mov r0, bcd+1
0561 12011D     314            lcall ?Display_BCD
0564 D000       314            pop ar0
0566            315            
0566 C0E0       316            push acc
0568 740C       316            mov a, #12
056A 14         316            dec a
056B 120116     316            lcall ?Set_Cursor_2 ; Select column and row
056E D0E0       316            pop acc
0570 C000       317            push ar0
0572 A839       317            mov r0, bcd+0
0574 12011D     317            lcall ?Display_BCD
0577 D000       317            pop ar0
0579 C0E0       318            push acc
057B 740A       318            mov a, #10
057D 14         318            dec a
057E 120116     318            lcall ?Set_Cursor_2 ; Select column and row
0581 D0E0       318            pop acc
0583 C0E0       319            push acc
0585 742E       319            mov a, #'.'
0587 1200CE     319            lcall ?WriteData
058A D0E0       319            pop acc
058C C0E0       320            push acc
058E 7407       320            mov a, #7
0590 14         320            dec a
0591 120116     320            lcall ?Set_Cursor_2 ; Select column and row
0594 D0E0       320            pop acc
0596 C0E0       321            push acc
0598 7420       321            mov a, #0x20
059A 1200CE     321            lcall ?WriteData
059D D0E0       321            pop acc
059F C0E0       322            push acc
05A1 740F       322            mov a, #15
05A3 14         322            dec a
05A4 120116     322            lcall ?Set_Cursor_2 ; Select column and row
05A7 D0E0       322            pop acc
05A9 C0E0       323            push acc
05AB 74DF       323            mov a, #0xDF
05AD 1200CE     323            lcall ?WriteData
05B0 D0E0       323            pop acc
05B2 C0E0       324            push acc
05B4 7410       324            mov a, #16
05B6 14         324            dec a
05B7 120116     324            lcall ?Set_Cursor_2 ; Select column and row
05BA D0E0       324            pop acc
05BC C0E0       325            push acc
05BE 7443       325            mov a, #'C'
05C0 1200CE     325            lcall ?WriteData
05C3 D0E0       325            pop acc
05C5            326   
05C5 22         327            ret
05C6            328   
05C6            329   ; /* READ ADC */
05C6            330   Read_ADC:
05C6 C2EF       331            clr ADCF
05C8 D2EE       332            setb ADCS ;  ADC start trigger signal
05CA 30EFFD     333       jnb ADCF, $ ; Wait for conversion complete
05CD            334       
05CD            335       ; Read the ADC result and store in [R1, R0]
05CD E5C2       336       mov a, ADCRL
05CF 540F       337       anl a, #0x0f
05D1 F8         338       mov R0, a
05D2 E5C3       339       mov a, ADCRH   
05D4 C4         340       swap a
05D5 C0E0       341       push acc
05D7 540F       342       anl a, #0x0f
05D9 F9         343       mov R1, a
05DA D0E0       344       pop acc
05DC 54F0       345       anl a, #0xf0
05DE 48         346       orl a, R0
05DF F8         347       mov R0, A
05E0 22         348            ret
05E1            349   
05E1            350   Main:
05E1 75817F     351       mov SP, #0x7F ; Set the stack pointer to the begining of idata
05E4            352       
05E4 1203B6     353       lcall InitAll
05E7 1200D8     354       lcall LCD_4BIT
05EA            355   
05EA            356            ; Initialize all variables
05EA D201       357            setb seconds_flag
05EC 754F00     358            mov FSM1_state, #0
05EF 755200     359            mov seconds, #0
05F2 755500     360            mov ReflowTemp, #0
05F5 755600     361            mov ReflowTime, #0
05F8 755700     362            mov SoakTime, #0
05FB            363   
05FB            364       ; initial messages in LCD
05FB C0E0       365            push acc
05FD 7401       365            mov a, #1
05FF 14         365            dec a
0600 120118     365            lcall ?Set_Cursor_1 ; Select column and row
0603 D0E0       365            pop acc
0605 C083       366            push dph
0607 C082       366            push dpl
0609 C0E0       366            push acc
060B 90002E     366            mov dptr, #test_message
060E 12010B     366            lcall ?Send_Constant_String
0611 D0E0       366            pop acc
0613 D082       366            pop dpl
0615 D083       366            pop dph
0617 C0E0       367            push acc
0619 7401       367            mov a, #1
061B 14         367            dec a
061C 120116     367            lcall ?Set_Cursor_2 ; Select column and row
061F D0E0       367            pop acc
0621 C083       368            push dph
0623 C082       368            push dpl
0625 C0E0       368            push acc
0627 90003F     368            mov dptr, #value_message
062A 12010B     368            lcall ?Send_Constant_String
062D D0E0       368            pop acc
062F D082       368            pop dpl
0631 D083       368            pop dph
0633            369   
0633 753801     370            mov data_out, #0b00000001
0636            371   
0636            372   ;Forever: ;avaliable: r2, r3
0636            373   FSM_sys:
0636            374   ; /* TEMP_READ: READS TEMPERATURE */
0636            375   ; Note:     Before converting to be stored tempC, 
0636            376   ;           all values are stored as 32 bit numbers 
0636            377   ;           with 3 decimal points. (in milli-celcius)
0636            378   ;           
0636            379   ; Example:  2.07 V would be represented by the number
0636            380   ;           20700. (The real value * 1000).
0636            381   TEMP_READ:
0636 020669     382            ljmp read_led
0639            383   
0639            384   Avg_ADC:
0639 753000     385            mov x+0, #low (0 % 0x10000) 
063C 753100     385            mov x+1, #high(0 % 0x10000) 
063F 753200     385            mov x+2, #low (0 / 0x10000) 
0642 753300     385            mov x+3, #high(0 / 0x10000) 
0645 7D64       386       mov R5, #100
0647            387   sum_loop_avg:
0647 1205C6     388       lcall Read_ADC
064A 753700     389       mov y+3, #0
064D 753600     390       mov y+2, #0
0650 8935       391       mov y+1, R1
0652 8834       392       mov y+0, R0
0654 12020B     393       lcall add32
0657 DDEE       394       djnz R5, sum_loop_avg
0659 753400     395            mov y+0, #low (0 % 0x10000) 
065C 753500     395            mov y+1, #high(0 % 0x10000) 
065F 753600     395            mov y+2, #low (0 / 0x10000) 
0662 753700     395            mov y+3, #high(0 / 0x10000) 
0665 12034D     396       lcall div32
0668 22         397       ret
0669            398   
0669            399   read_led:
0669 53E8F0     400       anl ADCCON0, #0xf0          ; read led voltage
066C 43E800     401       orl ADCCON0, #LED_PORT
066F 1205C6     402       lcall Read_ADC
0672 8842       403       mov VLED_ADC+0, R0          ; save reading to VLED_ADC
0674 8943       404            mov VLED_ADC+1, R1
0676            405   
0676            406   read_opamp:
0676 53E8F0     407       anl ADCCON0, #0xf0          ; *** OPAMP ***
0679 43E801     408       orl ADCCON0, #OPAMP_PORT
067C 1205C6     409       lcall Read_ADC
067F 8830       410       mov x+0, R0                              ; load opamp reading to x
0681 8931       411            mov x+1, R1
0683 753200     412            mov x+2, #0                     
0686 753300     413            mov x+3, #0
0689 753498     414            mov y+0, #low (207000 % 0x10000) 
068C 753528     414            mov y+1, #high(207000 % 0x10000) 
068F 753603     414            mov y+2, #low (207000 / 0x10000) 
0692 753700     414            mov y+3, #high(207000 / 0x10000)               ; load const vled ref into y      
0695 1202C0     415       lcall mul32
0698 854234     416       mov y+0, VLED_ADC+0              ; import vled reading into y
069B 854335     417            mov y+1, VLED_ADC+1         
069E 753600     418            mov y+2, #0                     
06A1 753700     419            mov y+3, #0
06A4 12034D     420       lcall div32                 ; x value stores celcius 
06A7 7534E8     421            mov y+0, #low (1000 % 0x10000) 
06AA 753503     421            mov y+1, #high(1000 % 0x10000) 
06AD 753600     421            mov y+2, #low (1000 / 0x10000) 
06B0 753700     421            mov y+3, #high(1000 / 0x10000)                 ; celcius -> milli celcius 
06B3 85304B     422       mov OPAMP_temp+0, x+0       ; save calculated opamp temp (mili C)
06B6 85314C     423       mov OPAMP_temp+1, x+1
06B9 85324D     424       mov OPAMP_temp+2, x+2
06BC 85334E     425       mov OPAMP_temp+3, x+3
06BF            426   
06BF            427   read_lm335:
06BF 53E8F0     428       anl ADCCON0, #0xf0          ; *** LM335 ***
06C2 43E805     429       orl ADCCON0, #LM335_PORT
06C5 1205C6     430       lcall Read_ADC
06C8 8830       431       mov x+0, R0                              ; load lm335 reading to x
06CA 8931       432            mov x+1, R1
06CC 753200     433            mov x+2, #0                     
06CF 753300     434            mov x+3, #0
06D2 753498     435            mov y+0, #low (207000 % 0x10000) 
06D5 753528     435            mov y+1, #high(207000 % 0x10000) 
06D8 753603     435            mov y+2, #low (207000 / 0x10000) 
06DB 753700     435            mov y+3, #high(207000 / 0x10000)                ; load const vled ref into y      
06DE 1202C0     436       lcall mul32
06E1 854234     437       mov y+0, VLED_ADC+0              ; import vled reading into y
06E4 854335     438            mov y+1, VLED_ADC+1         
06E7 753600     439            mov y+2, #0                     
06EA 753700     440            mov y+3, #0
06ED 12034D     441       lcall div32
06F0 75340A     442            mov y+0, #low (10 % 0x10000) 
06F3 753500     442            mov y+1, #high(10 % 0x10000) 
06F6 753600     442            mov y+2, #low (10 / 0x10000) 
06F9 753700     442            mov y+3, #high(10 / 0x10000) 
06FC 1202C0     443       lcall mul32
06FF 753468     444            mov y+0, #low (273000 % 0x10000) 
0702 75352A     444            mov y+1, #high(273000 % 0x10000) 
0705 753604     444            mov y+2, #low (273000 / 0x10000) 
0708 753700     444            mov y+3, #high(273000 / 0x10000)                            ; adjust to 273.000 C offset
070B 12022C     445            lcall sub32                     ; result of lm335 temp remains in x
070E            446   
070E            447   add_lm335_to_opamp:
070E 854B34     448       mov y+0, OPAMP_temp+0       ; load opamp temp to y
0711 854C35     449       mov y+1, OPAMP_temp+1
0714 854D36     450       mov y+2, OPAMP_temp+2
0717 854E37     451       mov y+3, OPAMP_temp+3
071A            452       ;lcall add32                 ; lm335 + opamp = real temp
071A 853047     453       mov temp_mc+0, x+0          ; store result in temp_mc (for python)
071D 853148     454       mov temp_mc+1, x+1
0720 853249     455       mov temp_mc+2, x+2
0723 85334A     456       mov temp_mc+3, x+3
0726            457   
0726            458   export_to_main:
0726 7534E8     459            mov y+0, #low (1000 % 0x10000) 
0729 753503     459            mov y+1, #high(1000 % 0x10000) 
072C 753600     459            mov y+2, #low (1000 / 0x10000) 
072F 753700     459            mov y+3, #high(1000 / 0x10000) 
0732 12034D     460       lcall div32
0735 853046     461       mov tempc, x+0              ; Both tempc and x now stores temp (C)
0738            462   
0738 120146     463            lcall hex2bcd                           ; Convert val stored in x to BCD in "bcd"
073B 120511     464            lcall Display_formated_BCD
073E 1201CF     465       lcall bcd2hex                                ; hex number now stored in x                    
0741            466   
0741            467   Export:                                                  ; Data export to python
0741 7AFA       468            mov R2, #250                            ; Wait 500 ms between conversions
0743 12050B     469            lcall waitms
0746 7AFA       470            mov R2, #250
0748 12050B     471            lcall waitms                            ; Sends binary contents of 
074B 1204B9     472       lcall SendBin                                ; temp_mc and data_out to python
074E            473   
074E            474            ; /* FSM1 STATE CHANGE CONTROLS */
074E 020751     475            ljmp FSM1
0751            476   
0751            477   ; REQUIREMENTS
0751            478   ; Start/Stop button, to do this, make routine which displays "stopped" for a little bit
0751            479   ; Temperature display, implemented already
0751            480   ; Running time display, implement in main
0751            481   ; 
0751            482   
0751            483   
0751            484   FSM1:
0751 E54F       485            mov a, FSM1_state
0753            486   
0753            487   FSM1_state0:
0753 B40011     488            cjne a, #0, FSM1_state1 ; if FSM1_state (currently stored in a) is not equal to zero (ie. state zero), go to state 1
0756 755300     489            mov pwm, #0
0759 C201       490            clr seconds_flag
075B            491            ; check for push button input
075B 208406     492            jb START_BUTTON, FSM1_state0_done
075E 3084FD     493            jnb START_BUTTON, $ ; Wait for key release
0761 754F01     494            mov FSM1_state, #1
0764            495   
0764            496   FSM1_state0_done:
0764 020636     497            ljmp FSM_sys
0767            498   
0767            499   FSM1_state1:
0767 B40113     500            cjne a, #1, FSM1_state2
076A 755364     501            mov pwm, #100
076D 755200     502            mov seconds, #0
0770 7496       503            mov a, #150
0772 C3         504            clr c
0773 9546       505            subb a, tempc
0775 5003       506            jnc FSM1_state1_done
0777 754F02     507            mov FSM1_state, #2
077A            508   
077A            509   FSM1_state1_done:
077A 020636     510            ljmp FSM_sys
077D            511   
077D            512   FSM1_state2:
077D B4021B     513            cjne a, #2, FSM1_state3
0780 755314     514            mov pwm, #20
0783 30010A     515            jnb seconds_flag, FSM_state2_funk
0786            516            ;mov a, #60
0786 E557       517            mov a, SoakTime
0788 C3         518            clr c
0789 9552       519            subb a, seconds                 ; Want time to be greater than 60 seconds
078B 400B       520            jc FSM1_state2_done
078D 754F03     521            mov FSM1_state, #3
0790            522   
0790            523   FSM_state2_funk:
0790 755200     524            mov seconds, #0         ; Set seconds so we can count up to the required time 
0793 D201       525            setb seconds_flag       ; seconds flag so we don't reset seconds_flag multiple times
0795 02077D     526            ljmp FSM1_state2        
0798            527   
0798            528   FSM1_state2_done:
0798 020636     529            ljmp FSM_sys
079B            530   
079B            531   FSM1_state3:
079B B40312     532            cjne a, #3, FSM1_state4
079E 755364     533            mov pwm, #100
07A1            534            ;mov a, #220
07A1 E555       535            mov a, ReflowTemp
07A3 C201       536            clr seconds_flag
07A5 C3         537            clr c
07A6 9546       538            subb a, tempc
07A8 5003       539            jnc FSM1_state3_done
07AA 754F04     540            mov FSM1_state, #4
07AD            541   
07AD            542   FSM1_state3_done:
07AD 020636     543            ljmp FSM_sys
07B0            544   
07B0            545   FSM1_state4:
07B0 B4041B     546            cjne a, #4, FSM1_state5
07B3 755314     547            mov pwm, #20 
07B6 30010A     548            jnb seconds_flag, FSM1_state4_funk
07B9            549            ;mov a, #45
07B9 E556       550            mov a, ReflowTime
07BB C3         551            clr c 
07BC 9552       552            subb a, seconds ; when seconds is greater than 45, there will be a carry bit
07BE 400B       553            jc FSM1_state4_done
07C0 754F05     554            mov FSM1_state, #5
07C3            555   
07C3            556   FSM1_state4_funk:
07C3 755200     557            mov seconds, #0
07C6 D201       558            setb seconds_flag
07C8 0207B0     559            ljmp FSM1_state4
07CB            560   
07CB            561   FSM1_state4_done:
07CB 020636     562            ljmp FSM_sys
07CE            563   
07CE            564   FSM1_state5:
07CE B40510     565            cjne a, #5, FSM1_abort_state            ; if the state is not in 0-5, then it must be 10 (aka the abort state)
07D1 755300     566            mov pwm, #0
07D4 743C       567            mov a, #60
07D6 C3         568            clr c
07D7 9546       569            subb a, tempc
07D9 4003       570            jc FSM1_state5_done
07DB 754F00     571            mov FSM1_state, #0
07DE            572   
07DE            573   FSM1_state5_done:
07DE 020636     574            ljmp FSM_sys
07E1            575   
07E1            576   FSM1_abort_state:                                                ; When the abort state is triggered, turn everything off and remain in this state utill you reset
07E1 755300     577            mov pwm, #0
07E4 C0E0       578            push acc
07E6 7401       578            mov a, #1
07E8 14         578            dec a
07E9 120118     578            lcall ?Set_Cursor_1 ; Select column and row
07EC D0E0       578            pop acc
07EE C083       579            push dph
07F0 C082       579            push dpl
07F2 C0E0       579            push acc
07F4 90006D     579            mov dptr, #abort_message
07F7 12010B     579            lcall ?Send_Constant_String
07FA D0E0       579            pop acc
07FC D082       579            pop dpl
07FE D083       579            pop dph
0800            580   
0800 0207E1     581            ljmp FSM1_abort_state
0803            582   
0803            583   END
=======
38EA            306   New_Line:
38EA 0D0A00     307            DB '\r', '\n', 0
38ED            308   
38ED            309   ; /* 1ms DELAY FUNCTIONS */
38ED            310   wait_1ms:
38ED C28C       311            clr     TR0 ; Stop timer 0
38EF C28D       312            clr     TF0 ; Clear overflow flag
38F1 758CBF     313            mov     TH0, #high(TIMER0_RELOAD_1MS)
38F4 758A28     314            mov     TL0,#low(TIMER0_RELOAD_1MS)
38F7 D28C       315            setb TR0
38F9 308DFD     316            jnb     TF0, $ ; Wait for overflow
38FC 22         317            ret
38FD            318   waitms:
38FD 1238ED     319            lcall wait_1ms
3900 DAFB       320            djnz R2, waitms
3902 22         321            ret
3903            322   
3903            323   Display_formated_BCD: ;4 dig 
3903 C0E0       324            push acc
3905 7401       324            mov a, #1
3907 14         324            dec a
3908 123357     324            lcall ?Set_Cursor_1 ; Select column and row
390B D0E0       324            pop acc
390D C083       325            push dph
390F C082       325            push dpl
3911 C0E0       325            push acc
3913 90328B     325            mov dptr, #cel_message
3916 12334A     325            lcall ?Send_Constant_String
3919 D0E0       325            pop acc
391B D082       325            pop dpl
391D D083       325            pop dph
391F C0E0       326            push acc
3921 7407       326            mov a, #7
3923 14         326            dec a
3924 123355     326            lcall ?Set_Cursor_2 ; Select column and row
3927 D0E0       326            pop acc
3929            326   
3929 C000       327            push ar0
392B A83E       327            mov r0, bcd+2
392D 12335C     327            lcall ?Display_BCD
3930 D000       327            pop ar0
3932 C0E0       328            push acc
3934 7409       328            mov a, #9
3936 14         328            dec a
3937 123355     328            lcall ?Set_Cursor_2 ; Select column and row
393A D0E0       328            pop acc
393C C000       329            push ar0
393E A83D       329            mov r0, bcd+1
3940 12335C     329            lcall ?Display_BCD
3943 D000       329            pop ar0
3945 C0E0       330            push acc
3947 740A       330            mov a, #10
3949 14         330            dec a
394A 123355     330            lcall ?Set_Cursor_2 ; Select column and row
394D D0E0       330            pop acc
394F C000       331            push ar0
3951 A83D       331            mov r0, bcd+1
3953 12335C     331            lcall ?Display_BCD
3956 D000       331            pop ar0
3958            332            
3958 C0E0       333            push acc
395A 740C       333            mov a, #12
395C 14         333            dec a
395D 123355     333            lcall ?Set_Cursor_2 ; Select column and row
3960 D0E0       333            pop acc
3962 C000       334            push ar0
3964 A83C       334            mov r0, bcd+0
3966 12335C     334            lcall ?Display_BCD
3969 D000       334            pop ar0
396B C0E0       335            push acc
396D 740A       335            mov a, #10
396F 14         335            dec a
3970 123355     335            lcall ?Set_Cursor_2 ; Select column and row
3973 D0E0       335            pop acc
3975 C0E0       336            push acc
3977 742E       336            mov a, #'.'
3979 12330D     336            lcall ?WriteData
397C D0E0       336            pop acc
397E C0E0       337            push acc
3980 7407       337            mov a, #7
3982 14         337            dec a
3983 123355     337            lcall ?Set_Cursor_2 ; Select column and row
3986 D0E0       337            pop acc
3988 C0E0       338            push acc
398A 7420       338            mov a, #0x20
398C 12330D     338            lcall ?WriteData
398F D0E0       338            pop acc
3991 C0E0       339            push acc
3993 740F       339            mov a, #15
3995 14         339            dec a
3996 123355     339            lcall ?Set_Cursor_2 ; Select column and row
3999 D0E0       339            pop acc
399B C0E0       340            push acc
399D 74DF       340            mov a, #0xDF
399F 12330D     340            lcall ?WriteData
39A2 D0E0       340            pop acc
39A4 C0E0       341            push acc
39A6 7410       341            mov a, #16
39A8 14         341            dec a
39A9 123355     341            lcall ?Set_Cursor_2 ; Select column and row
39AC D0E0       341            pop acc
39AE C0E0       342            push acc
39B0 7443       342            mov a, #'C'
39B2 12330D     342            lcall ?WriteData
39B5 D0E0       342            pop acc
39B7 22         343            ret
39B8            344   
39B8            345   
39B8            346   ; /* READ ADC */
39B8            347   Read_ADC:
39B8 C2EF       348            clr ADCF
39BA D2EE       349            setb ADCS ;  ADC start trigger signal
39BC 30EFFD     350       jnb ADCF, $ ; Wait for conversion complete
39BF            351       
39BF            352       ; Read the ADC result and store in [R1, R0]
39BF E5C2       353       mov a, ADCRL
39C1 540F       354       anl a, #0x0f
39C3 F8         355       mov R0, a
39C4 E5C3       356       mov a, ADCRH   
39C6 C4         357       swap a
39C7 C0E0       358       push acc
39C9 540F       359       anl a, #0x0f
39CB F9         360       mov R1, a
39CC D0E0       361       pop acc
39CE 54F0       362       anl a, #0xf0
39D0 48         363       orl a, R0
39D1 F8         364       mov R0, A
39D2 22         365            ret
39D3            366   
39D3            367   Main:
39D3 75817F     368       mov SP, #0x7F        ; Set the stack pointer to the begining of idata
39D6            369       
39D6 123793     370       lcall InitAll
39D9 123317     371       lcall LCD_4BIT
39DC            372   
39DC            373            ; Initialize all variables
39DC D201       374            setb seconds_flag
39DE 755600     375            mov FSM1_state, #0
39E1 755900     376            mov seconds, #0
39E4 755C00     377            mov ReflowTemp, #0
39E7 755D00     378            mov ReflowTime, #0
39EA 755E00     379            mov SoakTime, #0
39ED            380   
39ED            381       ; initial messages in LCD
39ED C0E0       382            push acc
39EF 7401       382            mov a, #1
39F1 14         382            dec a
39F2 123357     382            lcall ?Set_Cursor_1 ; Select column and row
39F5 D0E0       382            pop acc
39F7 C083       383            push dph
39F9 C082       383            push dpl
39FB C0E0       383            push acc
39FD 90326E     383            mov dptr, #test_message
3A00 12334A     383            lcall ?Send_Constant_String
3A03 D0E0       383            pop acc
3A05 D082       383            pop dpl
3A07 D083       383            pop dph
3A09 C0E0       384            push acc
3A0B 7401       384            mov a, #1
3A0D 14         384            dec a
3A0E 123355     384            lcall ?Set_Cursor_2 ; Select column and row
3A11 D0E0       384            pop acc
3A13 C083       385            push dph
3A15 C082       385            push dpl
3A17 C0E0       385            push acc
3A19 90327F     385            mov dptr, #value_message
3A1C 12334A     385            lcall ?Send_Constant_String
3A1F D0E0       385            pop acc
3A21 D082       385            pop dpl
3A23 D083       385            pop dph
3A25            386   
3A25            387            ;mov data_out, #0b00000001
3A25            388   
3A25            389   ;Forever: ;avaliable: r2, r3
3A25            390   FSM_sys:
3A25            391   ; /* TEMP_READ: READS TEMPERATURE */
3A25            392   ; Note:     Before converting to be stored tempC, 
3A25            393   ;           all values are stored as 32 bit numbers 
3A25            394   ;           with 3 decimal points. (in milli-celcius)
3A25            395   ;           
3A25            396   ; Example:  2.07 V would be represented by the number
3A25            397   ;           20700. (The real value * 1000).
3A25            398   TEMP_READ:
3A25 023A58     399            ljmp read_led
3A28            400   
3A28            401   Avg_ADC:                                                 ; function for ADC noise reduction
3A28 753000     402            mov x+0, #low (0 % 0x10000) 
3A2B 753100     402            mov x+1, #high(0 % 0x10000) 
3A2E 753200     402            mov x+2, #low (0 / 0x10000) 
3A31 753300     402            mov x+3, #high(0 / 0x10000) 
3A34 7DFF       403       mov R5, #255
3A36            404   sum_loop_avg:
3A36 1239B8     405       lcall Read_ADC
3A39 753700     406       mov y+3, #0
3A3C 753600     407       mov y+2, #0
3A3F 8935       408       mov y+1, R1
3A41 8834       409       mov y+0, R0
3A43 123478     410       lcall add32
3A46 DDEE       411       djnz R5, sum_loop_avg
3A48 7534FF     412            mov y+0, #low (255 % 0x10000) 
3A4B 753500     412            mov y+1, #high(255 % 0x10000) 
3A4E 753600     412            mov y+2, #low (255 / 0x10000) 
3A51 753700     412            mov y+3, #high(255 / 0x10000) 
3A54 1235BA     413       lcall div32
3A57 22         414       ret
3A58            415   
3A58            416   read_led:
3A58 53E8F0     417       anl ADCCON0, #0xf0          ; read led voltage
3A5B 43E800     418       orl ADCCON0, #LED_PORT
3A5E 123A28     419       lcall Avg_ADC
3A61 8841       420       mov VLED_ADC+0, R0          ; save reading to VLED_ADC
3A63 8942       421            mov VLED_ADC+1, R1
3A65            422   
3A65            423   read_lm335:
3A65 53E8F0     424       anl ADCCON0, #0xf0          ; *** LM335 ***
3A68 43E805     425       orl ADCCON0, #LM335_PORT
3A6B 123A28     426       lcall Avg_ADC
3A6E 8830       427       mov x+0, R0                              ; load lm335 reading to x
3A70 8931       428            mov x+1, R1
3A72 753200     429            mov x+2, #0                     
3A75 753300     430            mov x+3, #0
3A78 7534A0     431            mov y+0, #low (260000 % 0x10000) 
3A7B 7535F7     431            mov y+1, #high(260000 % 0x10000) 
3A7E 753603     431            mov y+2, #low (260000 / 0x10000) 
3A81 753700     431            mov y+3, #high(260000 / 0x10000)               ; load const vled ref into y      
3A84 12352D     432       lcall mul32
3A87 854134     433       mov y+0, VLED_ADC+0              ; import vled reading into y
3A8A 854235     434            mov y+1, VLED_ADC+1         
3A8D 753600     435            mov y+2, #0                     
3A90 753700     436            mov y+3, #0
3A93 1235BA     437       lcall div32
3A96 753468     438            mov y+0, #low (273000 % 0x10000) 
3A99 75352A     438            mov y+1, #high(273000 % 0x10000) 
3A9C 753604     438            mov y+2, #low (273000 / 0x10000) 
3A9F 753700     438            mov y+3, #high(273000 / 0x10000)                            ; adjust to 273.000 C offset
3AA2 123499     439            lcall sub32                     ; result of lm335 temp remains in x
3AA5 85304E     440            mov temp_lm+0, x+0          ; store 3 decimal lm335 value for later
3AA8 85314F     441       mov temp_lm+1, x+1                           
3AAB 853250     442       mov temp_lm+2, x+2
3AAE 853351     443       mov temp_lm+3, x+3
3AB1            444   
3AB1            445   read_opamp:
3AB1 53E8F0     446            anl ADCCON0, #0xf0          ; *** OPAMP ***
3AB4 43E807     447       orl ADCCON0, #OPAMP_PORT     ; 
3AB7 123A28     448            lcall Avg_ADC
3ABA 8830       449            mov x+0, R0                         ; load opamp reading to x
3ABC 8931       450            mov x+1, R1
3ABE 753200     451            mov x+2, #0                     
3AC1 753300     452            mov x+3, #0
3AC4            453            ; mov data_out+0, R0                    
3AC4            454            ; mov data_out+1, R1            ;THIS WORKS
3AC4            455            ; mov data_out+2, #0
3AC4            456            ; mov data_out+3, #0
3AC4            457            
3AC4 753428     458            mov y+0, #low (2600 % 0x10000) 
3AC7 75350A     458            mov y+1, #high(2600 % 0x10000) 
3ACA 753600     458            mov y+2, #low (2600 / 0x10000) 
3ACD 753700     458            mov y+3, #high(2600 / 0x10000)                 ; load const vled ref (2070 mV) into y      
3AD0 12352D     459       lcall mul32
3AD3 854134     460       mov y+0, VLED_ADC+0              ; import led adc reading into y
3AD6 854235     461            mov y+1, VLED_ADC+1                
3AD9 753600     462            mov y+2, #0                     
3ADC 753700     463            mov y+3, #0
3ADF 1235BA     464       lcall div32                 ; x value now stores OPAMP V in mV
3AE2            465   
3AE2            466            ; mov data_out+0, x+0                   
3AE2            467            ; mov data_out+1, x+1                   ; THIS WORKS
3AE2            468            ; mov data_out+2, x+2
3AE2            469            ; mov data_out+3, x+3
3AE2            470   
3AE2            471   
3AE2            472   
3AE2 7534E8     473            mov y+0, #low (1000 % 0x10000) 
3AE5 753503     473            mov y+1, #high(1000 % 0x10000) 
3AE8 753600     473            mov y+2, #low (1000 / 0x10000) 
3AEB 753700     473            mov y+3, #high(1000 / 0x10000)                                  
3AEE 12352D     474            lcall mul32                                     ; turn mV to uV
3AF1 75341B     475            mov y+0, #low (V2C_DIVISOR % 0x10000) 
3AF4 753504     475            mov y+1, #high(V2C_DIVISOR % 0x10000) 
3AF7 753600     475            mov y+2, #low (V2C_DIVISOR / 0x10000) 
3AFA 753700     475            mov y+3, #high(V2C_DIVISOR / 0x10000) 
3AFD            476            
3AFD 1235BA     477            lcall div32                                     ; deg C reading now in x
3B00            478   
3B00            479            ; mov data_out+0, x+0           ; THIS WORKS            
3B00            480            ; mov data_out+1, x+1
3B00            481            ; mov data_out+2, x+2
3B00            482            ; mov data_out+3, x+3
3B00            483            ; mov temp_offset+0, x+0                ; use for reverse checking
3B00            484            ; mov temp_offset+1, x+1        
3B00            485            
3B00 7534E8     486            mov y+0, #low (1000 % 0x10000) 
3B03 753503     486            mov y+1, #high(1000 % 0x10000) 
3B06 753600     486            mov y+2, #low (1000 / 0x10000) 
3B09 753700     486            mov y+3, #high(1000 / 0x10000) 
3B0C 12352D     487            lcall mul32                                     ; conv to mV again to add to lm335 data
3B0F            488   
3B0F            489            ; mov data_out+0, x+0                           
3B0F            490            ; mov data_out+1, x+1   ; THIS WORKS
3B0F            491            ; mov data_out+2, x+2
3B0F            492            ; mov data_out+3, x+3
3B0F            493   
3B0F            494   add_lm335_to_opamp:
3B0F 854E34     495       mov y+0, temp_lm+0           ; load lm335 temp to y
3B12 854F35     496       mov y+1, temp_lm+1
3B15 855036     497       mov y+2, temp_lm+2
3B18 855137     498       mov y+3, temp_lm+3
3B1B 123478     499       lcall add32                  ; lm335 + opamp = real temp
3B1E 853046     500       mov temp_mc+0, x+0          ; store result in temp_mc (for python)
3B21 853147     501       mov temp_mc+1, x+1                           
3B24 853248     502       mov temp_mc+2, x+2
3B27 853349     503       mov temp_mc+3, x+3
3B2A            504   
3B2A 854638     505            mov data_out+0, temp_mc+0                               
3B2D 854739     506            mov data_out+1, temp_mc+1       
3B30 85483A     507            mov data_out+2, temp_mc+2
3B33 85493B     508            mov data_out+3, temp_mc+3
3B36            509   
3B36            510   export_to_bcd:
3B36            511            ; lcall hex2bcd                                 ; Convert val stored in x to BCD in "bcd"
3B36            512            ; lcall Display_formated_BCD
3B36 1236EC     513            lcall Display_x         
3B39            514            
3B39            515   export_to_main:
3B39 854630     516            mov x+0, temp_mc+0          
3B3C 854731     517       mov x+1, temp_mc+1
3B3F 854832     518       mov x+2, temp_mc+2
3B42 854933     519       mov x+3, temp_mc+3
3B45 7534E8     520            mov y+0, #low (1000 % 0x10000) 
3B48 753503     520            mov y+1, #high(1000 % 0x10000) 
3B4B 753600     520            mov y+2, #low (1000 / 0x10000) 
3B4E 753700     520            mov y+3, #high(1000 / 0x10000) 
3B51 1235BA     521       lcall div32
3B54 853045     522       mov tempc, x+0              ; Both tempc and x now stores temp (C)           
3B57            523   
3B57            524   Export:                                                  ; Data export to python
3B57 7AFA       525            mov R2, #250                            ; Wait 500 ms between conversions
3B59 1238FD     526            lcall waitms
3B5C 7AFA       527            mov R2, #250
3B5E 1238FD     528            lcall waitms                            ; Sends binary contents of 
3B61            529   
3B61 123899     530       lcall SendBin                                ; temp_mc and data_out to python
3B64            531   
3B64            532            ; /* FSM1 STATE CHANGE CONTROLS */
3B64 023B67     533            ljmp FSM1
3B67            534   
3B67            535   ; REQUIREMENTS
3B67            536   ; Start/Stop button, to do this, make routine which displays "stopped" for a little bit
3B67            537   ; Temperature display, implemented already
3B67            538   ; Running time display, implement in main
3B67            539   ; 
3B67            540   
3B67            541   
3B67            542   FSM1:
3B67 E556       543            mov a, FSM1_state
3B69            544   
3B69            545   FSM1_state0:
3B69 B40011     546            cjne a, #0, FSM1_state1 ; if FSM1_state (currently stored in a) is not equal to zero (ie. state zero), go to state 1
3B6C 755A00     547            mov pwm, #0
3B6F C201       548            clr seconds_flag
3B71            549            ; check for push button input
3B71 208406     550            jb START_BUTTON, FSM1_state0_done
3B74 3084FD     551            jnb START_BUTTON, $ ; Wait for key release
3B77 755601     552            mov FSM1_state, #1
3B7A            553   
3B7A            554   FSM1_state0_done:
3B7A 023A25     555            ljmp FSM_sys
3B7D            556   
3B7D            557   FSM1_state1:
3B7D B40113     558            cjne a, #1, FSM1_state2
3B80 755A64     559            mov pwm, #100
3B83 755900     560            mov seconds, #0
3B86 7496       561            mov a, #150
3B88 C3         562            clr c
3B89 9545       563            subb a, tempc
3B8B 5003       564            jnc FSM1_state1_done
3B8D 755602     565            mov FSM1_state, #2
3B90            566   
3B90            567   FSM1_state1_done:
3B90 023A25     568            ljmp FSM_sys
3B93            569   
3B93            570   FSM1_state2:
3B93 B4021B     571            cjne a, #2, FSM1_state3
3B96 755A14     572            mov pwm, #20
3B99 30010A     573            jnb seconds_flag, FSM_state2_funk
3B9C            574            ;mov a, #60
3B9C E55E       575            mov a, SoakTime
3B9E C3         576            clr c
3B9F 9559       577            subb a, seconds                 ; Want time to be greater than 60 seconds
3BA1 400B       578            jc FSM1_state2_done
3BA3 755603     579            mov FSM1_state, #3
3BA6            580   
3BA6            581   FSM_state2_funk:
3BA6 755900     582            mov seconds, #0         ; Set seconds so we can count up to the required time 
3BA9 D201       583            setb seconds_flag       ; seconds flag so we don't reset seconds_flag multiple times
3BAB 023B93     584            ljmp FSM1_state2        
3BAE            585   
3BAE            586   FSM1_state2_done:
3BAE 023A25     587            ljmp FSM_sys
3BB1            588   
3BB1            589   FSM1_state3:
3BB1 B40312     590            cjne a, #3, FSM1_state4
3BB4 755A64     591            mov pwm, #100
3BB7            592            ;mov a, #220
3BB7 E55C       593            mov a, ReflowTemp
3BB9 C201       594            clr seconds_flag
3BBB C3         595            clr c
3BBC 9545       596            subb a, tempc
3BBE 5003       597            jnc FSM1_state3_done
3BC0 755604     598            mov FSM1_state, #4
3BC3            599   
3BC3            600   FSM1_state3_done:
3BC3 023A25     601            ljmp FSM_sys
3BC6            602   
3BC6            603   FSM1_state4:
3BC6 B4041B     604            cjne a, #4, FSM1_state5
3BC9 755A14     605            mov pwm, #20 
3BCC 30010A     606            jnb seconds_flag, FSM1_state4_funk
3BCF            607            ;mov a, #45
3BCF E55D       608            mov a, ReflowTime
3BD1 C3         609            clr c 
3BD2 9559       610            subb a, seconds ; when seconds is greater than 45, there will be a carry bit
3BD4 400B       611            jc FSM1_state4_done
3BD6 755605     612            mov FSM1_state, #5
3BD9            613   
3BD9            614   FSM1_state4_funk:
3BD9 755900     615            mov seconds, #0
3BDC D201       616            setb seconds_flag
3BDE 023BC6     617            ljmp FSM1_state4
3BE1            618   
3BE1            619   FSM1_state4_done:
3BE1 023A25     620            ljmp FSM_sys
3BE4            621   
3BE4            622   FSM1_state5:
3BE4 B40510     623            cjne a, #5, FSM1_abort_state            ; if the state is not in 0-5, then it must be 10 (aka the abort state)
3BE7 755A00     624            mov pwm, #0
3BEA 743C       625            mov a, #60
3BEC C3         626            clr c
3BED 9545       627            subb a, tempc
3BEF 4003       628            jc FSM1_state5_done
3BF1 755600     629            mov FSM1_state, #0
3BF4            630   
3BF4            631   FSM1_state5_done:
3BF4 023A25     632            ljmp FSM_sys
3BF7            633   
3BF7            634   FSM1_abort_state:                                                ; When the abort state is triggered, turn everything off and remain in this state utill you reset
3BF7 755A00     635            mov pwm, #0
3BFA C0E0       636            push acc
3BFC 7401       636            mov a, #1
3BFE 14         636            dec a
3BFF 123357     636            lcall ?Set_Cursor_1 ; Select column and row
3C02 D0E0       636            pop acc
3C04 C083       637            push dph
3C06 C082       637            push dpl
3C08 C0E0       637            push acc
3C0A 9032AD     637            mov dptr, #abort_message
3C0D 12334A     637            lcall ?Send_Constant_String
3C10 D0E0       637            pop acc
3C12 D082       637            pop dpl
3C14 D083       637            pop dph
3C16            638   
3C16 023BF7     639            ljmp FSM1_abort_state
3C19            640   
3C19            641   END
>>>>>>> Stashed changes
