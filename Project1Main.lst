                  2   $LIST
0000              4   
0000              5   ;  N76E003 pinout:
0000              6   ;                               -------
0000              7   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000              8   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000              9   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             10   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             11   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             12   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             13   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             14   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             15   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             16   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             17   ;                               -------
0000             18   ;
0000             19   
0000             20   CLK                 EQU 16600000                                                 ; Microcontroller system frequency in Hz
0000             21   BAUD                EQU 115200                                                   ; Baud rate of UART in bps
0000             22   TIMER1_RELOAD       EQU (0x100-(CLK/(16*BAUD)))
0000             23   TIMER0_RELOAD_1MS   EQU (0x10000-(CLK/1000))
0000             24   TIMER2_RATE              EQU 100                                                         ; 1/100 = 10ms
0000             25   TIMER2_RELOAD            EQU (65536-(CLK/(16*TIMER2_RATE)))
0000             26   GAIN                             EQU 25
0000             27   ;V2C_DIVISOR                     EQU (GAIN*41)
0000             28   V2C_DIVISOR                      EQU 1051
0000             29   
0000             30   ; /*** PORT DEFINITIONS ***/
0000             31   LCD_RS                   equ P1.3
0000             32   LCD_E                    equ P1.4
0000             33   LCD_D4                   equ P0.0
0000             34   LCD_D5                   equ P0.1
0000             35   LCD_D6                   equ P0.2
0000             36   LCD_D7                   equ P0.3
0000             37   PWM_OUT                  equ P1.0
0000             38   START_BUTTON     equ P0.4
0000             39   ; Analog Input Port Numbering
0000             40   LED_PORT                 equ 0x00                        ; AIN port numbers
0000             41   LM335_PORT               equ 0x05
0000             42   OPAMP_PORT               equ 0x07
0000             43   AINCONFIG                equ 0b10100001          ; bits 1 = toggled analog in
0000             44   
0000             45   ; /*** VECTORS ***/
0000             46   org 0000H
0000 0239E4      47            ljmp Main
0003             48   
002B             49   org 002BH                                        ; timer 2 enable
002B 023829      50            ljmp Timer2_ISR
002E             51   
3000             52   org 3000H                                        ; lookup table stored at APROM address starting 0x4000
3000             53   ;        $NOLIST
                 -1    	$include(thermodata.inc)
3000              1   ; Contains mV offset for Thermocouple
3000              2   ; Stored in APROM location: 0x3000
3000              3   thermodata:
3000 00000027     4       DW  0, 39, 79, 119, 158, 198, 238, 277, 317, 357, 397, 437, 477, 517, 557, 597 
     004F0077
     009E00C6
     00EE0115
     013D0165
     018D01B5
     01DD0205
     022D0255
3020 027D02A5     5       DW  637, 677, 718, 758, 798, 838, 879, 919, 960, 1000, 1041, 1081, 1122, 1163, 1203, 1244
     02CE02F6
     031E0346
     036F0397
     03C003E8
     04110439
     0462048B
     04B304DC
3040 0505052E     6       DW  1285, 1326, 1366, 1407, 1448, 1489, 1530, 1571, 1612, 1653, 1694, 1735, 1776, 1817, 1858, 1899
     0556057F
     05A805D1
     05FA0623
     064C0675
     069E06C7
     06F00719
     0742076B
3060 079507BE     7       DW  1941, 1982, 2023, 2064, 2106, 2147, 2188, 2230, 2271, 2312, 2354, 2395, 2436, 2478, 2519, 2561 
     07E70810
     083A0863
     088C08B6
     08DF0908
     0932095B
     098409AE
     09D70A01
3080 0A2A0A54     8       DW  2602, 2644, 2685, 2727, 2768, 2810, 2851, 2893, 2934, 2976, 3017, 3059, 3100, 3142, 3184, 3225
     0A7D0AA7
     0AD00AFA
     0B230B4D
     0B760BA0
     0BC90BF3
     0C1C0C46
     0C700C99
30A0 0CC30CEC     9       DW  3267, 3308, 3350, 3391, 3433, 3474, 3516, 3557, 3599, 3640, 3682, 3723, 3765, 3806, 3848, 3889 
     0D160D3F
     0D690D92
     0DBC0DE5
     0E0F0E38
     0E620E8B
     0EB50EDE
     0F080F31
30C0 0F5B0F84    10       DW  3931, 3972, 4013, 4055, 4096, 4138, 4179, 4220, 4262, 4303, 4344, 4385, 4427, 4468, 4509, 4550 
     0FAD0FD7
     1000102A
     1053107C
     10A610CF
     10F81121
     114B1174
     119D11C6
30E0 11EF1219    11       DW  4591, 4633, 4674, 4715, 4756, 4797, 4838, 4879, 4920, 4961, 5002, 5043, 5084, 5124, 5165, 5206
     1242126B
     129412BD
     12E6130F
     13381361
     138A13B3
     13DC1404
     142D1456
3100 147F14A8    12       DW  5247, 5288, 5328, 5369, 5410, 5450, 5491, 5532, 5572, 5613, 5653, 5694, 5735, 5775, 5815, 5856
     14D014F9
     1522154A
     1573159C
     15C415ED
     1615163E
     1667168F
     16B716E0
3120 17081731    13       DW  5896, 5937, 5977, 6017, 6058, 6098, 6138, 6179, 6219, 6259, 6299, 6339, 6380, 6420, 6460, 6500
     17591781
     17AA17D2
     17FA1823
     184B1873
     189B18C3
     18EC1914
     193C1964
3140 198C19B4    14       DW  6540, 6580, 6620, 6660, 6701, 6741, 6781, 6821, 6861, 6901, 6941, 6981, 7021, 7060, 7100, 7140
     19DC1A04
     1A2D1A55
     1A7D1AA5
     1ACD1AF5
     1B1D1B45
     1B6D1B94
     1BBC1BE4
3160 1C0C1C34    15       DW  7180, 7220, 7260, 7300, 7340, 7380, 7420, 7460, 7500, 7540, 7579, 7619, 7659, 7699, 7739, 7779
     1C5C1C84
     1CAC1CD4
     1CFC1D24
     1D4C1D74
     1D9B1DC3
     1DEB1E13
     1E3B1E63
3180 1E8B1EB3    16       DW  7819, 7859, 7899, 7939, 7979, 8019, 8059, 8099, 8138, 8178, 8218, 8258, 8298, 8338, 8378, 8418
     1EDB1F03
     1F2B1F53
     1F7B1FA3
     1FCA1FF2
     201A2042
     206A2092
     20BA20E2
31A0 210A2133    17       DW  8458, 8499, 8539, 8579, 8619, 8659, 8699, 8739, 8779, 8819, 8860, 8900, 8940, 8980, 9020, 9061
     215B2183
     21AB21D3
     21FB2223
     224B2273
     229C22C4
     22EC2314
     233C2365
31C0 238D23B5    18       DW  9101, 9141, 9181, 9222, 9262, 9302, 9343, 9383, 9423, 9464, 9504, 9545, 9585, 9626, 9666, 9707
     23DD2406
     242E2456
     247F24A7
     24CF24F8
     25202549
     2571259A
     25C225EB
31E0 2613263C    19       DW  9747, 9788, 9828, 9869, 9909, 9950, 9991, 10031, 10072, 10113, 10153, 10194, 10235, 10276, 10316, 10357 
     2664268D
     26B526DE
     2707272F
     27582781
     27A927D2
     27FB2824
     284C2875
3200 289E28C7    20       DW  10398, 10439, 10480, 10520, 10561, 10602, 10643, 10684, 10725, 10766, 10807, 10848, 10889, 10930, 10971, 11012 
     28F02918
     2941296A
     299329BC
     29E52A0E
     2A372A60
     2A892AB2
     2ADB2B04
3220 2B2D2B56    21       DW  11053, 11094, 11135, 11176, 11217, 11259, 11300, 11341, 11382, 11423, 11465, 11506, 11547, 11588, 11630, 11671
     2B7F2BA8
     2BD12BFB
     2C242C4D
     2C762C9F
     2CC92CF2
     2D1B2D44
     2D6E2D97
3240 2DC02DE9    22       DW  11712, 11753, 11795, 11836, 11877, 11919, 11960, 12001, 12043, 12084, 12126, 12167, 12209, 12250, 12291, 12333
     2E132E3C
     2E652E8F
     2EB82EE1
     2F0B2F34
     2F5E2F87
     2FB12FDA
     3003302D
3260 30563080    23       DW  12374, 12416, 12457, 12499, 12540, 12582, 12624
     30A930D3
     30FC3126
     3150
326E             24   
326E             55   ;        $List
326E             56   
326E             57   ; /*** DIRECT ACCESS VARIABLES @RAM 0x30 -> 0x7F ***/
0030             58   DSEG at 30H
0030             59   x:                       ds 4            ; for math
0034             60   y:                       ds 4
0038             61   data_out:        ds 4            ; for python
003C             62   bcd:                     ds 5            ; for display
0041             63   
0041             64   VLED_ADC:                ds 2            ; for temperature 
0043             65   dtemp:                   ds 2
0045             66   tempc:                   ds 1
0046             67   temp_mc:                 ds 4
004A             68   OPAMP_temp:      ds 4
004E             69   temp_lm:                 ds 4
0052             70   temp_offset:     ds 2
0054             71   mV_offset:       ds 2
0056             72   
0056             73   FSM1_state:      ds 1            ; fsm states
0057             74   
0057             75   pwm_counter:     ds 1            ; time check and pwm
0058             76   count10ms:               ds 1
0059             77   seconds:                 ds 1
005A             78   pwm:                     ds 1
005B             79   abort_time:              ds 1
005C             80   
005C             81   ReflowTemp:      ds 1            ; reflow profile parameters
005D             82   ReflowTime:              ds 1
005E             83   SoakTime:                ds 1
005F             84   
005F             85   Val_test:                ds 4
0063             86   Val_temp:                ds 4
0067             87   
0067             88   ; /*** SINGLE BIT VARIABLES @RAM 0x20 -> 0x2F ***/
0000             89   BSEG 
0000             90   mf:                      dbit 1
0001             91   seconds_flag:    dbit 1
0002             92   s_flag:                  dbit 1
0003             93   
0003             94   ; /*** CODE SEGMENT ***/
326E             95   CSEG
326E             96   ;                     1234567890123456    <- This helps determine the location of the counter
326E 2A2A2A2A    97   test_message:     db '****LOADING*****', 0
     4C4F4144
     494E472A
     2A2A2A2A
     00
327F 54454D50    98   value_message:    db 'TEMP:      ', 0
     3A202020
     20202000
328B 43454C43    99   cel_message:       db 'CELCIUS  READING',0
     49555320
     20524541
     44494E47
     00
329C 46415245   100   fah_message:      db 'FARENHET READING',0
     4E484554
     20524541
     44494E47
     00
32AD 41424F52   101   abort_message:     db 'ABORTABORTABORT ', 0
     5441424F
     52544142
     4F525420
     00
32BE 43757272   102   state_message:     db 'Current State:  ', 0
     656E7420
     53746174
     653A2020
     00
32CF            103   
33C4            122   $LIST
                546   $LIST
37A4            141   $LIST
                108   $LIST
37A4            110   
37A4            111   
37A4            112   InitAll:
37A4            113            ; /*** SERIAL PORT INITIALIZATION ***/
37A4 75AC00     114            mov     P3M1,#0x00                      ; Configure all the pins for biderectional I/O
37A7 75AD00     115            mov     P3M2,#0x00
37AA 75B300     116            mov     P1M1,#0x00
37AD 75B400     117            mov     P1M2,#0x00
37B0 75B100     118            mov     P0M1,#0x00
37B3 75B200     119            mov     P0M2,#0x00
37B6            120       ; Since the reset button bounces, we need to wait a bit before
37B6            121       ; sending messages, otherwise we risk displaying gibberish!
37B6            122       ;mov R1, #200
37B6            123       ;mov R0, #104
37B6            124       ;djnz R0, $                                  ; 4 cycles->4*60.285ns*104=25us
37B6            125       ;djnz R1, $-4                                ; 25us*200=5.0ms
37B6 7A05       126       mov R2, #5
37B8 12390E     127       lcall waitms
37BB            128       ; Now we can proceed with the configuration of the serial port
37BB 438E10     129            orl     CKCON, #0x10                    ; CLK is the input for timer 1
37BE 438780     130            orl     PCON, #0x80                     ; Bit SMOD=1, double baud rate
37C1 759852     131            mov     SCON, #0x52
37C4 53C4DF     132            anl     T3CON, #0b11011111
37C7 53890F     133            anl     TMOD, #0x0F                             ; Clear the configuration bits for timer 1
37CA 438920     134            orl     TMOD, #0x20                     ; Timer 1 Mode 2
37CD 758DF7     135            mov     TH1, #TIMER1_RELOAD
37D0 D28E       136            setb TR1
37D2            137   
37D2            138            ; /*** INITIALIZE THE REST ***/
37D2 438E10     139            orl     CKCON, #0x10                    ; CLK is the input for timer 1
37D5 438780     140            orl     PCON, #0x80                     ; Bit SMOD=1, double baud rate
37D8 759852     141            mov     SCON, #0x52
37DB 53C4DF     142            anl     T3CON, #0b11011111
37DE 53890F     143            anl     TMOD, #0x0F                     ; Clear the configuration bits for timer 1
37E1 438920     144            orl     TMOD, #0x20                     ; Timer 1 Mode 2
37E4 758DF7     145            mov     TH1, #TIMER1_RELOAD     ; TH1=TIMER1_RELOAD;
37E7 D28E       146            setb TR1
37E9            147            
37E9            148            ; Using timer 0 for delay functions.  Initialize here:
37E9 C28C       149            clr     TR0                                     ; Stop timer 0
37EB 438E08     150            orl     CKCON,#0x08                     ; CLK is the input for timer 0
37EE 5389F0     151            anl     TMOD,#0xF0                              ; Clear the configuration bits for timer 0
37F1 438901     152            orl     TMOD,#0x01                              ; Timer 0 in Mode 1: 16-bit timer
37F4            153            
37F4            154            ; Initialize the pin used by the ADC (P1.1) as input.
37F4 43B302     155            orl     P1M1, #0b00000010
37F7 53B4FD     156            anl     P1M2, #0b11111101
37FA            157            
37FA            158            ; Initialize and start the ADC:
37FA 53E8F0     159            anl ADCCON0, #0xF0
37FD 43E807     160            orl ADCCON0, #0x07                      ; Select channel 7
3800            161            ; AINDIDS select if some pins are analog inputs or digital I/O:
3800 75F600     162            mov AINDIDS, #0x00                      ; Disable all analog inputs
3803 43F640     163            orl AINDIDS, #0b1000000         ; P1.1 is analog input
3806 43E101     164            orl ADCCON1, #0x01                      ; Enable ADC
3809 755200     165            mov temp_offset, #0x00
380C            166   
380C            167   
380C            168   ;----------------------------------------------------------------;
380C            169   ;                                        TIMER 2 INITIALIZATION
380C            170   ;----------------------------------------------------------------;
380C            171   
380C 75C800     172            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
380F 75CDD7     173            mov TH2, #high(TIMER2_RELOAD)
3812 75CC79     174            mov TL2, #low(TIMER2_RELOAD)
3815            175            ; Set the reload value
3815 75C9A0     176            mov T2MOD, #0b1010_0000 ; Enable timer 2 autoreload, and clock divider is 16
3818 75CBD7     177            mov RCMP2H, #high(TIMER2_RELOAD)
381B 75CA79     178            mov RCMP2L, #low(TIMER2_RELOAD)
381E            179            ; Init the free running 10 ms counter to zero
381E 755700     180            mov pwm_counter, #0
3821            181            ; Enable the timer and interrupts
3821 439B80     182            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
3824 D2CA       183       setb TR2  ; Enable timer 2
3826            184   
3826 D2AF       185            setb EA ; Enable global interrupts
3828 22         186       ret
3829            187   
3829            188   
3829            189   ;---------------------------------;
3829            190   ; ISR for Timer 2                 ;
3829            191   ;---------------------------------;
3829            192   Timer2_ISR:
3829 C2CF       193            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
382B C0D0       194            push psw
382D C0E0       195            push acc
382F            196            
382F 0557       197            inc pwm_counter
3831 C3         198            clr c
3832 E55A       199            mov a, pwm
3834 9557       200            subb a, pwm_counter ; If pwm_counter <= pwm then c=1
3836 B3         201            cpl c
3837 9290       202            mov PWM_OUT, c
3839            203            
3839 E557       204            mov a, pwm_counter
383B B46432     205            cjne a, #100, Timer2_ISR_done
383E            206            ; executes every second
383E 755700     207            mov pwm_counter, #0
3841 0559       208            inc seconds ; It is super easy to keep a seconds count here
3843 D202       209            setb s_flag
3845 E556       210            mov a, FSM1_state
3847 B40003     211            cjne a, #0, Abort_Check0                        ; For abort check, the abort should not trigger if you are in state 0
384A 023870     212            ljmp Timer2_ISR_done
384D            213   
384D            214   Abort_Check0:
384D            215   ; Check if temperature is above 240. If so, abort
384D C3         216            clr c
384E E545       217            mov a, tempc
3850 94F0       218            subb a, #240                                            ; if a is greater than 240, there will be no carry bit so we need to abort
3852 4006       219            jc Abort_Check1                                                 ; if temperature is below 240, continue to next check
3854            220            ; abort routine
3854 75560A     221            mov FSM1_state, #10
3857 023870     222       ljmp Timer2_ISR_done                ; if temp is above 240, abort condition has already been triggered, skip ahead to done
385A            223   
385A            224   Abort_Check1:
385A            225   ; Check if temperature is below 50. If so, check for how long
385A E545       226            mov a, tempc
385C C3         227            clr c
385D 9432       228            subb a, #50                                                     ; if tempc (stored in a) is less than 50, there will be a carry bit
385F 500C       229            jnc Timer2_ISR_abort_done                       ; skip the abort checks if temperature is above 50
3861            230   
3861            231   Abort_Check2:
3861            232   ; Check if has been 60 seconds (at below 50 degrees)
3861 055B       233            inc abort_time
3863 E55B       234            mov a, abort_time
3865 C3         235            clr c
3866 943C       236            subb a, #60                                                     ; if abort_time is less than 60, there will be a carry bit
3868 5006       237            jnc Timer2_ISR_done                                     ; if there is a carry 
386A 75560A     238            mov FSM1_state, #10
386D            239   
386D            240   Timer2_ISR_abort_done:
386D 755B00     241            mov abort_time, #0
3870            242   
3870            243   Timer2_ISR_done:
3870 D0E0       244            pop acc
3872 D0D0       245            pop psw
3874 32         246            reti
3875            247   
3875            248   line1:
3875 50574D20   249            DB 'PWM Example     '
     4578616D
     706C6520
     20202020
3885 00         250            DB 0
3886            251   line2:
3886 43686B20   252            DB 'Chk pin 15:P1.0 '
     70696E20
     31353A50
     312E3020
3896 00         253            DB 0
3897            254   
3897            255   ; /* Send a character using the serial port */
3897            256   putchar:
3897 3099FD     257       jnb TI, putchar
389A C299       258       clr TI
389C F599       259       mov SBUF, a
389E 22         260       ret
389F            261   
389F            262   ; Send a constant-zero-terminated string using the serial port
389F            263   SendString:
389F E4         264       clr A
38A0 93         265       movc A, @A+DPTR
38A1 6006       266       jz SendStringDone
38A3 123897     267       lcall putchar
38A6 A3         268       inc DPTR
38A7 80F6       269       sjmp SendString
38A9            270   SendStringDone:
38A9 22         271       ret
38AA            272   
38AA            273   ; Sends binary data to Python via putchar
38AA            274   SendBin:                                         
38AA E4         275            clr A                                   ; Sends temp_mc
38AB E546       276            mov a, temp_mc+0
38AD 123897     277            lcall putchar
38B0 E4         278            clr A
38B1 E547       279            mov a, temp_mc+1
38B3 123897     280            lcall putchar
38B6 E4         281            clr A
38B7 E548       282            mov a, temp_mc+2
38B9 123897     283            lcall putchar
38BC E4         284            clr A
38BD E549       285            mov a, temp_mc+3
38BF 123897     286            lcall putchar
38C2            287   
38C2 E4         288            clr A                                   ; Sends data_out
38C3 E538       289            mov a, data_out+0
38C5 123897     290            lcall putchar
38C8 E4         291            clr A
38C9 E539       292            mov a, data_out+1
38CB 123897     293            lcall putchar
38CE E4         294            clr A                                   ; Sends data_out
38CF E53A       295            mov a, data_out+2
38D1 123897     296            lcall putchar
38D4 E4         297            clr A
38D5 E53B       298            mov a, data_out+3
38D7 123897     299            lcall putchar
38DA 22         300            ret
38DB            301   
38DB            302   ASCII_CHAR: 
38DB 30313233   303            db '0123456789ABCDEF'
     34353637
     38394142
     43444546
38EB            304   
38EB            305   Hello_World:
38EB 48656C6C   306       DB  'Hello, World!', '\r', '\n', 0
     6F2C2057
     6F726C64
     210D0A00
38FB            307   New_Line:
38FB 0D0A00     308            DB '\r', '\n', 0
38FE            309   
38FE            310   ; /* 1ms DELAY FUNCTIONS */
38FE            311   wait_1ms:
38FE C28C       312            clr     TR0 ; Stop timer 0
3900 C28D       313            clr     TF0 ; Clear overflow flag
3902 758CBF     314            mov     TH0, #high(TIMER0_RELOAD_1MS)
3905 758A28     315            mov     TL0,#low(TIMER0_RELOAD_1MS)
3908 D28C       316            setb TR0
390A 308DFD     317            jnb     TF0, $ ; Wait for overflow
390D 22         318            ret
390E            319   waitms:
390E 1238FE     320            lcall wait_1ms
3911 DAFB       321            djnz R2, waitms
3913 22         322            ret
3914            323   
3914            324   Display_formated_BCD: ;4 dig 
3914 C0E0       325            push acc
3916 7401       325            mov a, #1
3918 14         325            dec a
3919 123368     325            lcall ?Set_Cursor_1 ; Select column and row
391C D0E0       325            pop acc
391E C083       326            push dph
3920 C082       326            push dpl
3922 C0E0       326            push acc
3924 90328B     326            mov dptr, #cel_message
3927 12335B     326            lcall ?Send_Constant_String
392A D0E0       326            pop acc
392C D082       326            pop dpl
392E D083       326            pop dph
3930 C0E0       327            push acc
3932 7407       327            mov a, #7
3934 14         327            dec a
3935 123366     327            lcall ?Set_Cursor_2 ; Select column and row
3938 D0E0       327            pop acc
393A            327   
393A C000       328            push ar0
393C A83E       328            mov r0, bcd+2
393E 12336D     328            lcall ?Display_BCD
3941 D000       328            pop ar0
3943 C0E0       329            push acc
3945 7409       329            mov a, #9
3947 14         329            dec a
3948 123366     329            lcall ?Set_Cursor_2 ; Select column and row
394B D0E0       329            pop acc
394D C000       330            push ar0
394F A83D       330            mov r0, bcd+1
3951 12336D     330            lcall ?Display_BCD
3954 D000       330            pop ar0
3956 C0E0       331            push acc
3958 740A       331            mov a, #10
395A 14         331            dec a
395B 123366     331            lcall ?Set_Cursor_2 ; Select column and row
395E D0E0       331            pop acc
3960 C000       332            push ar0
3962 A83D       332            mov r0, bcd+1
3964 12336D     332            lcall ?Display_BCD
3967 D000       332            pop ar0
3969            333            
3969 C0E0       334            push acc
396B 740C       334            mov a, #12
396D 14         334            dec a
396E 123366     334            lcall ?Set_Cursor_2 ; Select column and row
3971 D0E0       334            pop acc
3973 C000       335            push ar0
3975 A83C       335            mov r0, bcd+0
3977 12336D     335            lcall ?Display_BCD
397A D000       335            pop ar0
397C C0E0       336            push acc
397E 740A       336            mov a, #10
3980 14         336            dec a
3981 123366     336            lcall ?Set_Cursor_2 ; Select column and row
3984 D0E0       336            pop acc
3986 C0E0       337            push acc
3988 742E       337            mov a, #'.'
398A 12331E     337            lcall ?WriteData
398D D0E0       337            pop acc
398F C0E0       338            push acc
3991 7407       338            mov a, #7
3993 14         338            dec a
3994 123366     338            lcall ?Set_Cursor_2 ; Select column and row
3997 D0E0       338            pop acc
3999 C0E0       339            push acc
399B 7420       339            mov a, #0x20
399D 12331E     339            lcall ?WriteData
39A0 D0E0       339            pop acc
39A2 C0E0       340            push acc
39A4 740F       340            mov a, #15
39A6 14         340            dec a
39A7 123366     340            lcall ?Set_Cursor_2 ; Select column and row
39AA D0E0       340            pop acc
39AC C0E0       341            push acc
39AE 74DF       341            mov a, #0xDF
39B0 12331E     341            lcall ?WriteData
39B3 D0E0       341            pop acc
39B5 C0E0       342            push acc
39B7 7410       342            mov a, #16
39B9 14         342            dec a
39BA 123366     342            lcall ?Set_Cursor_2 ; Select column and row
39BD D0E0       342            pop acc
39BF C0E0       343            push acc
39C1 7443       343            mov a, #'C'
39C3 12331E     343            lcall ?WriteData
39C6 D0E0       343            pop acc
39C8 22         344            ret
39C9            345   
39C9            346   
39C9            347   ; /* READ ADC */
39C9            348   Read_ADC:
39C9 C2EF       349            clr ADCF
39CB D2EE       350            setb ADCS ;  ADC start trigger signal
39CD 30EFFD     351       jnb ADCF, $ ; Wait for conversion complete
39D0            352       
39D0            353       ; Read the ADC result and store in [R1, R0]
39D0 E5C2       354       mov a, ADCRL
39D2 540F       355       anl a, #0x0f
39D4 F8         356       mov R0, a
39D5 E5C3       357       mov a, ADCRH   
39D7 C4         358       swap a
39D8 C0E0       359       push acc
39DA 540F       360       anl a, #0x0f
39DC F9         361       mov R1, a
39DD D0E0       362       pop acc
39DF 54F0       363       anl a, #0xf0
39E1 48         364       orl a, R0
39E2 F8         365       mov R0, A
39E3 22         366            ret
39E4            367   
39E4            368   Main:
39E4 75817F     369       mov SP, #0x7F        ; Set the stack pointer to the begining of idata
39E7            370       
39E7 1237A4     371       lcall InitAll
39EA 123328     372       lcall LCD_4BIT
39ED            373   
39ED            374            ; Initialize all variables
39ED D201       375            setb seconds_flag
39EF 755600     376            mov FSM1_state, #0
39F2 755900     377            mov seconds, #0
39F5 755C00     378            mov ReflowTemp, #0
39F8 755D00     379            mov ReflowTime, #0
39FB 755E00     380            mov SoakTime, #0
39FE            381   
39FE            382       ; initial messages in LCD
39FE C0E0       383            push acc
3A00 7401       383            mov a, #1
3A02 14         383            dec a
3A03 123368     383            lcall ?Set_Cursor_1 ; Select column and row
3A06 D0E0       383            pop acc
3A08 C083       384            push dph
3A0A C082       384            push dpl
3A0C C0E0       384            push acc
3A0E 90326E     384            mov dptr, #test_message
3A11 12335B     384            lcall ?Send_Constant_String
3A14 D0E0       384            pop acc
3A16 D082       384            pop dpl
3A18 D083       384            pop dph
3A1A C0E0       385            push acc
3A1C 7401       385            mov a, #1
3A1E 14         385            dec a
3A1F 123366     385            lcall ?Set_Cursor_2 ; Select column and row
3A22 D0E0       385            pop acc
3A24 C083       386            push dph
3A26 C082       386            push dpl
3A28 C0E0       386            push acc
3A2A 90327F     386            mov dptr, #value_message
3A2D 12335B     386            lcall ?Send_Constant_String
3A30 D0E0       386            pop acc
3A32 D082       386            pop dpl
3A34 D083       386            pop dph
3A36            387   
3A36            388            ;mov data_out, #0b00000001
3A36            389   
3A36            390   ;Forever: ;avaliable: r2, r3
3A36            391   FSM_sys:
3A36            392   ; /* TEMP_READ: READS TEMPERATURE */
3A36            393   ; Note:     Before converting to be stored tempC, 
3A36            394   ;           all values are stored as 32 bit numbers 
3A36            395   ;           with 3 decimal points. (in milli-celcius)
3A36            396   ;           
3A36            397   ; Example:  2.07 V would be represented by the number
3A36            398   ;           20700. (The real value * 1000).
3A36            399   TEMP_READ:
3A36 023A69     400            ljmp read_led
3A39            401   
3A39            402   Avg_ADC:                                                 ; function for ADC noise reduction
3A39 753000     403            mov x+0, #low (0 % 0x10000) 
3A3C 753100     403            mov x+1, #high(0 % 0x10000) 
3A3F 753200     403            mov x+2, #low (0 / 0x10000) 
3A42 753300     403            mov x+3, #high(0 / 0x10000) 
3A45 7DFF       404       mov R5, #255
3A47            405   sum_loop_avg:
3A47 1239C9     406       lcall Read_ADC
3A4A 753700     407       mov y+3, #0
3A4D 753600     408       mov y+2, #0
3A50 8935       409       mov y+1, R1
3A52 8834       410       mov y+0, R0
3A54 123489     411       lcall add32
3A57 DDEE       412       djnz R5, sum_loop_avg
3A59 7534FF     413            mov y+0, #low (255 % 0x10000) 
3A5C 753500     413            mov y+1, #high(255 % 0x10000) 
3A5F 753600     413            mov y+2, #low (255 / 0x10000) 
3A62 753700     413            mov y+3, #high(255 / 0x10000) 
3A65 1235CB     414       lcall div32
3A68 22         415       ret
3A69            416   
3A69            417   read_led:
3A69 53E8F0     418       anl ADCCON0, #0xf0          ; read led voltage
3A6C 43E800     419       orl ADCCON0, #LED_PORT
3A6F 123A39     420       lcall Avg_ADC
3A72 8841       421       mov VLED_ADC+0, R0          ; save reading to VLED_ADC
3A74 8942       422            mov VLED_ADC+1, R1
3A76            423   
3A76            424   read_lm335:
3A76 53E8F0     425       anl ADCCON0, #0xf0          ; *** LM335 ***
3A79 43E805     426       orl ADCCON0, #LM335_PORT
3A7C 123A39     427       lcall Avg_ADC
3A7F 8830       428       mov x+0, R0                              ; load lm335 reading to x
3A81 8931       429            mov x+1, R1
3A83 753200     430            mov x+2, #0                     
3A86 753300     431            mov x+3, #0
3A89 7534A0     432            mov y+0, #low (260000 % 0x10000) 
3A8C 7535F7     432            mov y+1, #high(260000 % 0x10000) 
3A8F 753603     432            mov y+2, #low (260000 / 0x10000) 
3A92 753700     432            mov y+3, #high(260000 / 0x10000)               ; load const vled ref into y      
3A95 12353E     433       lcall mul32
3A98 854134     434       mov y+0, VLED_ADC+0              ; import vled reading into y
3A9B 854235     435            mov y+1, VLED_ADC+1         
3A9E 753600     436            mov y+2, #0                     
3AA1 753700     437            mov y+3, #0
3AA4 1235CB     438       lcall div32
3AA7 753468     439            mov y+0, #low (273000 % 0x10000) 
3AAA 75352A     439            mov y+1, #high(273000 % 0x10000) 
3AAD 753604     439            mov y+2, #low (273000 / 0x10000) 
3AB0 753700     439            mov y+3, #high(273000 / 0x10000)                            ; adjust to 273.000 C offset
3AB3 1234AA     440            lcall sub32                     ; result of lm335 temp remains in x
3AB6 85304E     441            mov temp_lm+0, x+0          ; store 3 decimal lm335 value for later
3AB9 85314F     442       mov temp_lm+1, x+1                           
3ABC 853250     443       mov temp_lm+2, x+2
3ABF 853351     444       mov temp_lm+3, x+3
3AC2            445   
3AC2            446   read_opamp:
3AC2 53E8F0     447            anl ADCCON0, #0xf0          ; *** OPAMP ***
3AC5 43E807     448       orl ADCCON0, #OPAMP_PORT     ; 
3AC8 123A39     449            lcall Avg_ADC
3ACB 8830       450            mov x+0, R0                         ; load opamp reading to x
3ACD 8931       451            mov x+1, R1
3ACF 753200     452            mov x+2, #0                     
3AD2 753300     453            mov x+3, #0
3AD5 8838       454            mov data_out+0, R0                      
3AD7 8939       455            mov data_out+1, R1
3AD9 753A00     456            mov data_out+2, #0
3ADC 753B00     457            mov data_out+3, #0
3ADF            458            
3ADF 753428     459            mov y+0, #low (2600 % 0x10000) 
3AE2 75350A     459            mov y+1, #high(2600 % 0x10000) 
3AE5 753600     459            mov y+2, #low (2600 / 0x10000) 
3AE8 753700     459            mov y+3, #high(2600 / 0x10000)                 ; load const vled ref (2070 mV) into y      
3AEB 12353E     460       lcall mul32
3AEE 854134     461       mov y+0, VLED_ADC+0              ; import led adc reading into y
3AF1 854235     462            mov y+1, VLED_ADC+1                
3AF4 753600     463            mov y+2, #0                     
3AF7 753700     464            mov y+3, #0
3AFA 1235CB     465       lcall div32                 ; x value now stores OPAMP V in mV
3AFD            466   
3AFD            467            ; mov data_out+0, x+0                   
3AFD            468            ; mov data_out+1, x+1
3AFD            469            ; mov data_out+2, x+2
3AFD            470            ; mov data_out+3, x+3
3AFD            471   
3AFD            472   
3AFD            473   
3AFD 7534E8     474            mov y+0, #low (1000 % 0x10000) 
3B00 753503     474            mov y+1, #high(1000 % 0x10000) 
3B03 753600     474            mov y+2, #low (1000 / 0x10000) 
3B06 753700     474            mov y+3, #high(1000 / 0x10000)                                  
3B09 12353E     475            lcall mul32                                     ; turn mV to uV
3B0C 75341B     476            mov y+0, #low (V2C_DIVISOR % 0x10000) 
3B0F 753504     476            mov y+1, #high(V2C_DIVISOR % 0x10000) 
3B12 753600     476            mov y+2, #low (V2C_DIVISOR / 0x10000) 
3B15 753700     476            mov y+3, #high(V2C_DIVISOR / 0x10000) 
3B18            477            
3B18 1235CB     478            lcall div32                                     ; deg C reading now in x
3B1B            479   
3B1B            480            ; mov data_out+0, x+0                   
3B1B            481            ; mov data_out+1, x+1
3B1B            482            ; mov data_out+2, x+2
3B1B            483            ; mov data_out+3, x+3
3B1B            484            ; mov temp_offset+0, x+0                ; use for reverse checking
3B1B            485            ; mov temp_offset+1, x+1        
3B1B            486            
3B1B            487            ; Load_y(1000)
3B1B            488            ; lcall mul32                                   ; conv to mV again to add to lm335 data
3B1B            489   
3B1B            490   ; add_lm335_to_opamp:
3B1B            491   ;     mov y+0, temp_lm+0         ; load lm335 temp to y
3B1B            492   ;     mov y+1, temp_lm+1
3B1B            493   ;     mov y+2, temp_lm+2
3B1B            494   ;     mov y+3, temp_lm+3
3B1B            495   ;     lcall add32                        ; lm335 + opamp = real temp
3B1B 853046     496        mov temp_mc+0, x+0          ; store result in temp_mc (for python)
3B1E 853147     497        mov temp_mc+1, x+1                          
3B21 853248     498        mov temp_mc+2, x+2
3B24 853349     499        mov temp_mc+3, x+3
3B27            500   
3B27            501   export_to_bcd:
3B27            502            ; lcall hex2bcd                                 ; Convert val stored in x to BCD in "bcd"
3B27            503            ; lcall Display_formated_BCD
3B27 1236FD     504            lcall Display_x         
3B2A            505            
3B2A            506   export_to_main:
3B2A 854630     507            mov x+0, temp_mc+0          
3B2D 854731     508       mov x+1, temp_mc+1
3B30 854832     509       mov x+2, temp_mc+2
3B33 854933     510       mov x+3, temp_mc+3
3B36 7534E8     511            mov y+0, #low (1000 % 0x10000) 
3B39 753503     511            mov y+1, #high(1000 % 0x10000) 
3B3C 753600     511            mov y+2, #low (1000 / 0x10000) 
3B3F 753700     511            mov y+3, #high(1000 / 0x10000) 
3B42 1235CB     512       lcall div32
3B45 853045     513       mov tempc, x+0              ; Both tempc and x now stores temp (C)           
3B48            514   
3B48            515   Export:                                                  ; Data export to python
3B48 7AFA       516            mov R2, #250                            ; Wait 500 ms between conversions
3B4A 12390E     517            lcall waitms
3B4D 7AFA       518            mov R2, #250
3B4F 12390E     519            lcall waitms                            ; Sends binary contents of 
3B52            520   
3B52 1238AA     521       lcall SendBin                                ; temp_mc and data_out to python
3B55            522   
3B55            523            ; /* FSM1 STATE CHANGE CONTROLS */
3B55 023B58     524            ljmp FSM1
3B58            525   
3B58            526   ; REQUIREMENTS
3B58            527   ; Start/Stop button, to do this, make routine which displays "stopped" for a little bit
3B58            528   ; Temperature display, implemented already
3B58            529   ; Running time display, implement in main
3B58            530   ; 
3B58            531   
3B58            532   
3B58            533   FSM1:
3B58 E556       534            mov a, FSM1_state
3B5A C0E0       535            push acc
3B5C 7401       535            mov a, #1
3B5E 14         535            dec a
3B5F 123368     535            lcall ?Set_Cursor_1 ; Select column and row
3B62 D0E0       535            pop acc
3B64 C083       536            push dph
3B66 C082       536            push dpl
3B68 C0E0       536            push acc
3B6A 9032BE     536            mov dptr, #state_message
3B6D 12335B     536            lcall ?Send_Constant_String
3B70 D0E0       536            pop acc
3B72 D082       536            pop dpl
3B74 D083       536            pop dph
3B76            537   
3B76            538   FSM1_state0:
3B76 B40024     539            cjne a, #0, FSM1_state1 ; if FSM1_state (currently stored in a) is not equal to zero (ie. state zero), go to state 1
3B79 755A00     540            mov pwm, #0
3B7C C0E0       541            push acc
3B7E 740E       541            mov a, #14
3B80 14         541            dec a
3B81 123368     541            lcall ?Set_Cursor_1 ; Select column and row
3B84 D0E0       541            pop acc
3B86 C000       542            push ar0
3B88 7800       542            mov r0, #0x00
3B8A 12336D     542            lcall ?Display_BCD
3B8D D000       542            pop ar0
3B8F C201       543            clr seconds_flag
3B91            544            ; check for push button input
3B91 208406     545            jb START_BUTTON, FSM1_state0_done
3B94 3084FD     546            jnb START_BUTTON, $ ; Wait for key release
3B97 755601     547            mov FSM1_state, #1
3B9A            548   
3B9A            549   FSM1_state0_done:
3B9A 023A36     550            ljmp FSM_sys
3B9D            551   
3B9D            552   FSM1_state1:
3B9D B40126     553            cjne a, #1, FSM1_state2
3BA0 755A64     554            mov pwm, #100
3BA3 C0E0       555            push acc
3BA5 740E       555            mov a, #14
3BA7 14         555            dec a
3BA8 123368     555            lcall ?Set_Cursor_1 ; Select column and row
3BAB D0E0       555            pop acc
3BAD C000       556            push ar0
3BAF 7801       556            mov r0, #0x01
3BB1 12336D     556            lcall ?Display_BCD
3BB4 D000       556            pop ar0
3BB6 755900     557            mov seconds, #0
3BB9 7496       558            mov a, #150
3BBB C3         559            clr c
3BBC 9545       560            subb a, tempc
3BBE 5003       561            jnc FSM1_state1_done
3BC0 755602     562            mov FSM1_state, #2
3BC3            563   
3BC3            564   FSM1_state1_done:
3BC3 023A36     565            ljmp FSM_sys
3BC6            566   
3BC6            567   FSM1_state2:
3BC6 B4022E     568            cjne a, #2, FSM1_state3
3BC9 755A14     569            mov pwm, #20
3BCC C0E0       570            push acc
3BCE 740E       570            mov a, #14
3BD0 14         570            dec a
3BD1 123368     570            lcall ?Set_Cursor_1 ; Select column and row
3BD4 D0E0       570            pop acc
3BD6 C000       571            push ar0
3BD8 7802       571            mov r0, #0x02
3BDA 12336D     571            lcall ?Display_BCD
3BDD D000       571            pop ar0
3BDF 30010A     572            jnb seconds_flag, FSM_state2_funk
3BE2            573            ;mov a, #60
3BE2 E55E       574            mov a, SoakTime
3BE4 C3         575            clr c
3BE5 9559       576            subb a, seconds                 ; Want time to be greater than 60 seconds
3BE7 400B       577            jc FSM1_state2_done
3BE9 755603     578            mov FSM1_state, #3
3BEC            579   
3BEC            580   FSM_state2_funk:
3BEC 755900     581            mov seconds, #0         ; Set seconds so we can count up to the required time 
3BEF D201       582            setb seconds_flag       ; seconds flag so we don't reset seconds_flag multiple times
3BF1 023BC6     583            ljmp FSM1_state2        
3BF4            584   
3BF4            585   FSM1_state2_done:
3BF4 023A36     586            ljmp FSM_sys
3BF7            587   
3BF7            588   FSM1_state3:
3BF7 B40325     589            cjne a, #3, FSM1_state4
3BFA 755A64     590            mov pwm, #100
3BFD C0E0       591            push acc
3BFF 740E       591            mov a, #14
3C01 14         591            dec a
3C02 123368     591            lcall ?Set_Cursor_1 ; Select column and row
3C05 D0E0       591            pop acc
3C07 C000       592            push ar0
3C09 7803       592            mov r0, #0x03
3C0B 12336D     592            lcall ?Display_BCD
3C0E D000       592            pop ar0
3C10            593            ;mov a, #220
3C10 E55C       594            mov a, ReflowTemp
3C12 C201       595            clr seconds_flag
3C14 C3         596            clr c
3C15 9545       597            subb a, tempc
3C17 5003       598            jnc FSM1_state3_done
3C19 755604     599            mov FSM1_state, #4
3C1C            600   
3C1C            601   FSM1_state3_done:
3C1C 023A36     602            ljmp FSM_sys
3C1F            603   
3C1F            604   FSM1_state4:
3C1F B4042E     605            cjne a, #4, FSM1_state5
3C22 755A14     606            mov pwm, #20 
3C25 C0E0       607            push acc
3C27 740E       607            mov a, #14
3C29 14         607            dec a
3C2A 123368     607            lcall ?Set_Cursor_1 ; Select column and row
3C2D D0E0       607            pop acc
3C2F C000       608            push ar0
3C31 7804       608            mov r0, #0x04
3C33 12336D     608            lcall ?Display_BCD
3C36 D000       608            pop ar0
3C38 30010A     609            jnb seconds_flag, FSM1_state4_funk
3C3B            610            ;mov a, #45
3C3B E55D       611            mov a, ReflowTime
3C3D C3         612            clr c 
3C3E 9559       613            subb a, seconds ; when seconds is greater than 45, there will be a carry bit
3C40 400B       614            jc FSM1_state4_done
3C42 755605     615            mov FSM1_state, #5
3C45            616   
3C45            617   FSM1_state4_funk:
3C45 755900     618            mov seconds, #0
3C48 D201       619            setb seconds_flag
3C4A 023C1F     620            ljmp FSM1_state4
3C4D            621   
3C4D            622   FSM1_state4_done:
3C4D 023A36     623            ljmp FSM_sys
3C50            624   
3C50            625   FSM1_state5:
3C50 B40523     626            cjne a, #5, FSM1_abort_state            ; if the state is not in 0-5, then it must be 10 (aka the abort state)
3C53 755A00     627            mov pwm, #0
3C56 C0E0       628            push acc
3C58 740E       628            mov a, #14
3C5A 14         628            dec a
3C5B 123368     628            lcall ?Set_Cursor_1 ; Select column and row
3C5E D0E0       628            pop acc
3C60 C000       629            push ar0
3C62 7804       629            mov r0, #0x04
3C64 12336D     629            lcall ?Display_BCD
3C67 D000       629            pop ar0
3C69 743C       630            mov a, #60
3C6B C3         631            clr c
3C6C 9545       632            subb a, tempc
3C6E 4003       633            jc FSM1_state5_done
3C70 755600     634            mov FSM1_state, #0
3C73            635   
3C73            636   FSM1_state5_done:
3C73 023A36     637            ljmp FSM_sys
3C76            638   
3C76            639   FSM1_abort_state:                                                ; When the abort state is triggered, turn everything off and remain in this state utill you reset
3C76 755A00     640            mov pwm, #0
3C79 C0E0       641            push acc
3C7B 7401       641            mov a, #1
3C7D 14         641            dec a
3C7E 123368     641            lcall ?Set_Cursor_1 ; Select column and row
3C81 D0E0       641            pop acc
3C83 C083       642            push dph
3C85 C082       642            push dpl
3C87 C0E0       642            push acc
3C89 9032AD     642            mov dptr, #abort_message
3C8C 12335B     642            lcall ?Send_Constant_String
3C8F D0E0       642            pop acc
3C91 D082       642            pop dpl
3C93 D083       642            pop dph
3C95            643   
3C95 023C76     644            ljmp FSM1_abort_state
3C98            645   
3C98            646   END
