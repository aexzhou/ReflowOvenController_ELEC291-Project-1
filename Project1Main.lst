                  2   $LIST
0000              4   
0000              5   ;  N76E003 pinout:
0000              6   ;                               -------
0000              7   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000              8   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000              9   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             10   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             11   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             12   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             13   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             14   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             15   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             16   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             17   ;                               -------
0000             18   ;
0000             19   
0000             20   CLK                 EQU 16600000                                                 ; Microcontroller system frequency in Hz
0000             21   BAUD                EQU 115200                                                   ; Baud rate of UART in bps
0000             22   TIMER1_RELOAD       EQU (0x100-(CLK/(16*BAUD)))
0000             23   TIMER0_RELOAD_1MS   EQU (0x10000-(CLK/1000))
0000             24   TIMER2_RATE              EQU 100                                                         ; 1/100 = 10ms
0000             25   TIMER2_RELOAD            EQU (65536-(CLK/(16*TIMER2_RATE)))
0000             26   GAIN                             EQU 25
0000             27   ;V2C_DIVISOR                     EQU (GAIN*41)
0000             28   V2C_DIVISOR                      EQU 1051
0000             29   
0000             30   ; /*** PORT DEFINITIONS ***/
0000             31   LCD_RS                   equ P1.3
0000             32   LCD_E                    equ P1.4
0000             33   LCD_D4                   equ P0.0
0000             34   LCD_D5                   equ P0.1
0000             35   LCD_D6                   equ P0.2
0000             36   LCD_D7                   equ P0.3
0000             37   PWM_OUT                  equ P1.0
0000             38   START_BUTTON     equ P0.4
0000             39   ; Analog Input Port Numbering
0000             40   LED_PORT                 equ 0x00                        ; AIN port numbers
0000             41   LM335_PORT               equ 0x05
0000             42   OPAMP_PORT               equ 0x07
0000             43   AINCONFIG                equ 0b10100001          ; bits 1 = toggled analog in
0000             44   
0000             45   ; /*** VECTORS ***/
0000             46   org 0000H
0000 023A98      47            ljmp Main
0003             48   
002B             49   org 002BH                                        ; timer 2 enable
002B 02383F      50            ljmp Timer2_ISR
002E             51   
3000             52   org 3000H                                        ; lookup table stored at APROM address starting 0x4000
3000             53   ;        $NOLIST
                 -1    	$include(thermodata.inc)
3000              1   ; Contains mV offset for Thermocouple
3000              2   ; Stored in APROM location: 0x3000
3000              3   thermodata:
3000 00000027     4       DW  0, 39, 79, 119, 158, 198, 238, 277, 317, 357, 397, 437, 477, 517, 557, 597 
     004F0077
     009E00C6
     00EE0115
     013D0165
     018D01B5
     01DD0205
     022D0255
3020 027D02A5     5       DW  637, 677, 718, 758, 798, 838, 879, 919, 960, 1000, 1041, 1081, 1122, 1163, 1203, 1244
     02CE02F6
     031E0346
     036F0397
     03C003E8
     04110439
     0462048B
     04B304DC
3040 0505052E     6       DW  1285, 1326, 1366, 1407, 1448, 1489, 1530, 1571, 1612, 1653, 1694, 1735, 1776, 1817, 1858, 1899
     0556057F
     05A805D1
     05FA0623
     064C0675
     069E06C7
     06F00719
     0742076B
3060 079507BE     7       DW  1941, 1982, 2023, 2064, 2106, 2147, 2188, 2230, 2271, 2312, 2354, 2395, 2436, 2478, 2519, 2561 
     07E70810
     083A0863
     088C08B6
     08DF0908
     0932095B
     098409AE
     09D70A01
3080 0A2A0A54     8       DW  2602, 2644, 2685, 2727, 2768, 2810, 2851, 2893, 2934, 2976, 3017, 3059, 3100, 3142, 3184, 3225
     0A7D0AA7
     0AD00AFA
     0B230B4D
     0B760BA0
     0BC90BF3
     0C1C0C46
     0C700C99
30A0 0CC30CEC     9       DW  3267, 3308, 3350, 3391, 3433, 3474, 3516, 3557, 3599, 3640, 3682, 3723, 3765, 3806, 3848, 3889 
     0D160D3F
     0D690D92
     0DBC0DE5
     0E0F0E38
     0E620E8B
     0EB50EDE
     0F080F31
30C0 0F5B0F84    10       DW  3931, 3972, 4013, 4055, 4096, 4138, 4179, 4220, 4262, 4303, 4344, 4385, 4427, 4468, 4509, 4550 
     0FAD0FD7
     1000102A
     1053107C
     10A610CF
     10F81121
     114B1174
     119D11C6
30E0 11EF1219    11       DW  4591, 4633, 4674, 4715, 4756, 4797, 4838, 4879, 4920, 4961, 5002, 5043, 5084, 5124, 5165, 5206
     1242126B
     129412BD
     12E6130F
     13381361
     138A13B3
     13DC1404
     142D1456
3100 147F14A8    12       DW  5247, 5288, 5328, 5369, 5410, 5450, 5491, 5532, 5572, 5613, 5653, 5694, 5735, 5775, 5815, 5856
     14D014F9
     1522154A
     1573159C
     15C415ED
     1615163E
     1667168F
     16B716E0
3120 17081731    13       DW  5896, 5937, 5977, 6017, 6058, 6098, 6138, 6179, 6219, 6259, 6299, 6339, 6380, 6420, 6460, 6500
     17591781
     17AA17D2
     17FA1823
     184B1873
     189B18C3
     18EC1914
     193C1964
3140 198C19B4    14       DW  6540, 6580, 6620, 6660, 6701, 6741, 6781, 6821, 6861, 6901, 6941, 6981, 7021, 7060, 7100, 7140
     19DC1A04
     1A2D1A55
     1A7D1AA5
     1ACD1AF5
     1B1D1B45
     1B6D1B94
     1BBC1BE4
3160 1C0C1C34    15       DW  7180, 7220, 7260, 7300, 7340, 7380, 7420, 7460, 7500, 7540, 7579, 7619, 7659, 7699, 7739, 7779
     1C5C1C84
     1CAC1CD4
     1CFC1D24
     1D4C1D74
     1D9B1DC3
     1DEB1E13
     1E3B1E63
3180 1E8B1EB3    16       DW  7819, 7859, 7899, 7939, 7979, 8019, 8059, 8099, 8138, 8178, 8218, 8258, 8298, 8338, 8378, 8418
     1EDB1F03
     1F2B1F53
     1F7B1FA3
     1FCA1FF2
     201A2042
     206A2092
     20BA20E2
31A0 210A2133    17       DW  8458, 8499, 8539, 8579, 8619, 8659, 8699, 8739, 8779, 8819, 8860, 8900, 8940, 8980, 9020, 9061
     215B2183
     21AB21D3
     21FB2223
     224B2273
     229C22C4
     22EC2314
     233C2365
31C0 238D23B5    18       DW  9101, 9141, 9181, 9222, 9262, 9302, 9343, 9383, 9423, 9464, 9504, 9545, 9585, 9626, 9666, 9707
     23DD2406
     242E2456
     247F24A7
     24CF24F8
     25202549
     2571259A
     25C225EB
31E0 2613263C    19       DW  9747, 9788, 9828, 9869, 9909, 9950, 9991, 10031, 10072, 10113, 10153, 10194, 10235, 10276, 10316, 10357 
     2664268D
     26B526DE
     2707272F
     27582781
     27A927D2
     27FB2824
     284C2875
3200 289E28C7    20       DW  10398, 10439, 10480, 10520, 10561, 10602, 10643, 10684, 10725, 10766, 10807, 10848, 10889, 10930, 10971, 11012 
     28F02918
     2941296A
     299329BC
     29E52A0E
     2A372A60
     2A892AB2
     2ADB2B04
3220 2B2D2B56    21       DW  11053, 11094, 11135, 11176, 11217, 11259, 11300, 11341, 11382, 11423, 11465, 11506, 11547, 11588, 11630, 11671
     2B7F2BA8
     2BD12BFB
     2C242C4D
     2C762C9F
     2CC92CF2
     2D1B2D44
     2D6E2D97
3240 2DC02DE9    22       DW  11712, 11753, 11795, 11836, 11877, 11919, 11960, 12001, 12043, 12084, 12126, 12167, 12209, 12250, 12291, 12333
     2E132E3C
     2E652E8F
     2EB82EE1
     2F0B2F34
     2F5E2F87
     2FB12FDA
     3003302D
3260 30563080    23       DW  12374, 12416, 12457, 12499, 12540, 12582, 12624
     30A930D3
     30FC3126
     3150
326E             24   
326E             55   ;        $List
326E             56   
326E             57   ; /*** DIRECT ACCESS VARIABLES @RAM 0x30 -> 0x7F ***/
0030             58   DSEG at 30H
0030             59   x:                       ds 4            ; for math
0034             60   y:                       ds 4
0038             61   data_out:        ds 4            ; for python
003C             62   bcd:                     ds 5            ; for display
0041             63   
0041             64   VLED_ADC:                ds 2            ; for temperature 
0043             65   dtemp:                   ds 2
0045             66   tempc:                   ds 1
0046             67   temp_mc:                 ds 4
004A             68   OPAMP_temp:      ds 4
004E             69   temp_lm:                 ds 4
0052             70   temp_offset:     ds 2
0054             71   mV_offset:       ds 2
0056             72   
0056             73   FSM1_state:      ds 1            ; fsm states
0057             74   
0057             75   pwm_counter:     ds 1            ; time check and pwm
0058             76   count10ms:               ds 1
0059             77   seconds:                 ds 1
005A             78   pwm:                     ds 1
005B             79   abort_time:              ds 1
005C             80   
005C             81   ReflowTemp:      ds 1            ; reflow profile parameters
005D             82   ReflowTime:              ds 1
005E             83   SoakTime:                ds 1
005F             84   
005F             85   Val_test:                ds 4
0063             86   Val_temp:                ds 4
0067             87   
0067             88   ; /*** SINGLE BIT VARIABLES @RAM 0x20 -> 0x2F ***/
0000             89   BSEG 
0000             90   mf:                      dbit 1
0001             91   seconds_flag:    dbit 1
0002             92   s_flag:                  dbit 1
0003             93   
0003             94   ; /*** CODE SEGMENT ***/
326E             95   CSEG
326E             96   ;                     1234567890123456    <- This helps determine the location of the counter
326E 2A2A2A2A    97   test_message:     db '****LOADING*****', 0
     4C4F4144
     494E472A
     2A2A2A2A
     00
327F 54454D50    98   value_message:    db 'TEMP:           ', 0
     3A202020
     20202020
     20202020
     00
3290 4F56454E    99   temp_message:      db 'OVEN TEMP:      ', 0
     2054454D
     503A2020
     20202020
     00
32A1 46415245   100   fah_message:      db 'FARENHET READING', 0
     4E484554
     20524541
     44494E47
     00
32B2 41424F52   101   abort_message:     db 'ABORTABORTABORT ', 0
     5441424F
     52544142
     4F525420
     00
32C3 43757272   102   state_message:     db 'Current State:  ', 0
     656E7420
     53746174
     653A2020
     00
32D4 53746174   103   error_message:     db 'State Error     ', 0
     65204572
     726F7220
     20202020
     00
32E5            104   
33DA            122   $LIST
                546   $LIST
37BA            141   $LIST
                110   $LIST
37BA            112   
37BA            113   
37BA            114   InitAll:
37BA            115            ; /*** SERIAL PORT INITIALIZATION ***/
37BA 75AC00     116            mov     P3M1,#0x00                      ; Configure all the pins for biderectional I/O
37BD 75AD00     117            mov     P3M2,#0x00
37C0 75B300     118            mov     P1M1,#0x00
37C3 75B400     119            mov     P1M2,#0x00
37C6 75B100     120            mov     P0M1,#0x00
37C9 75B200     121            mov     P0M2,#0x00
37CC            122       ; Since the reset button bounces, we need to wait a bit before
37CC            123       ; sending messages, otherwise we risk displaying gibberish!
37CC            124       ;mov R1, #200
37CC            125       ;mov R0, #104
37CC            126       ;djnz R0, $                                  ; 4 cycles->4*60.285ns*104=25us
37CC            127       ;djnz R1, $-4                                ; 25us*200=5.0ms
37CC 7A05       128       mov R2, #5
37CE 123927     129       lcall waitms
37D1            130       ; Now we can proceed with the configuration of the serial port
37D1 438E10     131            orl     CKCON, #0x10                    ; CLK is the input for timer 1
37D4 438780     132            orl     PCON, #0x80                     ; Bit SMOD=1, double baud rate
37D7 759852     133            mov     SCON, #0x52
37DA 53C4DF     134            anl     T3CON, #0b11011111
37DD 53890F     135            anl     TMOD, #0x0F                             ; Clear the configuration bits for timer 1
37E0 438920     136            orl     TMOD, #0x20                     ; Timer 1 Mode 2
37E3 758DF7     137            mov     TH1, #TIMER1_RELOAD
37E6 D28E       138            setb TR1
37E8            139   
37E8            140            ; /*** INITIALIZE THE REST ***/
37E8 438E10     141            orl     CKCON, #0x10                    ; CLK is the input for timer 1
37EB 438780     142            orl     PCON, #0x80                     ; Bit SMOD=1, double baud rate
37EE 759852     143            mov     SCON, #0x52
37F1 53C4DF     144            anl     T3CON, #0b11011111
37F4 53890F     145            anl     TMOD, #0x0F                     ; Clear the configuration bits for timer 1
37F7 438920     146            orl     TMOD, #0x20                     ; Timer 1 Mode 2
37FA 758DF7     147            mov     TH1, #TIMER1_RELOAD     ; TH1=TIMER1_RELOAD;
37FD D28E       148            setb TR1
37FF            149            
37FF            150            ; Using timer 0 for delay functions.  Initialize here:
37FF C28C       151            clr     TR0                                     ; Stop timer 0
3801 438E08     152            orl     CKCON,#0x08                     ; CLK is the input for timer 0
3804 5389F0     153            anl     TMOD,#0xF0                              ; Clear the configuration bits for timer 0
3807 438901     154            orl     TMOD,#0x01                              ; Timer 0 in Mode 1: 16-bit timer
380A            155            
380A            156            ; Initialize the pin used by the ADC (P1.1) as input.
380A 43B302     157            orl     P1M1, #0b00000010
380D 53B4FD     158            anl     P1M2, #0b11111101
3810            159            
3810            160            ; Initialize and start the ADC:
3810 53E8F0     161            anl ADCCON0, #0xF0
3813 43E807     162            orl ADCCON0, #0x07                      ; Select channel 7
3816            163            ; AINDIDS select if some pins are analog inputs or digital I/O:
3816 75F600     164            mov AINDIDS, #0x00                      ; Disable all analog inputs
3819 43F640     165            orl AINDIDS, #0b1000000         ; P1.1 is analog input
381C 43E101     166            orl ADCCON1, #0x01                      ; Enable ADC
381F 755200     167            mov temp_offset, #0x00
3822            168   
3822            169   
3822            170   ;----------------------------------------------------------------;
3822            171   ;                                        TIMER 2 INITIALIZATION
3822            172   ;----------------------------------------------------------------;
3822            173   
3822 75C800     174            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
3825 75CDD7     175            mov TH2, #high(TIMER2_RELOAD)
3828 75CC79     176            mov TL2, #low(TIMER2_RELOAD)
382B            177            ; Set the reload value
382B 75C9A0     178            mov T2MOD, #0b1010_0000 ; Enable timer 2 autoreload, and clock divider is 16
382E 75CBD7     179            mov RCMP2H, #high(TIMER2_RELOAD)
3831 75CA79     180            mov RCMP2L, #low(TIMER2_RELOAD)
3834            181            ; Init the free running 10 ms counter to zero
3834 755700     182            mov pwm_counter, #0
3837            183            ; Enable the timer and interrupts
3837 439B80     184            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
383A D2CA       185       setb TR2  ; Enable timer 2
383C            186   
383C D2AF       187            setb EA ; Enable global interrupts
383E 22         188       ret
383F            189   
383F            190   
383F            191   ;---------------------------------;
383F            192   ; ISR for Timer 2                 ;
383F            193   ;---------------------------------;
383F            194   Timer2_ISR:
383F C2CF       195            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
3841 C0D0       196            push psw
3843 C0E0       197            push acc
3845            198            
3845 0557       199            inc pwm_counter
3847 C3         200            clr c
3848 E55A       201            mov a, pwm
384A 9557       202            subb a, pwm_counter ; If pwm_counter <= pwm then c=1
384C B3         203            cpl c
384D 9290       204            mov PWM_OUT, c
384F            205            
384F E557       206            mov a, pwm_counter
3851 B46435     207            cjne a, #100, Timer2_ISR_done
3854            208            ; executes every second
3854 755700     209            mov pwm_counter, #0
3857 0559       210            inc seconds ; It is super easy to keep a seconds count here
3859 D202       211            setb s_flag
385B            212   
385B E556       213            mov a, FSM1_state
385D B40003     214            cjne a, #0, Abort_Check0                        ; For abort check, the abort should not trigger if you are in state 0
3860 023889     215            ljmp Timer2_ISR_done
3863            216   
3863            217   Abort_Check0:
3863            218   ; Check if temperature is above 240. If so, abort
3863 C3         219            clr c
3864 E545       220            mov a, tempc
3866 94F0       221            subb a, #240                                            ; if a is greater than 240, there will be no carry bit so we need to abort
3868 4006       222            jc Abort_Check1                                                 ; if temperature is below 240, continue to next check
386A            223            ; abort routine
386A 75560A     224            mov FSM1_state, #10
386D 023889     225       ljmp Timer2_ISR_done                ; if temp is above 240, abort condition has already been triggered, skip ahead to done
3870            226   
3870            227   Abort_Check1:
3870            228   ; Check if temperature is below 50. If so, check for how long
3870 E545       229            mov a, tempc
3872 C3         230            clr c
3873 9432       231            subb a, #50                                                     ; if tempc (stored in a) is less than 50, there will be a carry bit
3875 500F       232            jnc Timer2_ISR_abort_done                       ; skip the abort checks if temperature is above 50
3877            233   
3877            234   Abort_Check2:
3877            235   ; Check if has been 60 seconds (at below 50 degrees)
3877 055B       236            inc abort_time
3879 E55B       237            mov a, abort_time
387B C3         238            clr c
387C 943C       239            subb a, #60                                                     ; if abort_time is less than 60, there will be a carry bit
387E 4009       240            jc Timer2_ISR_done                                      ; if there is a carry 
3880 75560A     241            mov FSM1_state, #10
3883 023889     242            ljmp Timer2_ISR_done
3886            243   
3886            244   Timer2_ISR_abort_done:
3886 755B00     245            mov abort_time, #0
3889            246   
3889            247   Timer2_ISR_done:
3889 D0E0       248            pop acc
388B D0D0       249            pop psw
388D 32         250            reti
388E            251   
388E            252   line1:
388E 50574D20   253            DB 'PWM Example     '
     4578616D
     706C6520
     20202020
389E 00         254            DB 0
389F            255   line2:
389F 43686B20   256            DB 'Chk pin 15:P1.0 '
     70696E20
     31353A50
     312E3020
38AF 00         257            DB 0
38B0            258   
38B0            259   ; /* Send a character using the serial port */
38B0            260   putchar:
38B0 3099FD     261       jnb TI, putchar
38B3 C299       262       clr TI
38B5 F599       263       mov SBUF, a
38B7 22         264       ret
38B8            265   
38B8            266   ; Send a constant-zero-terminated string using the serial port
38B8            267   SendString:
38B8 E4         268       clr A
38B9 93         269       movc A, @A+DPTR
38BA 6006       270       jz SendStringDone
38BC 1238B0     271       lcall putchar
38BF A3         272       inc DPTR
38C0 80F6       273       sjmp SendString
38C2            274   SendStringDone:
38C2 22         275       ret
38C3            276   
38C3            277   ; Sends binary data to Python via putchar
38C3            278   SendBin:                                         
38C3 E4         279            clr A                                   ; Sends temp_mc
38C4 E546       280            mov a, temp_mc+0
38C6 1238B0     281            lcall putchar
38C9 E4         282            clr A
38CA E547       283            mov a, temp_mc+1
38CC 1238B0     284            lcall putchar
38CF E4         285            clr A
38D0 E548       286            mov a, temp_mc+2
38D2 1238B0     287            lcall putchar
38D5 E4         288            clr A
38D6 E549       289            mov a, temp_mc+3
38D8 1238B0     290            lcall putchar
38DB            291   
38DB E4         292            clr A                                   ; Sends data_out
38DC E538       293            mov a, data_out+0
38DE 1238B0     294            lcall putchar
38E1 E4         295            clr A
38E2 E539       296            mov a, data_out+1
38E4 1238B0     297            lcall putchar
38E7 E4         298            clr A                                   ; Sends data_out
38E8 E53A       299            mov a, data_out+2
38EA 1238B0     300            lcall putchar
38ED E4         301            clr A
38EE E53B       302            mov a, data_out+3
38F0 1238B0     303            lcall putchar
38F3 22         304            ret
38F4            305   
38F4            306   ASCII_CHAR: 
38F4 30313233   307            db '0123456789ABCDEF'
     34353637
     38394142
     43444546
3904            308   
3904            309   Hello_World:
3904 48656C6C   310       DB  'Hello, World!', '\r', '\n', 0
     6F2C2057
     6F726C64
     210D0A00
3914            311   New_Line:
3914 0D0A00     312            DB '\r', '\n', 0
3917            313   
3917            314   ; /* 1ms DELAY FUNCTIONS */
3917            315   wait_1ms:
3917 C28C       316            clr     TR0 ; Stop timer 0
3919 C28D       317            clr     TF0 ; Clear overflow flag
391B 758CBF     318            mov     TH0, #high(TIMER0_RELOAD_1MS)
391E 758A28     319            mov     TL0,#low(TIMER0_RELOAD_1MS)
3921 D28C       320            setb TR0
3923 308DFD     321            jnb     TF0, $ ; Wait for overflow
3926 22         322            ret
3927            323   waitms:
3927 123917     324            lcall wait_1ms
392A DAFB       325            djnz R2, waitms
392C 22         326            ret
392D            327   
392D            328   Display_formated_BCD: ;4 dig 
392D C0E0       329            push acc
392F 7401       329            mov a, #1
3931 14         329            dec a
3932 12337E     329            lcall ?Set_Cursor_1 ; Select column and row
3935 D0E0       329            pop acc
3937 C083       330            push dph
3939 C082       330            push dpl
393B C0E0       330            push acc
393D 903290     330            mov dptr, #temp_message
3940 123371     330            lcall ?Send_Constant_String
3943 D0E0       330            pop acc
3945 D082       330            pop dpl
3947 D083       330            pop dph
3949 C0E0       331            push acc
394B 7407       331            mov a, #7
394D 14         331            dec a
394E 12337C     331            lcall ?Set_Cursor_2 ; Select column and row
3951 D0E0       331            pop acc
3953 C000       332            push ar0
3955 A83E       332            mov r0, bcd+2
3957 123383     332            lcall ?Display_BCD
395A D000       332            pop ar0
395C C0E0       333            push acc
395E 7409       333            mov a, #9
3960 14         333            dec a
3961 12337C     333            lcall ?Set_Cursor_2 ; Select column and row
3964 D0E0       333            pop acc
3966 C000       334            push ar0
3968 A83D       334            mov r0, bcd+1
396A 123383     334            lcall ?Display_BCD
396D D000       334            pop ar0
396F C0E0       335            push acc
3971 740A       335            mov a, #10
3973 14         335            dec a
3974 12337C     335            lcall ?Set_Cursor_2 ; Select column and row
3977 D0E0       335            pop acc
3979            335   
3979 C000       336            push ar0
397B A83D       336            mov r0, bcd+1
397D 123383     336            lcall ?Display_BCD
3980 D000       336            pop ar0
3982            337            
3982 C0E0       338            push acc
3984 740C       338            mov a, #12
3986 14         338            dec a
3987 12337C     338            lcall ?Set_Cursor_2 ; Select column and row
398A D0E0       338            pop acc
398C C000       339            push ar0
398E A83C       339            mov r0, bcd+0
3990 123383     339            lcall ?Display_BCD
3993 D000       339            pop ar0
3995 C0E0       340            push acc
3997 740A       340            mov a, #10
3999 14         340            dec a
399A 12337C     340            lcall ?Set_Cursor_2 ; Select column and row
399D D0E0       340            pop acc
399F C0E0       341            push acc
39A1 742E       341            mov a, #'.'
39A3 123334     341            lcall ?WriteData
39A6 D0E0       341            pop acc
39A8 C0E0       342            push acc
39AA 7407       342            mov a, #7
39AC 14         342            dec a
39AD 12337C     342            lcall ?Set_Cursor_2 ; Select column and row
39B0 D0E0       342            pop acc
39B2 C0E0       343            push acc
39B4 7420       343            mov a, #0x20
39B6 123334     343            lcall ?WriteData
39B9 D0E0       343            pop acc
39BB C0E0       344            push acc
39BD 740F       344            mov a, #15
39BF 14         344            dec a
39C0 12337C     344            lcall ?Set_Cursor_2 ; Select column and row
39C3 D0E0       344            pop acc
39C5 C0E0       345            push acc
39C7 74DF       345            mov a, #0xDF
39C9 123334     345            lcall ?WriteData
39CC D0E0       345            pop acc
39CE C0E0       346            push acc
39D0 7410       346            mov a, #16
39D2 14         346            dec a
39D3 12337C     346            lcall ?Set_Cursor_2 ; Select column and row
39D6 D0E0       346            pop acc
39D8 C0E0       347            push acc
39DA 7443       347            mov a, #'C'
39DC 123334     347            lcall ?WriteData
39DF D0E0       347            pop acc
39E1 22         348            ret
39E2            349   
39E2            350   Display_temp_BCD: ;4 dig 
39E2 C0E0       351            push acc
39E4 E53D       352            mov a, bcd+1
39E6 B40003     353            cjne a, #0, Display_temp_BCD2
39E9 023A41     354            ljmp Display_temp_BCD3
39EC            355   Display_temp_BCD2:
39EC C0E0       356            push acc
39EE 7401       356            mov a, #1
39F0 14         356            dec a
39F1 12337C     356            lcall ?Set_Cursor_2 ; Select column and row
39F4 D0E0       356            pop acc
39F6 C083       357            push dph
39F8 C082       357            push dpl
39FA C0E0       357            push acc
39FC 903290     357            mov dptr, #temp_message
39FF 123371     357            lcall ?Send_Constant_String
3A02 D0E0       357            pop acc
3A04 D082       357            pop dpl
3A06 D083       357            pop dph
3A08 C0E0       358            push acc
3A0A 740B       358            mov a, #11
3A0C 14         358            dec a
3A0D 12337C     358            lcall ?Set_Cursor_2 ; Select column and row
3A10 D0E0       358            pop acc
3A12            358   
3A12 C000       359            push ar0
3A14 A83D       359            mov r0, bcd+1
3A16 123383     359            lcall ?Display_BCD
3A19 D000       359            pop ar0
3A1B C0E0       360            push acc
3A1D 740B       360            mov a, #11
3A1F 14         360            dec a
3A20 12337C     360            lcall ?Set_Cursor_2 ; Select column and row
3A23 D0E0       360            pop acc
3A25 C0E0       361            push acc
3A27 7420       361            mov a, #0x20
3A29 123334     361            lcall ?WriteData
3A2C D0E0       361            pop acc
3A2E C0E0       362            push acc
3A30 740D       362            mov a, #13
3A32 14         362            dec a
3A33 12337C     362            lcall ?Set_Cursor_2 ; Select column and row
3A36 D0E0       362            pop acc
3A38 C000       363            push ar0
3A3A A83C       363            mov r0, bcd+0
3A3C 123383     363            lcall ?Display_BCD
3A3F D000       363            pop ar0
3A41            364   Display_temp_BCD3:
3A41 C0E0       365            push acc
3A43 740C       365            mov a, #12
3A45 14         365            dec a
3A46 12337C     365            lcall ?Set_Cursor_2 ; Select column and row
3A49 D0E0       365            pop acc
3A4B C0E0       366            push acc
3A4D 7420       366            mov a, #0x20
3A4F 123334     366            lcall ?WriteData
3A52 D0E0       366            pop acc
3A54            367   Display_temp_BCD_done:
3A54 C0E0       368            push acc
3A56 740F       368            mov a, #15
3A58 14         368            dec a
3A59 12337C     368            lcall ?Set_Cursor_2 ; Select column and row
3A5C D0E0       368            pop acc
3A5E C0E0       369            push acc
3A60 74DF       369            mov a, #0xDF
3A62 123334     369            lcall ?WriteData
3A65 D0E0       369            pop acc                 ; deg symbol
3A67 C0E0       370            push acc
3A69 7410       370            mov a, #16
3A6B 14         370            dec a
3A6C 12337C     370            lcall ?Set_Cursor_2 ; Select column and row
3A6F D0E0       370            pop acc
3A71 C0E0       371            push acc
3A73 7443       371            mov a, #'C'
3A75 123334     371            lcall ?WriteData
3A78 D0E0       371            pop acc
3A7A D0E0       372            pop acc
3A7C 22         373            ret
3A7D            374   
3A7D            375   
3A7D            376   ; /* READ ADC */
3A7D            377   Read_ADC:
3A7D C2EF       378            clr ADCF
3A7F D2EE       379            setb ADCS ;  ADC start trigger signal
3A81 30EFFD     380       jnb ADCF, $ ; Wait for conversion complete
3A84            381       
3A84            382       ; Read the ADC result and store in [R1, R0]
3A84 E5C2       383       mov a, ADCRL
3A86 540F       384       anl a, #0x0f
3A88 F8         385       mov R0, a
3A89 E5C3       386       mov a, ADCRH   
3A8B C4         387       swap a
3A8C C0E0       388       push acc
3A8E 540F       389       anl a, #0x0f
3A90 F9         390       mov R1, a
3A91 D0E0       391       pop acc
3A93 54F0       392       anl a, #0xf0
3A95 48         393       orl a, R0
3A96 F8         394       mov R0, A
3A97 22         395            ret
3A98            396   
3A98            397   Main:
3A98 75817F     398       mov SP, #0x7F        ; Set the stack pointer to the begining of idata
3A9B            399       
3A9B 1237BA     400       lcall InitAll
3A9E 12333E     401       lcall LCD_4BIT
3AA1            402   
3AA1            403            ; Initialize all variables
3AA1 D201       404            setb seconds_flag
3AA3 755600     405            mov FSM1_state, #0
3AA6 755900     406            mov seconds, #0
3AA9 755CDC     407            mov ReflowTemp, #220
3AAC 755D1E     408            mov ReflowTime, #30
3AAF 755E3C     409            mov SoakTime, #60
3AB2 755B00     410            mov abort_time, #0
3AB5            411   
3AB5            412       ; initial messages in LCD
3AB5 C0E0       413            push acc
3AB7 7401       413            mov a, #1
3AB9 14         413            dec a
3ABA 12337E     413            lcall ?Set_Cursor_1 ; Select column and row
3ABD D0E0       413            pop acc
3ABF C083       414            push dph
3AC1 C082       414            push dpl
3AC3 C0E0       414            push acc
3AC5 90326E     414            mov dptr, #test_message
3AC8 123371     414            lcall ?Send_Constant_String
3ACB D0E0       414            pop acc
3ACD D082       414            pop dpl
3ACF D083       414            pop dph
3AD1 C0E0       415            push acc
3AD3 7401       415            mov a, #1
3AD5 14         415            dec a
3AD6 12337C     415            lcall ?Set_Cursor_2 ; Select column and row
3AD9 D0E0       415            pop acc
3ADB C083       416            push dph
3ADD C082       416            push dpl
3ADF C0E0       416            push acc
3AE1 90327F     416            mov dptr, #value_message
3AE4 123371     416            lcall ?Send_Constant_String
3AE7 D0E0       416            pop acc
3AE9 D082       416            pop dpl
3AEB D083       416            pop dph
3AED            417   
3AED            418            ;mov data_out, #0b00000001
3AED            419   
3AED            420   ;Forever: ;avaliable: r2, r3
3AED            421   FSM_sys:
3AED            422   ; /* TEMP_READ: READS TEMPERATURE */
3AED            423   ; Note:     Before converting to be stored tempC, 
3AED            424   ;           all values are stored as 32 bit numbers 
3AED            425   ;           with 3 decimal points. (in milli-celcius)
3AED            426   ;           
3AED            427   ; Example:  2.07 V would be represented by the number
3AED            428   ;           20700. (The real value * 1000).
3AED            429   TEMP_READ:
3AED 023B20     430            ljmp read_led
3AF0            431   
3AF0            432   Avg_ADC:                                                 ; function for ADC noise reduction
3AF0 753000     433            mov x+0, #low (0 % 0x10000) 
3AF3 753100     433            mov x+1, #high(0 % 0x10000) 
3AF6 753200     433            mov x+2, #low (0 / 0x10000) 
3AF9 753300     433            mov x+3, #high(0 / 0x10000) 
3AFC 7DFF       434       mov R5, #255
3AFE            435   sum_loop_avg:
3AFE 123A7D     436       lcall Read_ADC
3B01 753700     437       mov y+3, #0
3B04 753600     438       mov y+2, #0
3B07 8935       439       mov y+1, R1
3B09 8834       440       mov y+0, R0
3B0B 12349F     441       lcall add32
3B0E DDEE       442       djnz R5, sum_loop_avg
3B10 7534FF     443            mov y+0, #low (255 % 0x10000) 
3B13 753500     443            mov y+1, #high(255 % 0x10000) 
3B16 753600     443            mov y+2, #low (255 / 0x10000) 
3B19 753700     443            mov y+3, #high(255 / 0x10000) 
3B1C 1235E1     444       lcall div32
3B1F 22         445       ret
3B20            446   
3B20            447   read_led:
3B20 53E8F0     448       anl ADCCON0, #0xf0          ; read led voltage
3B23 43E800     449       orl ADCCON0, #LED_PORT
3B26 123AF0     450       lcall Avg_ADC
3B29 8841       451       mov VLED_ADC+0, R0          ; save reading to VLED_ADC
3B2B 8942       452            mov VLED_ADC+1, R1
3B2D            453   
3B2D            454   read_lm335:
3B2D 53E8F0     455       anl ADCCON0, #0xf0          ; *** LM335 ***
3B30 43E805     456       orl ADCCON0, #LM335_PORT
3B33 123AF0     457       lcall Avg_ADC
3B36 8830       458       mov x+0, R0                              ; load lm335 reading to x
3B38 8931       459            mov x+1, R1
3B3A 753200     460            mov x+2, #0                     
3B3D 753300     461            mov x+3, #0
3B40 7534A0     462            mov y+0, #low (260000 % 0x10000) 
3B43 7535F7     462            mov y+1, #high(260000 % 0x10000) 
3B46 753603     462            mov y+2, #low (260000 / 0x10000) 
3B49 753700     462            mov y+3, #high(260000 / 0x10000)               ; load const vled ref into y      
3B4C 123554     463       lcall mul32
3B4F 854134     464       mov y+0, VLED_ADC+0              ; import vled reading into y
3B52 854235     465            mov y+1, VLED_ADC+1         
3B55 753600     466            mov y+2, #0                     
3B58 753700     467            mov y+3, #0
3B5B 1235E1     468       lcall div32
3B5E 753468     469            mov y+0, #low (273000 % 0x10000) 
3B61 75352A     469            mov y+1, #high(273000 % 0x10000) 
3B64 753604     469            mov y+2, #low (273000 / 0x10000) 
3B67 753700     469            mov y+3, #high(273000 / 0x10000)                            ; adjust to 273.000 C offset
3B6A 1234C0     470            lcall sub32                     ; result of lm335 temp remains in x
3B6D 85304E     471            mov temp_lm+0, x+0          ; store 3 decimal lm335 value for later
3B70 85314F     472       mov temp_lm+1, x+1                           
3B73 853250     473       mov temp_lm+2, x+2
3B76 853351     474       mov temp_lm+3, x+3
3B79            475   
3B79            476   read_opamp:
3B79 53E8F0     477            anl ADCCON0, #0xf0          ; *** OPAMP ***
3B7C 43E807     478       orl ADCCON0, #OPAMP_PORT     ; 
3B7F 123AF0     479            lcall Avg_ADC
3B82 8830       480            mov x+0, R0                         ; load opamp reading to x
3B84 8931       481            mov x+1, R1
3B86 753200     482            mov x+2, #0                     
3B89 753300     483            mov x+3, #0
3B8C 753428     484            mov y+0, #low (2600 % 0x10000) 
3B8F 75350A     484            mov y+1, #high(2600 % 0x10000) 
3B92 753600     484            mov y+2, #low (2600 / 0x10000) 
3B95 753700     484            mov y+3, #high(2600 / 0x10000)                 ; load const vled ref (2070 mV) into y      
3B98 123554     485       lcall mul32
3B9B 854134     486       mov y+0, VLED_ADC+0              ; import led adc reading into y
3B9E 854235     487            mov y+1, VLED_ADC+1                
3BA1 753600     488            mov y+2, #0                     
3BA4 753700     489            mov y+3, #0
3BA7 1235E1     490       lcall div32                 ; x value now stores OPAMP V in mV
3BAA 7534E8     491            mov y+0, #low (1000 % 0x10000) 
3BAD 753503     491            mov y+1, #high(1000 % 0x10000) 
3BB0 753600     491            mov y+2, #low (1000 / 0x10000) 
3BB3 753700     491            mov y+3, #high(1000 / 0x10000)                                  
3BB6 123554     492            lcall mul32                                     ; turn mV to uV
3BB9 75341B     493            mov y+0, #low (V2C_DIVISOR % 0x10000) 
3BBC 753504     493            mov y+1, #high(V2C_DIVISOR % 0x10000) 
3BBF 753600     493            mov y+2, #low (V2C_DIVISOR / 0x10000) 
3BC2 753700     493            mov y+3, #high(V2C_DIVISOR / 0x10000) 
3BC5 1235E1     494            lcall div32                                     ; deg C reading now in x        
3BC8 7534E8     495            mov y+0, #low (1000 % 0x10000) 
3BCB 753503     495            mov y+1, #high(1000 % 0x10000) 
3BCE 753600     495            mov y+2, #low (1000 / 0x10000) 
3BD1 753700     495            mov y+3, #high(1000 / 0x10000) 
3BD4 123554     496            lcall mul32                                     ; conv to mV again to add to lm335 data
3BD7            497   
3BD7            498   add_lm335_to_opamp:
3BD7 854E34     499       mov y+0, temp_lm+0           ; load lm335 temp to y
3BDA 854F35     500       mov y+1, temp_lm+1
3BDD 855036     501       mov y+2, temp_lm+2
3BE0 855137     502       mov y+3, temp_lm+3
3BE3 12349F     503       lcall add32                  ; lm335 + opamp = real temp
3BE6 853046     504       mov temp_mc+0, x+0          ; store result in temp_mc (for python)
3BE9 853147     505       mov temp_mc+1, x+1                           
3BEC 853248     506       mov temp_mc+2, x+2
3BEF 853349     507       mov temp_mc+3, x+3
3BF2            508            
3BF2            509   export_to_main:                                  ; exports temp reading to rest of code
3BF2 854630     510            mov x+0, temp_mc+0          
3BF5 854731     511       mov x+1, temp_mc+1
3BF8 854832     512       mov x+2, temp_mc+2
3BFB 854933     513       mov x+3, temp_mc+3
3BFE 7534E8     514            mov y+0, #low (1000 % 0x10000) 
3C01 753503     514            mov y+1, #high(1000 % 0x10000) 
3C04 753600     514            mov y+2, #low (1000 / 0x10000) 
3C07 753700     514            mov y+3, #high(1000 / 0x10000) 
3C0A 1235E1     515       lcall div32
3C0D 853045     516       mov tempc, x+0              ; Both tempc and x now stores temp (C)           
3C10            517   ;lcall TEMP_READ
3C10            518   
3C10            519   export_to_bcd:                                   ; sends temp reading in C to bcd
3C10 1233DA     520            lcall hex2bcd
3C13 1239E2     521            lcall Display_temp_BCD
3C16            522   
3C16            523   Export:                                                  ; Data export to python
3C16 7AFA       524            mov R2, #250                            ; Wait 500 ms between conversions
3C18 123927     525            lcall waitms
3C1B 7AFA       526            mov R2, #250
3C1D 123927     527            lcall waitms                            ; Sends binary contents of 
3C20 1238C3     528       lcall SendBin                                ; temp_mc and data_out to python
3C23            529   
3C23            530            ; /* FSM1 STATE CHANGE CONTROLS */
3C23 023C26     531            ljmp FSM1
3C26            532   
3C26            533   ; REQUIREMENTS
3C26            534   ; Start/Stop button, to do this, make routine which displays "stopped" for a little bit
3C26            535   ; Temperature display, implemented already
3C26            536   ; Running time display, implement in main
3C26            537   ; 
3C26            538   
3C26            539   
3C26            540   FSM1:
3C26 E556       541            mov a, FSM1_state
3C28 C0E0       542            push acc
3C2A 7401       542            mov a, #1
3C2C 14         542            dec a
3C2D 12337E     542            lcall ?Set_Cursor_1 ; Select column and row
3C30 D0E0       542            pop acc
3C32 C083       543            push dph
3C34 C082       543            push dpl
3C36 C0E0       543            push acc
3C38 9032C3     543            mov dptr, #state_message
3C3B 123371     543            lcall ?Send_Constant_String
3C3E D0E0       543            pop acc
3C40 D082       543            pop dpl
3C42 D083       543            pop dph
3C44 C0E0       544            push acc
3C46 740C       544            mov a, #12
3C48 14         544            dec a
3C49 12337C     544            lcall ?Set_Cursor_2 ; Select column and row
3C4C D0E0       544            pop acc
3C4E 85455F     545            mov Val_test+0, tempc          ; store result in temp_mc (for python)
3C51 756000     546       mov Val_test+1, #0   
3C54 756100     547       mov Val_test+2, #0
3C57 756200     548       mov Val_test+3, #0
3C5A 12366C     549            lcall Display_Val
3C5D            550   
3C5D            551   FSM1_state0:
3C5D B4002A     552            cjne a, #0, FSM1_state1 ; if FSM1_state (currently stored in a) is not equal to zero (ie. state zero), go to state 1
3C60 755601     553            mov FSM1_state, #1
3C63 023C87     554            ljmp FSM1_state0_done
3C66 755A00     555            mov pwm, #0
3C69 C0E0       556            push acc
3C6B 740F       556            mov a, #15
3C6D 14         556            dec a
3C6E 12337E     556            lcall ?Set_Cursor_1 ; Select column and row
3C71 D0E0       556            pop acc
3C73 C000       557            push ar0
3C75 7800       557            mov r0, #0x00
3C77 123383     557            lcall ?Display_BCD
3C7A D000       557            pop ar0
3C7C C201       558            clr seconds_flag
3C7E            559            ; check for push button input
3C7E 208406     560            jb START_BUTTON, FSM1_state0_done
3C81 3084FD     561            jnb START_BUTTON, $ ; Wait for key release
3C84 755601     562            mov FSM1_state, #1
3C87            563   
3C87            564   FSM1_state0_done:
3C87 023AED     565            ljmp FSM_sys
3C8A            566   
3C8A            567   FSM1_state1:
3C8A B40126     568            cjne a, #1, FSM1_state2
3C8D 755A64     569            mov pwm, #100
3C90 C0E0       570            push acc
3C92 740F       570            mov a, #15
3C94 14         570            dec a
3C95 12337E     570            lcall ?Set_Cursor_1 ; Select column and row
3C98 D0E0       570            pop acc
3C9A C000       571            push ar0
3C9C 7801       571            mov r0, #0x01
3C9E 123383     571            lcall ?Display_BCD
3CA1 D000       571            pop ar0
3CA3 755900     572            mov seconds, #0
3CA6 7496       573            mov a, #150
3CA8 C3         574            clr c
3CA9 9545       575            subb a, tempc
3CAB 5003       576            jnc FSM1_state1_done
3CAD 755602     577            mov FSM1_state, #2
3CB0            578   
3CB0            579   FSM1_state1_done:
3CB0 023AED     580            ljmp FSM_sys
3CB3            581   
3CB3            582   FSM1_state2:
3CB3 B4022E     583            cjne a, #2, FSM1_state3
3CB6 755A14     584            mov pwm, #20
3CB9 C0E0       585            push acc
3CBB 740F       585            mov a, #15
3CBD 14         585            dec a
3CBE 12337E     585            lcall ?Set_Cursor_1 ; Select column and row
3CC1 D0E0       585            pop acc
3CC3 C000       586            push ar0
3CC5 7802       586            mov r0, #0x02
3CC7 123383     586            lcall ?Display_BCD
3CCA D000       586            pop ar0
3CCC 30010A     587            jnb seconds_flag, FSM_state2_funk
3CCF            588            ;mov a, #60
3CCF E55E       589            mov a, SoakTime
3CD1 C3         590            clr c
3CD2 9559       591            subb a, seconds                 ; Want time to be greater than 60 seconds
3CD4 400B       592            jc FSM1_state2_done
3CD6 755603     593            mov FSM1_state, #3
3CD9            594   
3CD9            595   FSM_state2_funk:
3CD9 755900     596            mov seconds, #0         ; Set seconds so we can count up to the required time 
3CDC D201       597            setb seconds_flag       ; seconds flag so we don't reset seconds_flag multiple times
3CDE 023CB3     598            ljmp FSM1_state2        
3CE1            599   
3CE1            600   FSM1_state2_done:
3CE1 023AED     601            ljmp FSM_sys
3CE4            602   
3CE4            603   FSM1_state3:
3CE4 B40325     604            cjne a, #3, FSM1_state4
3CE7 755A64     605            mov pwm, #100
3CEA C0E0       606            push acc
3CEC 740F       606            mov a, #15
3CEE 14         606            dec a
3CEF 12337E     606            lcall ?Set_Cursor_1 ; Select column and row
3CF2 D0E0       606            pop acc
3CF4 C000       607            push ar0
3CF6 7803       607            mov r0, #0x03
3CF8 123383     607            lcall ?Display_BCD
3CFB D000       607            pop ar0
3CFD            608            ;mov a, #220
3CFD E55C       609            mov a, ReflowTemp
3CFF C201       610            clr seconds_flag
3D01 C3         611            clr c
3D02 9545       612            subb a, tempc
3D04 5003       613            jnc FSM1_state3_done
3D06 755604     614            mov FSM1_state, #4
3D09            615   
3D09            616   FSM1_state3_done:
3D09 023AED     617            ljmp FSM_sys
3D0C            618   
3D0C            619   FSM1_state4:
3D0C B4042E     620            cjne a, #4, FSM1_state5
3D0F 755A14     621            mov pwm, #20 
3D12 C0E0       622            push acc
3D14 740F       622            mov a, #15
3D16 14         622            dec a
3D17 12337E     622            lcall ?Set_Cursor_1 ; Select column and row
3D1A D0E0       622            pop acc
3D1C C000       623            push ar0
3D1E 7804       623            mov r0, #0x04
3D20 123383     623            lcall ?Display_BCD
3D23 D000       623            pop ar0
3D25 30010A     624            jnb seconds_flag, FSM1_state4_funk
3D28            625            ;mov a, #45
3D28 E55D       626            mov a, ReflowTime
3D2A C3         627            clr c 
3D2B 9559       628            subb a, seconds ; when seconds is greater than 45, there will be a carry bit
3D2D 400B       629            jc FSM1_state4_done
3D2F 755605     630            mov FSM1_state, #5
3D32            631   
3D32            632   FSM1_state4_funk:
3D32 755900     633            mov seconds, #0
3D35 D201       634            setb seconds_flag
3D37 023D0C     635            ljmp FSM1_state4
3D3A            636   
3D3A            637   FSM1_state4_done:
3D3A 023AED     638            ljmp FSM_sys
3D3D            639   
3D3D            640   FSM1_state5:
3D3D B40523     641            cjne a, #5, FSM1_abort_state            ; if the state is not in 0-5, then it must be 10 (aka the abort state)
3D40 755A00     642            mov pwm, #0
3D43 C0E0       643            push acc
3D45 740F       643            mov a, #15
3D47 14         643            dec a
3D48 12337E     643            lcall ?Set_Cursor_1 ; Select column and row
3D4B D0E0       643            pop acc
3D4D C000       644            push ar0
3D4F 7804       644            mov r0, #0x04
3D51 123383     644            lcall ?Display_BCD
3D54 D000       644            pop ar0
3D56 743C       645            mov a, #60
3D58 C3         646            clr c
3D59 9545       647            subb a, tempc
3D5B 4003       648            jc FSM1_state5_done
3D5D 755600     649            mov FSM1_state, #0
3D60            650   
3D60            651   FSM1_state5_done:
3D60 023AED     652            ljmp FSM_sys
3D63            653   
3D63            654   FSM1_abort_state:                                                ; When the abort state is triggered, turn everything off and remain in this state utill you reset
3D63 B40A22     655            cjne a, #10, FSM1_error                                 ; if state is somehow neither 0-5 or 10, go to state error
3D66 755A00     656            mov pwm, #0
3D69 C0E0       657            push acc
3D6B 7401       657            mov a, #1
3D6D 14         657            dec a
3D6E 12337E     657            lcall ?Set_Cursor_1 ; Select column and row
3D71 D0E0       657            pop acc
3D73 C083       658            push dph
3D75 C082       658            push dpl
3D77 C0E0       658            push acc
3D79 9032B2     658            mov dptr, #abort_message
3D7C 123371     658            lcall ?Send_Constant_String
3D7F D0E0       658            pop acc
3D81 D082       658            pop dpl
3D83 D083       658            pop dph
3D85            659   
3D85 023D63     660            ljmp FSM1_abort_state
3D88            661   
3D88            662   FSM1_error:
3D88 755A00     663            mov pwm, #0
3D8B C0E0       664            push acc
3D8D 7401       664            mov a, #1
3D8F 14         664            dec a
3D90 12337E     664            lcall ?Set_Cursor_1 ; Select column and row
3D93 D0E0       664            pop acc
3D95 C083       665            push dph
3D97 C082       665            push dpl
3D99 C0E0       665            push acc
3D9B 9032D4     665            mov dptr, #error_message
3D9E 123371     665            lcall ?Send_Constant_String
3DA1 D0E0       665            pop acc
3DA3 D082       665            pop dpl
3DA5 D083       665            pop dph
3DA7 023D88     666            ljmp FSM1_error
3DAA            667   
3DAA            668   END
