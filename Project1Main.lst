                  2   $LIST
0000              4   
0000              5   ;  N76E003 pinout:
0000              6   ;                               -------
0000              7   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000              8   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000              9   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             10   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             11   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             12   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             13   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             14   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             15   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             16   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             17   ;                               -------
0000             18   ;
0000             19   
0000             20   CLK                 EQU 16600000                                                 ; Microcontroller system frequency in Hz
0000             21   BAUD                EQU 115200                                                   ; Baud rate of UART in bps
0000             22   TIMER1_RELOAD       EQU (0x100-(CLK/(16*BAUD)))
0000             23   TIMER0_RELOAD_1MS   EQU (0x10000-(CLK/1000))
0000             24   TIMER2_RATE              EQU 100                                                         ; 1/100 = 10ms
0000             25   TIMER2_RELOAD            EQU (65536-(CLK/(16*TIMER2_RATE)))
0000             26   
0000             27   org 0000H
0000 0205E1      28      ljmp Main
0003             29   
0003             30   ; /* TIMER2 ENABLE */
002B             31   org 0x002B
002B 020438      32            ljmp Timer2_ISR
002E             33   
002E             34   
002E             35   ;                     1234567890123456    <- This helps determine the location of the counter
002E 2A2A2A2A    36   test_message:     db '****LOADING*****', 0
     4C4F4144
     494E472A
     2A2A2A2A
     00
003F 54454D50    37   value_message:    db 'TEMP:      ', 0
     3A202020
     20202000
004B 43454C43    38   cel_message:       db 'CELCIUS  READING',0
     49555320
     20524541
     44494E47
     00
005C 46415245    39   fah_message:      db 'FARENHET READING',0
     4E484554
     20524541
     44494E47
     00
006D 41424F52    40   abort_message:     db 'ABORTABORTABORT ', 0
     5441424F
     52544142
     4F525420
     00
007E             41   
007E             42   CSEG
007E             43   
007E             44   ; /* PORT DEFINITIONS */
007E             45   LCD_RS equ P1.3
007E             46   LCD_E  equ P1.4
007E             47   LCD_D4 equ P0.0
007E             48   LCD_D5 equ P0.1
007E             49   LCD_D6 equ P0.2
007E             50   LCD_D7 equ P0.3
007E             51   
007E             52   PWM_OUT equ P1.0
007E             53   START_BUTTON equ P0.4
007E             54   ; Analog Input Port Numbering
007E             55   LED_PORT equ 0x00                        ; AIN port numbers
007E             56   LM335_PORT equ 0x05
007E             57   OPAMP_PORT equ 0x01
007E             58   
                 60   	$LIST
0146             62   
0146             63   ; /* MATH.INC STUFFS */
0030             64   DSEG at 30H
0030             65   x:               ds 4
0034             66   y:               ds 4
0038             67   data_out:   ds 1
0039             68   
0039             69   bcd:             ds 5
003E             70   temp_out:        ds 4
0042             71   
0042             72   VLED_ADC: ds 2
0044             73   dtemp:  ds 2
0046             74   tempc: ds 1
0047             75   temp_mc:         ds 4
004B             76   OPAMP_temp: ds 4
004F             77   
004F             78   ; /* FSM STATES */
004F             79   FSM1_state:  ds 1
0050             80   
0050             81   ; /* TIME CHECK AND PWM */
0050             82   pwm_counter:     ds 1
0051             83   count10ms:               ds 1
0052             84   seconds:                 ds 1
0053             85   pwm:                     ds 1
0054             86   abort_time:              ds 1
0055             87   
0000             88   BSEG
0000             89   mf: dbit 1
0001             90   seconds_flag: dbit 1
0002             91   s_flag: dbit 1
0003             92   
0003             93   
                546   $LIST
                 95   $LIST
03B6             97   
03B6             98   InitAll:
03B6             99            ; /*** SERIAL PORT INITIALIZATION ***/
03B6            100   
03B6 75AC00     101            mov     P3M1,#0x00                      ; Configure all the pins for biderectional I/O
03B9 75AD00     102            mov     P3M2,#0x00
03BC 75B300     103            mov     P1M1,#0x00
03BF 75B400     104            mov     P1M2,#0x00
03C2 75B100     105            mov     P0M1,#0x00
03C5 75B200     106            mov     P0M2,#0x00
03C8            107       ; Since the reset button bounces, we need to wait a bit before
03C8            108       ; sending messages, otherwise we risk displaying gibberish!
03C8            109       ;mov R1, #200
03C8            110       ;mov R0, #104
03C8            111       ;djnz R0, $                                  ; 4 cycles->4*60.285ns*104=25us
03C8            112       ;djnz R1, $-4                                ; 25us*200=5.0ms
03C8 7A05       113       mov R2, #5
03CA 12050B     114       lcall waitms
03CD            115       ; Now we can proceed with the configuration of the serial port
03CD 438E10     116            orl     CKCON, #0x10                    ; CLK is the input for timer 1
03D0 438780     117            orl     PCON, #0x80                     ; Bit SMOD=1, double baud rate
03D3 759852     118            mov     SCON, #0x52
03D6 53C4DF     119            anl     T3CON, #0b11011111
03D9 53890F     120            anl     TMOD, #0x0F                             ; Clear the configuration bits for timer 1
03DC 438920     121            orl     TMOD, #0x20                     ; Timer 1 Mode 2
03DF 758DF7     122            mov     TH1, #TIMER1_RELOAD
03E2 D28E       123            setb TR1
03E4            124   
03E4            125            ; /*** INITIALIZE THE REST ***/
03E4            126   
03E4 438E10     127            orl     CKCON, #0x10                    ; CLK is the input for timer 1
03E7 438780     128            orl     PCON, #0x80                     ; Bit SMOD=1, double baud rate
03EA 759852     129            mov     SCON, #0x52
03ED 53C4DF     130            anl     T3CON, #0b11011111
03F0 53890F     131            anl     TMOD, #0x0F                     ; Clear the configuration bits for timer 1
03F3 438920     132            orl     TMOD, #0x20                     ; Timer 1 Mode 2
03F6 758DF7     133            mov     TH1, #TIMER1_RELOAD     ; TH1=TIMER1_RELOAD;
03F9 D28E       134            setb TR1
03FB            135            
03FB            136            ; Using timer 0 for delay functions.  Initialize here:
03FB C28C       137            clr     TR0                                     ; Stop timer 0
03FD 438E08     138            orl     CKCON,#0x08                     ; CLK is the input for timer 0
0400 5389F0     139            anl     TMOD,#0xF0                              ; Clear the configuration bits for timer 0
0403 438901     140            orl     TMOD,#0x01                              ; Timer 0 in Mode 1: 16-bit timer
0406            141            
0406            142            ; Initialize the pin used by the ADC (P1.1) as input.
0406 43B302     143            orl     P1M1, #0b00000010
0409 53B4FD     144            anl     P1M2, #0b11111101
040C            145            
040C            146            ; Initialize and start the ADC:
040C 53E8F0     147            anl ADCCON0, #0xF0
040F 43E807     148            orl ADCCON0, #0x07                      ; Select channel 7
0412            149            ; AINDIDS select if some pins are analog inputs or digital I/O:
0412 75F600     150            mov AINDIDS, #0x00                      ; Disable all analog inputs
0415 43F680     151            orl AINDIDS, #0b10000000        ; P1.1 is analog input
0418 43E101     152            orl ADCCON1, #0x01                      ; Enable ADC
041B            153   
041B            154   ;----------------------------------------------------------------;
041B            155   ;                                        TIMER 2 INITIALIZATION
041B            156   ;----------------------------------------------------------------;
041B            157   
041B 75C800     158            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
041E 75CDD7     159            mov TH2, #high(TIMER2_RELOAD)
0421 75CC79     160            mov TL2, #low(TIMER2_RELOAD)
0424            161            ; Set the reload value
0424 75C9A0     162            mov T2MOD, #0b1010_0000 ; Enable timer 2 autoreload, and clock divider is 16
0427 75CBD7     163            mov RCMP2H, #high(TIMER2_RELOAD)
042A 75CA79     164            mov RCMP2L, #low(TIMER2_RELOAD)
042D            165            ; Init the free running 10 ms counter to zero
042D 755000     166            mov pwm_counter, #0
0430            167            ; Enable the timer and interrupts
0430 439B80     168            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0433 D2CA       169       setb TR2  ; Enable timer 2
0435            170   
0435 D2AF       171            setb EA ; Enable global interrupts
0437 22         172       ret
0438            173   
0438            174   
0438            175   ;---------------------------------;
0438            176   ; ISR for Timer 2                 ;
0438            177   ;---------------------------------;
0438            178   Timer2_ISR:
0438 C2CF       179            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
043A C0D0       180            push psw
043C C0E0       181            push acc
043E            182            
043E 0550       183            inc pwm_counter
0440 C3         184            clr c
0441 E553       185            mov a, pwm
0443 9550       186            subb a, pwm_counter ; If pwm_counter <= pwm then c=1
0445 B3         187            cpl c
0446 9290       188            mov PWM_OUT, c
0448            189            
0448 E550       190            mov a, pwm_counter
044A B46432     191            cjne a, #100, Timer2_ISR_done
044D            192            ; executes every second
044D 755000     193            mov pwm_counter, #0
0450 0552       194            inc seconds ; It is super easy to keep a seconds count here
0452 D202       195            setb s_flag
0454 E54F       196            mov a, FSM1_state
0456 B40003     197            cjne a, #0, Abort_Check0                        ; For abort check, the abort should not trigger if you are in state 0
0459 02047F     198            ljmp Timer2_ISR_done
045C            199   
045C            200   Abort_Check0:
045C            201   ; Check if temperature is above 300. If so, abort
045C C3         202            clr c
045D E546       203            mov a, tempc
045F 94F0       204            subb a, #240                                            ; if a is greater than 240, there will be no carry bit so we need to abort
0461 4006       205            jc Abort_Check1                                                 ; if temperature is below 240, continue to next check
0463            206            ; abort routine
0463 754F0A     207            mov FSM1_state, #10
0466 02047F     208       ljmp Timer2_ISR_done                ; if temp is above 240, abort condition has already been triggered, skip ahead to done
0469            209   
0469            210   Abort_Check1:
0469            211   ; Check if temperature is below 50. If so, check for how long
0469 E546       212            mov a, tempc
046B C3         213            clr c
046C 9432       214            subb a, #50                                                     ; if tempc (stored in a) is less than 50, there will be a carry bit
046E 500C       215            jnc Timer2_ISR_abort_done                       ; skip the abort checks if temperature is above 50
0470            216   
0470            217   Abort_Check2:
0470            218   ; Check if has been 60 seconds (at below 50 degrees)
0470 0554       219            inc abort_time
0472 E554       220            mov a, abort_time
0474 C3         221            clr c
0475 943C       222            subb a, #60                                                     ; if abort_time is less than 60, there will be a carry bit
0477 5006       223            jnc Timer2_ISR_done                                     ; if there is a carry 
0479 754F0A     224            mov FSM1_state, #10
047C            225   
047C            226   Timer2_ISR_abort_done:
047C 755400     227            mov abort_time, #0
047F            228   
047F            229   Timer2_ISR_done:
047F D0E0       230            pop acc
0481 D0D0       231            pop psw
0483 32         232            reti
0484            233   
0484            234   line1:
0484 50574D20   235            DB 'PWM Example     '
     4578616D
     706C6520
     20202020
0494 00         236            DB 0
0495            237   line2:
0495 43686B20   238            DB 'Chk pin 15:P1.0 '
     70696E20
     31353A50
     312E3020
04A5 00         239            DB 0
04A6            240   
04A6            241   ; /* Send a character using the serial port */
04A6            242   putchar:
04A6 3099FD     243       jnb TI, putchar
04A9 C299       244       clr TI
04AB F599       245       mov SBUF, a
04AD 22         246       ret
04AE            247   
04AE            248   ; Send a constant-zero-terminated string using the serial port
04AE            249   SendString:
04AE E4         250       clr A
04AF 93         251       movc A, @A+DPTR
04B0 6006       252       jz SendStringDone
04B2 1204A6     253       lcall putchar
04B5 A3         254       inc DPTR
04B6 80F6       255       sjmp SendString
04B8            256   SendStringDone:
04B8 22         257       ret
04B9            258   
04B9            259   ; Sends binary data to Python via putchar
04B9            260   SendBin:                                         
04B9 E4         261            clr A                                   ; Sends temp_out
04BA E547       262            mov a, temp_mc+0
04BC 1204A6     263            lcall putchar
04BF E4         264            clr A
04C0 E548       265            mov a, temp_mc+1
04C2 1204A6     266            lcall putchar
04C5 E4         267            clr A
04C6 E549       268            mov a, temp_mc+2
04C8 1204A6     269            lcall putchar
04CB E4         270            clr A
04CC E54A       271            mov a, temp_mc+3
04CE 1204A6     272            lcall putchar
04D1            273   
04D1 E4         274            clr A                                   ; Sends data_out
04D2 E538       275            mov a, data_out 
04D4 1204A6     276            lcall putchar
04D7 22         277            ret
04D8            278   
04D8            279   ASCII_CHAR: 
04D8 30313233   280            db '0123456789ABCDEF'
     34353637
     38394142
     43444546
04E8            281   
04E8            282   Hello_World:
04E8 48656C6C   283       DB  'Hello, World!', '\r', '\n', 0
     6F2C2057
     6F726C64
     210D0A00
04F8            284   New_Line:
04F8 0D0A00     285            DB '\r', '\n', 0
04FB            286   
04FB            287   ; /* 1ms DELAY FUNCTIONS */
04FB            288   wait_1ms:
04FB C28C       289            clr     TR0 ; Stop timer 0
04FD C28D       290            clr     TF0 ; Clear overflow flag
04FF 758CBF     291            mov     TH0, #high(TIMER0_RELOAD_1MS)
0502 758A28     292            mov     TL0,#low(TIMER0_RELOAD_1MS)
0505 D28C       293            setb TR0
0507 308DFD     294            jnb     TF0, $ ; Wait for overflow
050A 22         295            ret
050B            296   waitms:
050B 1204FB     297            lcall wait_1ms
050E DAFB       298            djnz R2, waitms
0510 22         299            ret
0511            300   
0511            301   Display_formated_BCD: ;4 dig 
0511 C0E0       302            push acc
0513 7401       302            mov a, #1
0515 14         302            dec a
0516 120118     302            lcall ?Set_Cursor_1 ; Select column and row
0519 D0E0       302            pop acc
051B C083       303            push dph
051D C082       303            push dpl
051F C0E0       303            push acc
0521 90004B     303            mov dptr, #cel_message
0524 12010B     303            lcall ?Send_Constant_String
0527 D0E0       303            pop acc
0529 D082       303            pop dpl
052B D083       303            pop dph
052D C0E0       304            push acc
052F 7407       304            mov a, #7
0531 14         304            dec a
0532 120116     304            lcall ?Set_Cursor_2 ; Select column and row
0535 D0E0       304            pop acc
0537            304   
0537 C000       305            push ar0
0539 A83B       305            mov r0, bcd+2
053B 12011D     305            lcall ?Display_BCD
053E D000       305            pop ar0
0540 C0E0       306            push acc
0542 7409       306            mov a, #9
0544 14         306            dec a
0545 120116     306            lcall ?Set_Cursor_2 ; Select column and row
0548 D0E0       306            pop acc
054A C000       307            push ar0
054C A83A       307            mov r0, bcd+1
054E 12011D     307            lcall ?Display_BCD
0551 D000       307            pop ar0
0553 C0E0       308            push acc
0555 740A       308            mov a, #10
0557 14         308            dec a
0558 120116     308            lcall ?Set_Cursor_2 ; Select column and row
055B D0E0       308            pop acc
055D C000       309            push ar0
055F A83A       309            mov r0, bcd+1
0561 12011D     309            lcall ?Display_BCD
0564 D000       309            pop ar0
0566            310            
0566 C0E0       311            push acc
0568 740C       311            mov a, #12
056A 14         311            dec a
056B 120116     311            lcall ?Set_Cursor_2 ; Select column and row
056E D0E0       311            pop acc
0570 C000       312            push ar0
0572 A839       312            mov r0, bcd+0
0574 12011D     312            lcall ?Display_BCD
0577 D000       312            pop ar0
0579 C0E0       313            push acc
057B 740A       313            mov a, #10
057D 14         313            dec a
057E 120116     313            lcall ?Set_Cursor_2 ; Select column and row
0581 D0E0       313            pop acc
0583 C0E0       314            push acc
0585 742E       314            mov a, #'.'
0587 1200CE     314            lcall ?WriteData
058A D0E0       314            pop acc
058C C0E0       315            push acc
058E 7407       315            mov a, #7
0590 14         315            dec a
0591 120116     315            lcall ?Set_Cursor_2 ; Select column and row
0594 D0E0       315            pop acc
0596 C0E0       316            push acc
0598 7420       316            mov a, #0x20
059A 1200CE     316            lcall ?WriteData
059D D0E0       316            pop acc
059F C0E0       317            push acc
05A1 740F       317            mov a, #15
05A3 14         317            dec a
05A4 120116     317            lcall ?Set_Cursor_2 ; Select column and row
05A7 D0E0       317            pop acc
05A9 C0E0       318            push acc
05AB 74DF       318            mov a, #0xDF
05AD 1200CE     318            lcall ?WriteData
05B0 D0E0       318            pop acc
05B2 C0E0       319            push acc
05B4 7410       319            mov a, #16
05B6 14         319            dec a
05B7 120116     319            lcall ?Set_Cursor_2 ; Select column and row
05BA D0E0       319            pop acc
05BC C0E0       320            push acc
05BE 7443       320            mov a, #'C'
05C0 1200CE     320            lcall ?WriteData
05C3 D0E0       320            pop acc
05C5            321   
05C5 22         322            ret
05C6            323   
05C6            324   ; /* READ ADC */
05C6            325   Read_ADC:
05C6 C2EF       326            clr ADCF
05C8 D2EE       327            setb ADCS ;  ADC start trigger signal
05CA 30EFFD     328       jnb ADCF, $ ; Wait for conversion complete
05CD            329       
05CD            330       ; Read the ADC result and store in [R1, R0]
05CD E5C2       331       mov a, ADCRL
05CF 540F       332       anl a, #0x0f
05D1 F8         333       mov R0, a
05D2 E5C3       334       mov a, ADCRH   
05D4 C4         335       swap a
05D5 C0E0       336       push acc
05D7 540F       337       anl a, #0x0f
05D9 F9         338       mov R1, a
05DA D0E0       339       pop acc
05DC 54F0       340       anl a, #0xf0
05DE 48         341       orl a, R0
05DF F8         342       mov R0, A
05E0 22         343            ret
05E1            344   
05E1            345   Main:
05E1 75817F     346       mov SP, #0x7F ; Set the stack pointer to the begining of idata
05E4            347       
05E4 1203B6     348       lcall InitAll
05E7 1200D8     349       lcall LCD_4BIT
05EA            350   
05EA            351            ; Initialize all variables
05EA D201       352            setb seconds_flag
05EC 754F00     353            mov FSM1_state, #0
05EF 755200     354            mov seconds, #0
05F2            355   
05F2            356       ; initial messages in LCD
05F2 C0E0       357            push acc
05F4 7401       357            mov a, #1
05F6 14         357            dec a
05F7 120118     357            lcall ?Set_Cursor_1 ; Select column and row
05FA D0E0       357            pop acc
05FC C083       358            push dph
05FE C082       358            push dpl
0600 C0E0       358            push acc
0602 90002E     358            mov dptr, #test_message
0605 12010B     358            lcall ?Send_Constant_String
0608 D0E0       358            pop acc
060A D082       358            pop dpl
060C D083       358            pop dph
060E C0E0       359            push acc
0610 7401       359            mov a, #1
0612 14         359            dec a
0613 120116     359            lcall ?Set_Cursor_2 ; Select column and row
0616 D0E0       359            pop acc
0618 C083       360            push dph
061A C082       360            push dpl
061C C0E0       360            push acc
061E 90003F     360            mov dptr, #value_message
0621 12010B     360            lcall ?Send_Constant_String
0624 D0E0       360            pop acc
0626 D082       360            pop dpl
0628 D083       360            pop dph
062A            361   
062A 753801     362            mov data_out, #0b00000001
062D            363   
062D            364   ;Forever: ;avaliable: r2, r3
062D            365   FSM_sys:
062D            366   ; /* TEMP_READ: READS TEMPERATURE */
062D            367   ; Note:     Before converting to be stored tempC, 
062D            368   ;           all values are stored as 32 bit numbers 
062D            369   ;           with 3 decimal points. (in milli-celcius)
062D            370   ;           
062D            371   ; Example:  2.07 V would be represented by the number
062D            372   ;           20700. (The real value * 1000).
062D            373   TEMP_READ:
062D 53E8F0     374       anl ADCCON0, #0xf0          ; read led voltage
0630 43E800     375       orl ADCCON0, #LED_PORT
0633 1205C6     376       lcall Read_ADC
0636 8842       377       mov VLED_ADC+0, R0          ; save reading to VLED_ADC
0638 8943       378            mov VLED_ADC+1, R1
063A            379   
063A            380   read_opamp:
063A 53E8F0     381       anl ADCCON0, #0xf0          ; *** OPAMP ***
063D 43E801     382       orl ADCCON0, #OPAMP_PORT
0640 1205C6     383       lcall Read_ADC
0643 8830       384       mov x+0, R0                              ; load opamp reading to x
0645 8931       385            mov x+1, R1
0647 753200     386            mov x+2, #0                     
064A 753300     387            mov x+3, #0
064D 753498     388            mov y+0, #low (207000 % 0x10000) 
0650 753528     388            mov y+1, #high(207000 % 0x10000) 
0653 753603     388            mov y+2, #low (207000 / 0x10000) 
0656 753700     388            mov y+3, #high(207000 / 0x10000)               ; load const vled ref into y      
0659 1202C0     389       lcall mul32
065C 854234     390       mov y+0, VLED_ADC+0              ; import vled reading into y
065F 854335     391            mov y+1, VLED_ADC+1         
0662 753600     392            mov y+2, #0                     
0665 753700     393            mov y+3, #0
0668 12034D     394       lcall div32                 ; x value stores celcius 
066B 7534E8     395            mov y+0, #low (1000 % 0x10000) 
066E 753503     395            mov y+1, #high(1000 % 0x10000) 
0671 753600     395            mov y+2, #low (1000 / 0x10000) 
0674 753700     395            mov y+3, #high(1000 / 0x10000)                 ; celcius -> milli celcius 
0677 85304B     396       mov OPAMP_temp+0, x+0       ; save calculated opamp temp (mili C)
067A 85314C     397       mov OPAMP_temp+1, x+1
067D 85324D     398       mov OPAMP_temp+2, x+2
0680 85334E     399       mov OPAMP_temp+3, x+3
0683            400   
0683            401   read_lm335:
0683 53E8F0     402       anl ADCCON0, #0xf0          ; *** LM335 ***
0686 43E805     403       orl ADCCON0, #LM335_PORT
0689 1205C6     404       lcall Read_ADC
068C 8830       405       mov x+0, R0                              ; load lm335 reading to x
068E 8931       406            mov x+1, R1
0690 753200     407            mov x+2, #0                     
0693 753300     408            mov x+3, #0
0696 753498     409            mov y+0, #low (207000 % 0x10000) 
0699 753528     409            mov y+1, #high(207000 % 0x10000) 
069C 753603     409            mov y+2, #low (207000 / 0x10000) 
069F 753700     409            mov y+3, #high(207000 / 0x10000)                ; load const vled ref into y      
06A2 1202C0     410       lcall mul32
06A5 854234     411       mov y+0, VLED_ADC+0              ; import vled reading into y
06A8 854335     412            mov y+1, VLED_ADC+1         
06AB 753600     413            mov y+2, #0                     
06AE 753700     414            mov y+3, #0
06B1 12034D     415       lcall div32
06B4 75340A     416            mov y+0, #low (10 % 0x10000) 
06B7 753500     416            mov y+1, #high(10 % 0x10000) 
06BA 753600     416            mov y+2, #low (10 / 0x10000) 
06BD 753700     416            mov y+3, #high(10 / 0x10000) 
06C0 1202C0     417       lcall mul32
06C3 753468     418            mov y+0, #low (273000 % 0x10000) 
06C6 75352A     418            mov y+1, #high(273000 % 0x10000) 
06C9 753604     418            mov y+2, #low (273000 / 0x10000) 
06CC 753700     418            mov y+3, #high(273000 / 0x10000)                            ; adjust to 273.000 C offset
06CF 12022C     419            lcall sub32                     ; result of lm335 temp remains in x
06D2            420   
06D2            421   add_lm335_to_opamp:
06D2 854B34     422       mov y+0, OPAMP_temp+0       ; load opamp temp to y
06D5 854C35     423       mov y+1, OPAMP_temp+1
06D8 854D36     424       mov y+2, OPAMP_temp+2
06DB 854E37     425       mov y+3, OPAMP_temp+3
06DE 12020B     426       lcall add32                 ; lm335 + opamp = real temp
06E1 853047     427       mov temp_mc+0, x+0          ; store result in temp_mc (for python)
06E4 853148     428       mov temp_mc+1, x+1
06E7 853249     429       mov temp_mc+2, x+2
06EA 85334A     430       mov temp_mc+3, x+3
06ED            431   
06ED            432   export_to_main:
06ED 7534E8     433            mov y+0, #low (1000 % 0x10000) 
06F0 753503     433            mov y+1, #high(1000 % 0x10000) 
06F3 753600     433            mov y+2, #low (1000 / 0x10000) 
06F6 753700     433            mov y+3, #high(1000 / 0x10000) 
06F9 12034D     434       lcall div32
06FC 853046     435       mov tempc, x+0              ; Both tempc and x now stores temp (C)
06FF            436   
06FF 120146     437            lcall hex2bcd                           ; Convert val stored in x to BCD in "bcd"
0702 120511     438            lcall Display_formated_BCD
0705 1201CF     439       lcall bcd2hex                                ; hex number now stored in x                    
0708            440   
0708            441   Export:                                                  ; Data export to python
0708 7AFA       442            mov R2, #250                            ; Wait 500 ms between conversions
070A 12050B     443            lcall waitms
070D 7AFA       444            mov R2, #250
070F 12050B     445            lcall waitms                            ; Sends binary contents of 
0712 1204B9     446       lcall SendBin                                ; temp_mc and data_out to python
0715            447   
0715            448            ; /* FSM1 STATE CHANGE CONTROLS */
0715 020718     449            ljmp FSM1
0718            450   
0718            451   ; REQUIREMENTS
0718            452   ; Start/Stop button, to do this, make routine which displays "stopped" for a little bit
0718            453   ; Temperature display, implemented already
0718            454   ; Running time display, implement in main
0718            455   ; 
0718            456   
0718            457   
0718            458   FSM1:
0718 E54F       459            mov a, FSM1_state
071A            460   
071A            461   FSM1_state0:
071A B40011     462            cjne a, #0, FSM1_state1 ; if FSM1_state (currently stored in a) is not equal to zero (ie. state zero), go to state 1
071D 755300     463            mov pwm, #0
0720 C201       464            clr seconds_flag
0722            465            ; check for push button input
0722 208406     466            jb START_BUTTON, FSM1_state0_done
0725 3084FD     467            jnb START_BUTTON, $ ; Wait for key release
0728 754F01     468            mov FSM1_state, #1
072B            469   
072B            470   FSM1_state0_done:
072B 02062D     471            ljmp FSM_sys
072E            472   
072E            473   FSM1_state1:
072E B40113     474            cjne a, #1, FSM1_state2
0731 755364     475            mov pwm, #100
0734 755200     476            mov seconds, #0
0737 7496       477            mov a, #150
0739 C3         478            clr c
073A 9546       479            subb a, tempc
073C 5003       480            jnc FSM1_state1_done
073E 754F02     481            mov FSM1_state, #2
0741            482   
0741            483   FSM1_state1_done:
0741 02062D     484            ljmp FSM_sys
0744            485   
0744            486   FSM1_state2:
0744 B4021B     487            cjne a, #2, FSM1_state3
0747 755314     488            mov pwm, #20
074A 30010A     489            jnb seconds_flag, FSM_state2_funk
074D 743C       490            mov a, #60
074F C3         491            clr c
0750 9552       492            subb a, seconds                 ; Want time to be greater than 60 seconds
0752 400B       493            jc FSM1_state2_done
0754 754F03     494            mov FSM1_state, #3
0757            495   
0757            496   FSM_state2_funk:
0757 755200     497            mov seconds, #0         ; Set seconds so we can count up to the required time 
075A D201       498            setb seconds_flag       ; seconds flag so we don't reset seconds_flag multiple times
075C 020744     499            ljmp FSM1_state2        
075F            500   
075F            501   FSM1_state2_done:
075F 02062D     502            ljmp FSM_sys
0762            503   
0762            504   FSM1_state3:
0762 B40312     505            cjne a, #3, FSM1_state4
0765 755364     506            mov pwm, #100
0768 74DC       507            mov a, #220
076A C201       508            clr seconds_flag
076C C3         509            clr c
076D 9546       510            subb a, tempc
076F 5003       511            jnc FSM1_state3_done
0771 754F04     512            mov FSM1_state, #4
0774            513   
0774            514   FSM1_state3_done:
0774 02062D     515            ljmp FSM_sys
0777            516   
0777            517   FSM1_state4:
0777 B4041B     518            cjne a, #4, FSM1_state5
077A 755314     519            mov pwm, #20 
077D 30010A     520            jnb seconds_flag, FSM1_state4_funk
0780 742D       521            mov a, #45
0782 C3         522            clr c 
0783 9552       523            subb a, seconds ; when seconds is greater than 45, there will be a carry bit
0785 400B       524            jc FSM1_state4_done
0787 754F05     525            mov FSM1_state, #5
078A            526   
078A            527   FSM1_state4_funk:
078A 755200     528            mov seconds, #0
078D D201       529            setb seconds_flag
078F 020777     530            ljmp FSM1_state4
0792            531   
0792            532   FSM1_state4_done:
0792 02062D     533            ljmp FSM_sys
0795            534   
0795            535   FSM1_state5:
0795 B40510     536            cjne a, #5, FSM1_abort_state            ; if the state is not in 0-5, then it must be 10 (aka the abort state)
0798 755300     537            mov pwm, #0
079B 743C       538            mov a, #60
079D C3         539            clr c
079E 9546       540            subb a, tempc
07A0 4003       541            jc FSM1_state5_done
07A2 754F00     542            mov FSM1_state, #0
07A5            543   
07A5            544   FSM1_state5_done:
07A5 02062D     545            ljmp FSM_sys
07A8            546   
07A8            547   FSM1_abort_state:                                                ; When the abort state is triggered, turn everything off and remain in this state utill you reset
07A8 755300     548            mov pwm, #0
07AB C0E0       549            push acc
07AD 7401       549            mov a, #1
07AF 14         549            dec a
07B0 120118     549            lcall ?Set_Cursor_1 ; Select column and row
07B3 D0E0       549            pop acc
07B5 C083       550            push dph
07B7 C082       550            push dpl
07B9 C0E0       550            push acc
07BB 90006D     550            mov dptr, #abort_message
07BE 12010B     550            lcall ?Send_Constant_String
07C1 D0E0       550            pop acc
07C3 D082       550            pop dpl
07C5 D083       550            pop dph
07C7            551   
07C7 0207A8     552            ljmp FSM1_abort_state
07CA            553   
07CA            554   END
