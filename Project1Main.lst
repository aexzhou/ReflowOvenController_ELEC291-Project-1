                  2   $LIST
0000              4   
0000              5   ;  N76E003 pinout:
0000              6   ;                               -------
0000              7   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000              8   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000              9   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             10   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             11   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             12   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             13   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             14   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             15   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             16   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             17   ;                               -------
0000             18   ;
0000             19   
0000             20   CLK                 EQU 16600000                                                 ; Microcontroller system frequency in Hz
0000             21   BAUD                EQU 115200                                                   ; Baud rate of UART in bps
0000             22   TIMER1_RELOAD       EQU (0x100-(CLK/(16*BAUD)))
0000             23   TIMER0_RELOAD_1MS   EQU (0x10000-(CLK/1000))
0000             24   TIMER2_RATE              EQU 100                                                         ; 1/100 = 10ms
0000             25   TIMER2_RELOAD            EQU (65536-(CLK/(16*TIMER2_RATE)))
0000             26   
0000             27   org 0000H
0000 0205E1      28      ljmp Main
0003             29   
0003             30   ; /* TIMER2 ENABLE */
002B             31   org 0x002B
002B 020438      32            ljmp Timer2_ISR
002E             33   
002E             34   
002E             35   ;                     1234567890123456    <- This helps determine the location of the counter
002E 2A2A2A2A    36   test_message:     db '****LOADING*****', 0
     4C4F4144
     494E472A
     2A2A2A2A
     00
003F 54454D50    37   value_message:    db 'TEMP:      ', 0
     3A202020
     20202000
004B 43454C43    38   cel_message:       db 'CELCIUS  READING',0
     49555320
     20524541
     44494E47
     00
005C 46415245    39   fah_message:      db 'FARENHET READING',0
     4E484554
     20524541
     44494E47
     00
006D 41424F52    40   abort_message:     db 'ABORTABORTABORT ', 0
     5441424F
     52544142
     4F525420
     00
007E             41   
007E             42   CSEG
007E             43   
007E             44   ; /* PORT DEFINITIONS */
007E             45   LCD_RS equ P1.3
007E             46   LCD_E  equ P1.4
007E             47   LCD_D4 equ P0.0
007E             48   LCD_D5 equ P0.1
007E             49   LCD_D6 equ P0.2
007E             50   LCD_D7 equ P0.3
007E             51   
007E             52   PWM_OUT equ P1.0
007E             53   START_BUTTON equ P0.4
007E             54   ; Analog Input Port Numbering
007E             55   LED_PORT equ 0x00                        ; AIN port numbers
007E             56   LM335_PORT equ 0x05
007E             57   OPAMP_PORT equ 0x07
007E             58   
                 60   	$LIST
0146             62   
0146             63   ; /* MATH.INC STUFFS */
0030             64   DSEG at 30H
0030             65   x:               ds 4
0034             66   y:               ds 4
0038             67   data_out:   ds 1
0039             68   
0039             69   bcd:             ds 5
003E             70   temp_out:        ds 4
0042             71   
0042             72   VLED_ADC: ds 2
0044             73   dtemp:  ds 2
0046             74   tempc: ds 1
0047             75   temp_mc:         ds 4
004B             76   OPAMP_temp: ds 4
004F             77   
004F             78   ; /* FSM STATES */
004F             79   FSM1_state:  ds 1
0050             80   
0050             81   ; /* TIME CHECK AND PWM */
0050             82   pwm_counter:     ds 1
0051             83   count10ms:               ds 1
0052             84   seconds:                 ds 1
0053             85   pwm:                     ds 1
0054             86   abort_time:              ds 1
0055             87   
0055             88   ; /* Reflow profile parameters */
0055             89   ReflowTemp:      ds 1
0056             90   ReflowTime:              ds 1
0057             91   SoakTime:                ds 1
0058             92   
0000             93   BSEG
0000             94   mf: dbit 1
0001             95   seconds_flag: dbit 1
0002             96   s_flag: dbit 1
0003             97   
0003             98   
                546   $LIST
                100   $LIST
03B6            102   
03B6            103   InitAll:
03B6            104            ; /*** SERIAL PORT INITIALIZATION ***/
03B6            105   
03B6 75AC00     106            mov     P3M1,#0x00                      ; Configure all the pins for biderectional I/O
03B9 75AD00     107            mov     P3M2,#0x00
03BC 75B300     108            mov     P1M1,#0x00
03BF 75B400     109            mov     P1M2,#0x00
03C2 75B100     110            mov     P0M1,#0x00
03C5 75B200     111            mov     P0M2,#0x00
03C8            112       ; Since the reset button bounces, we need to wait a bit before
03C8            113       ; sending messages, otherwise we risk displaying gibberish!
03C8            114       ;mov R1, #200
03C8            115       ;mov R0, #104
03C8            116       ;djnz R0, $                                  ; 4 cycles->4*60.285ns*104=25us
03C8            117       ;djnz R1, $-4                                ; 25us*200=5.0ms
03C8 7A05       118       mov R2, #5
03CA 12050B     119       lcall waitms
03CD            120       ; Now we can proceed with the configuration of the serial port
03CD 438E10     121            orl     CKCON, #0x10                    ; CLK is the input for timer 1
03D0 438780     122            orl     PCON, #0x80                     ; Bit SMOD=1, double baud rate
03D3 759852     123            mov     SCON, #0x52
03D6 53C4DF     124            anl     T3CON, #0b11011111
03D9 53890F     125            anl     TMOD, #0x0F                             ; Clear the configuration bits for timer 1
03DC 438920     126            orl     TMOD, #0x20                     ; Timer 1 Mode 2
03DF 758DF7     127            mov     TH1, #TIMER1_RELOAD
03E2 D28E       128            setb TR1
03E4            129   
03E4            130            ; /*** INITIALIZE THE REST ***/
03E4            131   
03E4 438E10     132            orl     CKCON, #0x10                    ; CLK is the input for timer 1
03E7 438780     133            orl     PCON, #0x80                     ; Bit SMOD=1, double baud rate
03EA 759852     134            mov     SCON, #0x52
03ED 53C4DF     135            anl     T3CON, #0b11011111
03F0 53890F     136            anl     TMOD, #0x0F                     ; Clear the configuration bits for timer 1
03F3 438920     137            orl     TMOD, #0x20                     ; Timer 1 Mode 2
03F6 758DF7     138            mov     TH1, #TIMER1_RELOAD     ; TH1=TIMER1_RELOAD;
03F9 D28E       139            setb TR1
03FB            140            
03FB            141            ; Using timer 0 for delay functions.  Initialize here:
03FB C28C       142            clr     TR0                                     ; Stop timer 0
03FD 438E08     143            orl     CKCON,#0x08                     ; CLK is the input for timer 0
0400 5389F0     144            anl     TMOD,#0xF0                              ; Clear the configuration bits for timer 0
0403 438901     145            orl     TMOD,#0x01                              ; Timer 0 in Mode 1: 16-bit timer
0406            146            
0406            147            ; Initialize the pin used by the ADC (P1.1) as input.
0406 43B302     148            orl     P1M1, #0b00000010
0409 53B4FD     149            anl     P1M2, #0b11111101
040C            150            
040C            151            ; Initialize and start the ADC:
040C 53E8F0     152            anl ADCCON0, #0xF0
040F 43E807     153            orl ADCCON0, #0x07                      ; Select channel 7
0412            154            ; AINDIDS select if some pins are analog inputs or digital I/O:
0412 75F600     155            mov AINDIDS, #0x00                      ; Disable all analog inputs
0415 43F680     156            orl AINDIDS, #0b10000000        ; P1.1 is analog input
0418 43E101     157            orl ADCCON1, #0x01                      ; Enable ADC
041B            158   
041B            159   ;----------------------------------------------------------------;
041B            160   ;                                        TIMER 2 INITIALIZATION
041B            161   ;----------------------------------------------------------------;
041B            162   
041B 75C800     163            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
041E 75CDD7     164            mov TH2, #high(TIMER2_RELOAD)
0421 75CC79     165            mov TL2, #low(TIMER2_RELOAD)
0424            166            ; Set the reload value
0424 75C9A0     167            mov T2MOD, #0b1010_0000 ; Enable timer 2 autoreload, and clock divider is 16
0427 75CBD7     168            mov RCMP2H, #high(TIMER2_RELOAD)
042A 75CA79     169            mov RCMP2L, #low(TIMER2_RELOAD)
042D            170            ; Init the free running 10 ms counter to zero
042D 755000     171            mov pwm_counter, #0
0430            172            ; Enable the timer and interrupts
0430 439B80     173            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0433 D2CA       174       setb TR2  ; Enable timer 2
0435            175   
0435 D2AF       176            setb EA ; Enable global interrupts
0437 22         177       ret
0438            178   
0438            179   
0438            180   ;---------------------------------;
0438            181   ; ISR for Timer 2                 ;
0438            182   ;---------------------------------;
0438            183   Timer2_ISR:
0438 C2CF       184            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
043A C0D0       185            push psw
043C C0E0       186            push acc
043E            187            
043E 0550       188            inc pwm_counter
0440 C3         189            clr c
0441 E553       190            mov a, pwm
0443 9550       191            subb a, pwm_counter ; If pwm_counter <= pwm then c=1
0445 B3         192            cpl c
0446 9290       193            mov PWM_OUT, c
0448            194            
0448 E550       195            mov a, pwm_counter
044A B46432     196            cjne a, #100, Timer2_ISR_done
044D            197            ; executes every second
044D 755000     198            mov pwm_counter, #0
0450 0552       199            inc seconds ; It is super easy to keep a seconds count here
0452 D202       200            setb s_flag
0454 E54F       201            mov a, FSM1_state
0456 B40003     202            cjne a, #0, Abort_Check0                        ; For abort check, the abort should not trigger if you are in state 0
0459 02047F     203            ljmp Timer2_ISR_done
045C            204   
045C            205   Abort_Check0:
045C            206   ; Check if temperature is above 240. If so, abort
045C C3         207            clr c
045D E546       208            mov a, tempc
045F 94F0       209            subb a, #240                                            ; if a is greater than 240, there will be no carry bit so we need to abort
0461 4006       210            jc Abort_Check1                                                 ; if temperature is below 240, continue to next check
0463            211            ; abort routine
0463 754F0A     212            mov FSM1_state, #10
0466 02047F     213       ljmp Timer2_ISR_done                ; if temp is above 240, abort condition has already been triggered, skip ahead to done
0469            214   
0469            215   Abort_Check1:
0469            216   ; Check if temperature is below 50. If so, check for how long
0469 E546       217            mov a, tempc
046B C3         218            clr c
046C 9432       219            subb a, #50                                                     ; if tempc (stored in a) is less than 50, there will be a carry bit
046E 500C       220            jnc Timer2_ISR_abort_done                       ; skip the abort checks if temperature is above 50
0470            221   
0470            222   Abort_Check2:
0470            223   ; Check if has been 60 seconds (at below 50 degrees)
0470 0554       224            inc abort_time
0472 E554       225            mov a, abort_time
0474 C3         226            clr c
0475 943C       227            subb a, #60                                                     ; if abort_time is less than 60, there will be a carry bit
0477 5006       228            jnc Timer2_ISR_done                                     ; if there is a carry 
0479 754F0A     229            mov FSM1_state, #10
047C            230   
047C            231   Timer2_ISR_abort_done:
047C 755400     232            mov abort_time, #0
047F            233   
047F            234   Timer2_ISR_done:
047F D0E0       235            pop acc
0481 D0D0       236            pop psw
0483 32         237            reti
0484            238   
0484            239   line1:
0484 50574D20   240            DB 'PWM Example     '
     4578616D
     706C6520
     20202020
0494 00         241            DB 0
0495            242   line2:
0495 43686B20   243            DB 'Chk pin 15:P1.0 '
     70696E20
     31353A50
     312E3020
04A5 00         244            DB 0
04A6            245   
04A6            246   ; /* Send a character using the serial port */
04A6            247   putchar:
04A6 3099FD     248       jnb TI, putchar
04A9 C299       249       clr TI
04AB F599       250       mov SBUF, a
04AD 22         251       ret
04AE            252   
04AE            253   ; Send a constant-zero-terminated string using the serial port
04AE            254   SendString:
04AE E4         255       clr A
04AF 93         256       movc A, @A+DPTR
04B0 6006       257       jz SendStringDone
04B2 1204A6     258       lcall putchar
04B5 A3         259       inc DPTR
04B6 80F6       260       sjmp SendString
04B8            261   SendStringDone:
04B8 22         262       ret
04B9            263   
04B9            264   ; Sends binary data to Python via putchar
04B9            265   SendBin:                                         
04B9 E4         266            clr A                                   ; Sends temp_out
04BA E547       267            mov a, temp_mc+0
04BC 1204A6     268            lcall putchar
04BF E4         269            clr A
04C0 E548       270            mov a, temp_mc+1
04C2 1204A6     271            lcall putchar
04C5 E4         272            clr A
04C6 E549       273            mov a, temp_mc+2
04C8 1204A6     274            lcall putchar
04CB E4         275            clr A
04CC E54A       276            mov a, temp_mc+3
04CE 1204A6     277            lcall putchar
04D1            278   
04D1 E4         279            clr A                                   ; Sends data_out
04D2 E538       280            mov a, data_out 
04D4 1204A6     281            lcall putchar
04D7 22         282            ret
04D8            283   
04D8            284   ASCII_CHAR: 
04D8 30313233   285            db '0123456789ABCDEF'
     34353637
     38394142
     43444546
04E8            286   
04E8            287   Hello_World:
04E8 48656C6C   288       DB  'Hello, World!', '\r', '\n', 0
     6F2C2057
     6F726C64
     210D0A00
04F8            289   New_Line:
04F8 0D0A00     290            DB '\r', '\n', 0
04FB            291   
04FB            292   ; /* 1ms DELAY FUNCTIONS */
04FB            293   wait_1ms:
04FB C28C       294            clr     TR0 ; Stop timer 0
04FD C28D       295            clr     TF0 ; Clear overflow flag
04FF 758CBF     296            mov     TH0, #high(TIMER0_RELOAD_1MS)
0502 758A28     297            mov     TL0,#low(TIMER0_RELOAD_1MS)
0505 D28C       298            setb TR0
0507 308DFD     299            jnb     TF0, $ ; Wait for overflow
050A 22         300            ret
050B            301   waitms:
050B 1204FB     302            lcall wait_1ms
050E DAFB       303            djnz R2, waitms
0510 22         304            ret
0511            305   
0511            306   Display_formated_BCD: ;4 dig 
0511 C0E0       307            push acc
0513 7401       307            mov a, #1
0515 14         307            dec a
0516 120118     307            lcall ?Set_Cursor_1 ; Select column and row
0519 D0E0       307            pop acc
051B C083       308            push dph
051D C082       308            push dpl
051F C0E0       308            push acc
0521 90004B     308            mov dptr, #cel_message
0524 12010B     308            lcall ?Send_Constant_String
0527 D0E0       308            pop acc
0529 D082       308            pop dpl
052B D083       308            pop dph
052D C0E0       309            push acc
052F 7407       309            mov a, #7
0531 14         309            dec a
0532 120116     309            lcall ?Set_Cursor_2 ; Select column and row
0535 D0E0       309            pop acc
0537            309   
0537 C000       310            push ar0
0539 A83B       310            mov r0, bcd+2
053B 12011D     310            lcall ?Display_BCD
053E D000       310            pop ar0
0540 C0E0       311            push acc
0542 7409       311            mov a, #9
0544 14         311            dec a
0545 120116     311            lcall ?Set_Cursor_2 ; Select column and row
0548 D0E0       311            pop acc
054A C000       312            push ar0
054C A83A       312            mov r0, bcd+1
054E 12011D     312            lcall ?Display_BCD
0551 D000       312            pop ar0
0553 C0E0       313            push acc
0555 740A       313            mov a, #10
0557 14         313            dec a
0558 120116     313            lcall ?Set_Cursor_2 ; Select column and row
055B D0E0       313            pop acc
055D C000       314            push ar0
055F A83A       314            mov r0, bcd+1
0561 12011D     314            lcall ?Display_BCD
0564 D000       314            pop ar0
0566            315            
0566 C0E0       316            push acc
0568 740C       316            mov a, #12
056A 14         316            dec a
056B 120116     316            lcall ?Set_Cursor_2 ; Select column and row
056E D0E0       316            pop acc
0570 C000       317            push ar0
0572 A839       317            mov r0, bcd+0
0574 12011D     317            lcall ?Display_BCD
0577 D000       317            pop ar0
0579 C0E0       318            push acc
057B 740A       318            mov a, #10
057D 14         318            dec a
057E 120116     318            lcall ?Set_Cursor_2 ; Select column and row
0581 D0E0       318            pop acc
0583 C0E0       319            push acc
0585 742E       319            mov a, #'.'
0587 1200CE     319            lcall ?WriteData
058A D0E0       319            pop acc
058C C0E0       320            push acc
058E 7407       320            mov a, #7
0590 14         320            dec a
0591 120116     320            lcall ?Set_Cursor_2 ; Select column and row
0594 D0E0       320            pop acc
0596 C0E0       321            push acc
0598 7420       321            mov a, #0x20
059A 1200CE     321            lcall ?WriteData
059D D0E0       321            pop acc
059F C0E0       322            push acc
05A1 740F       322            mov a, #15
05A3 14         322            dec a
05A4 120116     322            lcall ?Set_Cursor_2 ; Select column and row
05A7 D0E0       322            pop acc
05A9 C0E0       323            push acc
05AB 74DF       323            mov a, #0xDF
05AD 1200CE     323            lcall ?WriteData
05B0 D0E0       323            pop acc
05B2 C0E0       324            push acc
05B4 7410       324            mov a, #16
05B6 14         324            dec a
05B7 120116     324            lcall ?Set_Cursor_2 ; Select column and row
05BA D0E0       324            pop acc
05BC C0E0       325            push acc
05BE 7443       325            mov a, #'C'
05C0 1200CE     325            lcall ?WriteData
05C3 D0E0       325            pop acc
05C5            326   
05C5 22         327            ret
05C6            328   
05C6            329   ; /* READ ADC */
05C6            330   Read_ADC:
05C6 C2EF       331            clr ADCF
05C8 D2EE       332            setb ADCS ;  ADC start trigger signal
05CA 30EFFD     333       jnb ADCF, $ ; Wait for conversion complete
05CD            334       
05CD            335       ; Read the ADC result and store in [R1, R0]
05CD E5C2       336       mov a, ADCRL
05CF 540F       337       anl a, #0x0f
05D1 F8         338       mov R0, a
05D2 E5C3       339       mov a, ADCRH   
05D4 C4         340       swap a
05D5 C0E0       341       push acc
05D7 540F       342       anl a, #0x0f
05D9 F9         343       mov R1, a
05DA D0E0       344       pop acc
05DC 54F0       345       anl a, #0xf0
05DE 48         346       orl a, R0
05DF F8         347       mov R0, A
05E0 22         348            ret
05E1            349   
05E1            350   Main:
05E1 75817F     351       mov SP, #0x7F ; Set the stack pointer to the begining of idata
05E4            352       
05E4 1203B6     353       lcall InitAll
05E7 1200D8     354       lcall LCD_4BIT
05EA            355   
05EA            356            ; Initialize all variables
05EA D201       357            setb seconds_flag
05EC 754F00     358            mov FSM1_state, #0
05EF 755200     359            mov seconds, #0
05F2 755500     360            mov ReflowTemp, #0
05F5 755600     361            mov ReflowTime, #0
05F8 755700     362            mov SoakTime, #0
05FB            363   
05FB            364       ; initial messages in LCD
05FB C0E0       365            push acc
05FD 7401       365            mov a, #1
05FF 14         365            dec a
0600 120118     365            lcall ?Set_Cursor_1 ; Select column and row
0603 D0E0       365            pop acc
0605 C083       366            push dph
0607 C082       366            push dpl
0609 C0E0       366            push acc
060B 90002E     366            mov dptr, #test_message
060E 12010B     366            lcall ?Send_Constant_String
0611 D0E0       366            pop acc
0613 D082       366            pop dpl
0615 D083       366            pop dph
0617 C0E0       367            push acc
0619 7401       367            mov a, #1
061B 14         367            dec a
061C 120116     367            lcall ?Set_Cursor_2 ; Select column and row
061F D0E0       367            pop acc
0621 C083       368            push dph
0623 C082       368            push dpl
0625 C0E0       368            push acc
0627 90003F     368            mov dptr, #value_message
062A 12010B     368            lcall ?Send_Constant_String
062D D0E0       368            pop acc
062F D082       368            pop dpl
0631 D083       368            pop dph
0633            369   
0633 753801     370            mov data_out, #0b00000001
0636            371   
0636            372   ;Forever: ;avaliable: r2, r3
0636            373   FSM_sys:
0636            374   ; /* TEMP_READ: READS TEMPERATURE */
0636            375   ; Note:     Before converting to be stored tempC, 
0636            376   ;           all values are stored as 32 bit numbers 
0636            377   ;           with 3 decimal points. (in milli-celcius)
0636            378   ;           
0636            379   ; Example:  2.07 V would be represented by the number
0636            380   ;           20700. (The real value * 1000).
0636            381   TEMP_READ:
0636 020669     382            ljmp read_led
0639            383   
0639            384   Avg_ADC:
0639 753000     385            mov x+0, #low (0 % 0x10000) 
063C 753100     385            mov x+1, #high(0 % 0x10000) 
063F 753200     385            mov x+2, #low (0 / 0x10000) 
0642 753300     385            mov x+3, #high(0 / 0x10000) 
0645 7D64       386       mov R5, #100
0647            387   sum_loop_avg:
0647 1205C6     388       lcall Read_ADC
064A 753700     389       mov y+3, #0
064D 753600     390       mov y+2, #0
0650 8935       391       mov y+1, R1
0652 8834       392       mov y+0, R0
0654 12020B     393       lcall add32
0657 DDEE       394       djnz R5, sum_loop_avg
0659 753400     395            mov y+0, #low (0 % 0x10000) 
065C 753500     395            mov y+1, #high(0 % 0x10000) 
065F 753600     395            mov y+2, #low (0 / 0x10000) 
0662 753700     395            mov y+3, #high(0 / 0x10000) 
0665 12034D     396       lcall div32
0668 22         397       ret
0669            398   
0669            399   read_led:
0669 53E8F0     400       anl ADCCON0, #0xf0          ; read led voltage
066C 43E800     401       orl ADCCON0, #LED_PORT
066F 1205C6     402       lcall Read_ADC
0672 8842       403       mov VLED_ADC+0, R0          ; save reading to VLED_ADC
0674 8943       404            mov VLED_ADC+1, R1
0676            405   
0676            406   read_opamp:
0676 53E8F0     407       anl ADCCON0, #0xf0          ; *** OPAMP ***
0679 43E807     408       orl ADCCON0, #OPAMP_PORT
067C 1205C6     409       lcall Read_ADC
067F 8830       410       mov x+0, R0                              ; load opamp reading to x
0681 8931       411            mov x+1, R1
0683 753200     412            mov x+2, #0                     
0686 753300     413            mov x+3, #0
0689 753498     414            mov y+0, #low (207000 % 0x10000) 
068C 753528     414            mov y+1, #high(207000 % 0x10000) 
068F 753603     414            mov y+2, #low (207000 / 0x10000) 
0692 753700     414            mov y+3, #high(207000 / 0x10000)               ; load const vled ref into y      
0695 1202C0     415       lcall mul32
0698 854234     416       mov y+0, VLED_ADC+0              ; import vled reading into y
069B 854335     417            mov y+1, VLED_ADC+1         
069E 753600     418            mov y+2, #0                     
06A1 753700     419            mov y+3, #0
06A4 12034D     420       lcall div32                 ; x value stores celcius 
06A7 7534E8     421            mov y+0, #low (1000 % 0x10000) 
06AA 753503     421            mov y+1, #high(1000 % 0x10000) 
06AD 753600     421            mov y+2, #low (1000 / 0x10000) 
06B0 753700     421            mov y+3, #high(1000 / 0x10000)                 ; celcius -> milli celcius 
06B3 85304B     422       mov OPAMP_temp+0, x+0       ; save calculated opamp temp (mili C)
06B6 85314C     423       mov OPAMP_temp+1, x+1
06B9 85324D     424       mov OPAMP_temp+2, x+2
06BC 85334E     425       mov OPAMP_temp+3, x+3
06BF            426   
06BF            427   read_lm335:
06BF 53E8F0     428       anl ADCCON0, #0xf0          ; *** LM335 ***
06C2 43E805     429       orl ADCCON0, #LM335_PORT
06C5 1205C6     430       lcall Read_ADC
06C8 8830       431       mov x+0, R0                              ; load lm335 reading to x
06CA 8931       432            mov x+1, R1
06CC 753200     433            mov x+2, #0                     
06CF 753300     434            mov x+3, #0
06D2 753498     435            mov y+0, #low (207000 % 0x10000) 
06D5 753528     435            mov y+1, #high(207000 % 0x10000) 
06D8 753603     435            mov y+2, #low (207000 / 0x10000) 
06DB 753700     435            mov y+3, #high(207000 / 0x10000)                ; load const vled ref into y      
06DE 1202C0     436       lcall mul32
06E1 854234     437       mov y+0, VLED_ADC+0              ; import vled reading into y
06E4 854335     438            mov y+1, VLED_ADC+1         
06E7 753600     439            mov y+2, #0                     
06EA 753700     440            mov y+3, #0
06ED 12034D     441       lcall div32
06F0 75340A     442            mov y+0, #low (10 % 0x10000) 
06F3 753500     442            mov y+1, #high(10 % 0x10000) 
06F6 753600     442            mov y+2, #low (10 / 0x10000) 
06F9 753700     442            mov y+3, #high(10 / 0x10000) 
06FC 1202C0     443       lcall mul32
06FF 753411     444            mov y+0, #low (273 % 0x10000) 
0702 753501     444            mov y+1, #high(273 % 0x10000) 
0705 753600     444            mov y+2, #low (273 / 0x10000) 
0708 753700     444            mov y+3, #high(273 / 0x10000)                       ; adjust to 273.000 C offset
070B 12022C     445            lcall sub32                     ; result of lm335 temp remains in x
070E            446   
070E            447   add_lm335_to_opamp:
070E 854B34     448       mov y+0, OPAMP_temp+0       ; load opamp temp to y
0711 854C35     449       mov y+1, OPAMP_temp+1
0714 854D36     450       mov y+2, OPAMP_temp+2
0717 854E37     451       mov y+3, OPAMP_temp+3
071A            452       ;lcall add32                 ; lm335 + opamp = real temp
071A 853047     453       mov temp_mc+0, x+0          ; store result in temp_mc (for python)
071D 853148     454       mov temp_mc+1, x+1
0720 853249     455       mov temp_mc+2, x+2
0723 85334A     456       mov temp_mc+3, x+3
0726            457   
0726            458   export_to_main:
0726 7534E8     459            mov y+0, #low (1000 % 0x10000) 
0729 753503     459            mov y+1, #high(1000 % 0x10000) 
072C 753600     459            mov y+2, #low (1000 / 0x10000) 
072F 753700     459            mov y+3, #high(1000 / 0x10000) 
0732 12034D     460       lcall div32
0735 853046     461       mov tempc, x+0              ; Both tempc and x now stores temp (C)
0738            462   
0738 120146     463            lcall hex2bcd                           ; Convert val stored in x to BCD in "bcd"
073B 120511     464            lcall Display_formated_BCD
073E 1201CF     465       lcall bcd2hex                                ; hex number now stored in x                    
0741            466   
0741            467   Export:                                                  ; Data export to python
0741 7AFA       468            mov R2, #250                            ; Wait 500 ms between conversions
0743 12050B     469            lcall waitms
0746 7AFA       470            mov R2, #250
0748 12050B     471            lcall waitms                            ; Sends binary contents of 
074B 1204B9     472       lcall SendBin                                ; temp_mc and data_out to python
074E            473   
074E            474            ; /* FSM1 STATE CHANGE CONTROLS */
074E 020751     475            ljmp FSM1
0751            476   
0751            477   ; REQUIREMENTS
0751            478   ; Start/Stop button, to do this, make routine which displays "stopped" for a little bit
0751            479   ; Temperature display, implemented already
0751            480   ; Running time display, implement in main
0751            481   ; 
0751            482   
0751            483   
0751            484   FSM1:
0751 E54F       485            mov a, FSM1_state
0753            486   
0753            487   FSM1_state0:
0753 B40011     488            cjne a, #0, FSM1_state1 ; if FSM1_state (currently stored in a) is not equal to zero (ie. state zero), go to state 1
0756 755300     489            mov pwm, #0
0759 C201       490            clr seconds_flag
075B            491            ; check for push button input
075B 208406     492            jb START_BUTTON, FSM1_state0_done
075E 3084FD     493            jnb START_BUTTON, $ ; Wait for key release
0761 754F01     494            mov FSM1_state, #1
0764            495   
0764            496   FSM1_state0_done:
0764 020636     497            ljmp FSM_sys
0767            498   
0767            499   FSM1_state1:
0767 B40113     500            cjne a, #1, FSM1_state2
076A 755364     501            mov pwm, #100
076D 755200     502            mov seconds, #0
0770 7496       503            mov a, #150
0772 C3         504            clr c
0773 9546       505            subb a, tempc
0775 5003       506            jnc FSM1_state1_done
0777 754F02     507            mov FSM1_state, #2
077A            508   
077A            509   FSM1_state1_done:
077A 020636     510            ljmp FSM_sys
077D            511   
077D            512   FSM1_state2:
077D B4021B     513            cjne a, #2, FSM1_state3
0780 755314     514            mov pwm, #20
0783 30010A     515            jnb seconds_flag, FSM_state2_funk
0786            516            ;mov a, #60
0786 E557       517            mov a, SoakTime
0788 C3         518            clr c
0789 9552       519            subb a, seconds                 ; Want time to be greater than 60 seconds
078B 400B       520            jc FSM1_state2_done
078D 754F03     521            mov FSM1_state, #3
0790            522   
0790            523   FSM_state2_funk:
0790 755200     524            mov seconds, #0         ; Set seconds so we can count up to the required time 
0793 D201       525            setb seconds_flag       ; seconds flag so we don't reset seconds_flag multiple times
0795 02077D     526            ljmp FSM1_state2        
0798            527   
0798            528   FSM1_state2_done:
0798 020636     529            ljmp FSM_sys
079B            530   
079B            531   FSM1_state3:
079B B40312     532            cjne a, #3, FSM1_state4
079E 755364     533            mov pwm, #100
07A1            534            ;mov a, #220
07A1 E555       535            mov a, ReflowTemp
07A3 C201       536            clr seconds_flag
07A5 C3         537            clr c
07A6 9546       538            subb a, tempc
07A8 5003       539            jnc FSM1_state3_done
07AA 754F04     540            mov FSM1_state, #4
07AD            541   
07AD            542   FSM1_state3_done:
07AD 020636     543            ljmp FSM_sys
07B0            544   
07B0            545   FSM1_state4:
07B0 B4041B     546            cjne a, #4, FSM1_state5
07B3 755314     547            mov pwm, #20 
07B6 30010A     548            jnb seconds_flag, FSM1_state4_funk
07B9            549            ;mov a, #45
07B9 E556       550            mov a, ReflowTime
07BB C3         551            clr c 
07BC 9552       552            subb a, seconds ; when seconds is greater than 45, there will be a carry bit
07BE 400B       553            jc FSM1_state4_done
07C0 754F05     554            mov FSM1_state, #5
07C3            555   
07C3            556   FSM1_state4_funk:
07C3 755200     557            mov seconds, #0
07C6 D201       558            setb seconds_flag
07C8 0207B0     559            ljmp FSM1_state4
07CB            560   
07CB            561   FSM1_state4_done:
07CB 020636     562            ljmp FSM_sys
07CE            563   
07CE            564   FSM1_state5:
07CE B40510     565            cjne a, #5, FSM1_abort_state            ; if the state is not in 0-5, then it must be 10 (aka the abort state)
07D1 755300     566            mov pwm, #0
07D4 743C       567            mov a, #60
07D6 C3         568            clr c
07D7 9546       569            subb a, tempc
07D9 4003       570            jc FSM1_state5_done
07DB 754F00     571            mov FSM1_state, #0
07DE            572   
07DE            573   FSM1_state5_done:
07DE 020636     574            ljmp FSM_sys
07E1            575   
07E1            576   FSM1_abort_state:                                                ; When the abort state is triggered, turn everything off and remain in this state utill you reset
07E1 755300     577            mov pwm, #0
07E4 C0E0       578            push acc
07E6 7401       578            mov a, #1
07E8 14         578            dec a
07E9 120118     578            lcall ?Set_Cursor_1 ; Select column and row
07EC D0E0       578            pop acc
07EE C083       579            push dph
07F0 C082       579            push dpl
07F2 C0E0       579            push acc
07F4 90006D     579            mov dptr, #abort_message
07F7 12010B     579            lcall ?Send_Constant_String
07FA D0E0       579            pop acc
07FC D082       579            pop dpl
07FE D083       579            pop dph
0800            580   
0800 0207E1     581            ljmp FSM1_abort_state
0803            582   
0803            583   END
