                  2   $LIST
0000              4   
0000              5   ;  N76E003 pinout:
0000              6   ;                               -------
0000              7   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000              8   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000              9   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             10   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             11   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             12   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             13   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             14   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             15   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             16   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             17   ;                               -------
0000             18   ;
0000             19   
0000             20   CLK                 EQU 16600000                                                 ; Microcontroller system frequency in Hz
0000             21   BAUD                EQU 115200                                                   ; Baud rate of UART in bps
0000             22   TIMER1_RELOAD       EQU (0x100-(CLK/(16*BAUD)))
0000             23   TIMER0_RELOAD_1MS   EQU (0x10000-(CLK/1000))
0000             24   TIMER2_RATE              EQU 100                                                         ; 1/100 = 10ms
0000             25   TIMER2_RELOAD            EQU (65536-(CLK/(16*TIMER2_RATE)))
0000             26   GAIN                             EQU 330
0000             27   V2C_DIVISOR                      EQU (330*41)
0000             28   
0000             29   ; /*** PORT DEFINITIONS ***/
0000             30   LCD_RS                   equ P1.3
0000             31   LCD_E                    equ P1.4
0000             32   LCD_D4                   equ P0.0
0000             33   LCD_D5                   equ P0.1
0000             34   LCD_D6                   equ P0.2
0000             35   LCD_D7                   equ P0.3
0000             36   PWM_OUT                  equ P1.0
0000             37   START_BUTTON     equ P0.4
0000             38   ; Analog Input Port Numbering
0000             39   LED_PORT                 equ 0x00                        ; AIN port numbers
0000             40   LM335_PORT               equ 0x05
0000             41   OPAMP_PORT               equ 0x07
0000             42   
0000             43   ; /*** VECTORS ***/
0000             44   org 0000H
0000 02390F      45            ljmp Main
0003             46   
002B             47   org 002BH                                        ; timer 2 enable
002B 023760      48            ljmp Timer2_ISR
002E             49   
3000             50   org 3000H                                        ; lookup table stored at APROM address starting 0x4000
3000             51   ;        $NOLIST
                 -1    	$include(thermodata.inc)
3000              1   ; Contains mV offset for Thermocouple
3000              2   ; Stored in APROM location: 0x3000
3000              3   thermodata:
3000 00000027     4       DW  0, 39, 79, 119, 158, 198, 238, 277, 317, 357, 397, 437, 477, 517, 557, 597 
     004F0077
     009E00C6
     00EE0115
     013D0165
     018D01B5
     01DD0205
     022D0255
3020 027D02A5     5       DW  637, 677, 718, 758, 798, 838, 879, 919, 960, 1000, 1041, 1081, 1122, 1163, 1203, 1244
     02CE02F6
     031E0346
     036F0397
     03C003E8
     04110439
     0462048B
     04B304DC
3040 0505052E     6       DW  1285, 1326, 1366, 1407, 1448, 1489, 1530, 1571, 1612, 1653, 1694, 1735, 1776, 1817, 1858, 1899
     0556057F
     05A805D1
     05FA0623
     064C0675
     069E06C7
     06F00719
     0742076B
3060 079507BE     7       DW  1941, 1982, 2023, 2064, 2106, 2147, 2188, 2230, 2271, 2312, 2354, 2395, 2436, 2478, 2519, 2561 
     07E70810
     083A0863
     088C08B6
     08DF0908
     0932095B
     098409AE
     09D70A01
3080 0A2A0A54     8       DW  2602, 2644, 2685, 2727, 2768, 2810, 2851, 2893, 2934, 2976, 3017, 3059, 3100, 3142, 3184, 3225
     0A7D0AA7
     0AD00AFA
     0B230B4D
     0B760BA0
     0BC90BF3
     0C1C0C46
     0C700C99
30A0 0CC30CEC     9       DW  3267, 3308, 3350, 3391, 3433, 3474, 3516, 3557, 3599, 3640, 3682, 3723, 3765, 3806, 3848, 3889 
     0D160D3F
     0D690D92
     0DBC0DE5
     0E0F0E38
     0E620E8B
     0EB50EDE
     0F080F31
30C0 0F5B0F84    10       DW  3931, 3972, 4013, 4055, 4096, 4138, 4179, 4220, 4262, 4303, 4344, 4385, 4427, 4468, 4509, 4550 
     0FAD0FD7
     1000102A
     1053107C
     10A610CF
     10F81121
     114B1174
     119D11C6
30E0 11EF1219    11       DW  4591, 4633, 4674, 4715, 4756, 4797, 4838, 4879, 4920, 4961, 5002, 5043, 5084, 5124, 5165, 5206
     1242126B
     129412BD
     12E6130F
     13381361
     138A13B3
     13DC1404
     142D1456
3100 147F14A8    12       DW  5247, 5288, 5328, 5369, 5410, 5450, 5491, 5532, 5572, 5613, 5653, 5694, 5735, 5775, 5815, 5856
     14D014F9
     1522154A
     1573159C
     15C415ED
     1615163E
     1667168F
     16B716E0
3120 17081731    13       DW  5896, 5937, 5977, 6017, 6058, 6098, 6138, 6179, 6219, 6259, 6299, 6339, 6380, 6420, 6460, 6500
     17591781
     17AA17D2
     17FA1823
     184B1873
     189B18C3
     18EC1914
     193C1964
3140 198C19B4    14       DW  6540, 6580, 6620, 6660, 6701, 6741, 6781, 6821, 6861, 6901, 6941, 6981, 7021, 7060, 7100, 7140
     19DC1A04
     1A2D1A55
     1A7D1AA5
     1ACD1AF5
     1B1D1B45
     1B6D1B94
     1BBC1BE4
3160 1C0C1C34    15       DW  7180, 7220, 7260, 7300, 7340, 7380, 7420, 7460, 7500, 7540, 7579, 7619, 7659, 7699, 7739, 7779
     1C5C1C84
     1CAC1CD4
     1CFC1D24
     1D4C1D74
     1D9B1DC3
     1DEB1E13
     1E3B1E63
3180 1E8B1EB3    16       DW  7819, 7859, 7899, 7939, 7979, 8019, 8059, 8099, 8138, 8178, 8218, 8258, 8298, 8338, 8378, 8418
     1EDB1F03
     1F2B1F53
     1F7B1FA3
     1FCA1FF2
     201A2042
     206A2092
     20BA20E2
31A0 210A2133    17       DW  8458, 8499, 8539, 8579, 8619, 8659, 8699, 8739, 8779, 8819, 8860, 8900, 8940, 8980, 9020, 9061
     215B2183
     21AB21D3
     21FB2223
     224B2273
     229C22C4
     22EC2314
     233C2365
31C0 238D23B5    18       DW  9101, 9141, 9181, 9222, 9262, 9302, 9343, 9383, 9423, 9464, 9504, 9545, 9585, 9626, 9666, 9707
     23DD2406
     242E2456
     247F24A7
     24CF24F8
     25202549
     2571259A
     25C225EB
31E0 2613263C    19       DW  9747, 9788, 9828, 9869, 9909, 9950, 9991, 10031, 10072, 10113, 10153, 10194, 10235, 10276, 10316, 10357 
     2664268D
     26B526DE
     2707272F
     27582781
     27A927D2
     27FB2824
     284C2875
3200 289E28C7    20       DW  10398, 10439, 10480, 10520, 10561, 10602, 10643, 10684, 10725, 10766, 10807, 10848, 10889, 10930, 10971, 11012 
     28F02918
     2941296A
     299329BC
     29E52A0E
     2A372A60
     2A892AB2
     2ADB2B04
3220 2B2D2B56    21       DW  11053, 11094, 11135, 11176, 11217, 11259, 11300, 11341, 11382, 11423, 11465, 11506, 11547, 11588, 11630, 11671
     2B7F2BA8
     2BD12BFB
     2C242C4D
     2C762C9F
     2CC92CF2
     2D1B2D44
     2D6E2D97
3240 2DC02DE9    22       DW  11712, 11753, 11795, 11836, 11877, 11919, 11960, 12001, 12043, 12084, 12126, 12167, 12209, 12250, 12291, 12333
     2E132E3C
     2E652E8F
     2EB82EE1
     2F0B2F34
     2F5E2F87
     2FB12FDA
     3003302D
3260 30563080    23       DW  12374, 12416, 12457, 12499, 12540, 12582, 12624
     30A930D3
     30FC3126
     3150
326E             24   
326E             53   ;        $List
326E             54   
326E             55   ; /*** DIRECT ACCESS VARIABLES @RAM 0x30 -> 0x7F ***/
0030             56   DSEG at 30H
0030             57   x:                       ds 4            ; for math
0034             58   y:                       ds 4
0038             59   data_out:        ds 2            ; for python
003A             60   bcd:                     ds 5            ; for display
003F             61   
003F             62   VLED_ADC:                ds 2            ; for temperature 
0041             63   dtemp:                   ds 2
0043             64   tempc:                   ds 1
0044             65   temp_mc:                 ds 4
0048             66   OPAMP_temp:      ds 4
004C             67   temp_lm:                 ds 4
0050             68   temp_offset:     ds 2
0052             69   mV_offset:       ds 2
0054             70   
0054             71   FSM1_state:      ds 1            ; fsm states
0055             72   
0055             73   pwm_counter:     ds 1            ; time check and pwm
0056             74   count10ms:               ds 1
0057             75   seconds:                 ds 1
0058             76   pwm:                     ds 1
0059             77   abort_time:              ds 1
005A             78   
005A             79   ReflowTemp:      ds 1            ; reflow profile parameters
005B             80   ReflowTime:              ds 1
005C             81   SoakTime:                ds 1
005D             82   
005D             83   Val_test:                ds 4
0061             84   Val_temp:                ds 4
0065             85   
0065             86   ; /*** SINGLE BIT VARIABLES @RAM 0x20 -> 0x2F ***/
0000             87   BSEG 
0000             88   mf:                      dbit 1
0001             89   seconds_flag:    dbit 1
0002             90   s_flag:                  dbit 1
0003             91   
0003             92   ; /*** CODE SEGMENT ***/
326E             93   CSEG
326E             94   ;                     1234567890123456    <- This helps determine the location of the counter
326E 2A2A2A2A    95   test_message:     db '****LOADING*****', 0
     4C4F4144
     494E472A
     2A2A2A2A
     00
327F 54454D50    96   value_message:    db 'TEMP:      ', 0
     3A202020
     20202000
328B 43454C43    97   cel_message:       db 'CELCIUS  READING',0
     49555320
     20524541
     44494E47
     00
329C 46415245    98   fah_message:      db 'FARENHET READING',0
     4E484554
     20524541
     44494E47
     00
32AD 41424F52    99   abort_message:     db 'ABORTABORTABORT ', 0
     5441424F
     52544142
     4F525420
     00
32BE            100   
33B3            122   $LIST
                546   $LIST
36DB             76   $LIST
                105   $LIST
36DB            107   
36DB            108   
36DB            109   InitAll:
36DB            110            ; /*** SERIAL PORT INITIALIZATION ***/
36DB 75AC00     111            mov     P3M1,#0x00                      ; Configure all the pins for biderectional I/O
36DE 75AD00     112            mov     P3M2,#0x00
36E1 75B300     113            mov     P1M1,#0x00
36E4 75B400     114            mov     P1M2,#0x00
36E7 75B100     115            mov     P0M1,#0x00
36EA 75B200     116            mov     P0M2,#0x00
36ED            117       ; Since the reset button bounces, we need to wait a bit before
36ED            118       ; sending messages, otherwise we risk displaying gibberish!
36ED            119       ;mov R1, #200
36ED            120       ;mov R0, #104
36ED            121       ;djnz R0, $                                  ; 4 cycles->4*60.285ns*104=25us
36ED            122       ;djnz R1, $-4                                ; 25us*200=5.0ms
36ED 7A05       123       mov R2, #5
36EF 123839     124       lcall waitms
36F2            125       ; Now we can proceed with the configuration of the serial port
36F2 438E10     126            orl     CKCON, #0x10                    ; CLK is the input for timer 1
36F5 438780     127            orl     PCON, #0x80                     ; Bit SMOD=1, double baud rate
36F8 759852     128            mov     SCON, #0x52
36FB 53C4DF     129            anl     T3CON, #0b11011111
36FE 53890F     130            anl     TMOD, #0x0F                             ; Clear the configuration bits for timer 1
3701 438920     131            orl     TMOD, #0x20                     ; Timer 1 Mode 2
3704 758DF7     132            mov     TH1, #TIMER1_RELOAD
3707 D28E       133            setb TR1
3709            134   
3709            135            ; /*** INITIALIZE THE REST ***/
3709 438E10     136            orl     CKCON, #0x10                    ; CLK is the input for timer 1
370C 438780     137            orl     PCON, #0x80                     ; Bit SMOD=1, double baud rate
370F 759852     138            mov     SCON, #0x52
3712 53C4DF     139            anl     T3CON, #0b11011111
3715 53890F     140            anl     TMOD, #0x0F                     ; Clear the configuration bits for timer 1
3718 438920     141            orl     TMOD, #0x20                     ; Timer 1 Mode 2
371B 758DF7     142            mov     TH1, #TIMER1_RELOAD     ; TH1=TIMER1_RELOAD;
371E D28E       143            setb TR1
3720            144            
3720            145            ; Using timer 0 for delay functions.  Initialize here:
3720 C28C       146            clr     TR0                                     ; Stop timer 0
3722 438E08     147            orl     CKCON,#0x08                     ; CLK is the input for timer 0
3725 5389F0     148            anl     TMOD,#0xF0                              ; Clear the configuration bits for timer 0
3728 438901     149            orl     TMOD,#0x01                              ; Timer 0 in Mode 1: 16-bit timer
372B            150            
372B            151            ; Initialize the pin used by the ADC (P1.1) as input.
372B 43B302     152            orl     P1M1, #0b00000010
372E 53B4FD     153            anl     P1M2, #0b11111101
3731            154            
3731            155            ; Initialize and start the ADC:
3731 53E8F0     156            anl ADCCON0, #0xF0
3734 43E807     157            orl ADCCON0, #0x07                      ; Select channel 7
3737            158            ; AINDIDS select if some pins are analog inputs or digital I/O:
3737 75F600     159            mov AINDIDS, #0x00                      ; Disable all analog inputs
373A 43F680     160            orl AINDIDS, #0b10000000        ; P1.1 is analog input
373D 43E101     161            orl ADCCON1, #0x01                      ; Enable ADC
3740 755000     162            mov temp_offset, #0x00
3743            163   
3743            164   
3743            165   ;----------------------------------------------------------------;
3743            166   ;                                        TIMER 2 INITIALIZATION
3743            167   ;----------------------------------------------------------------;
3743            168   
3743 75C800     169            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
3746 75CDD7     170            mov TH2, #high(TIMER2_RELOAD)
3749 75CC79     171            mov TL2, #low(TIMER2_RELOAD)
374C            172            ; Set the reload value
374C 75C9A0     173            mov T2MOD, #0b1010_0000 ; Enable timer 2 autoreload, and clock divider is 16
374F 75CBD7     174            mov RCMP2H, #high(TIMER2_RELOAD)
3752 75CA79     175            mov RCMP2L, #low(TIMER2_RELOAD)
3755            176            ; Init the free running 10 ms counter to zero
3755 755500     177            mov pwm_counter, #0
3758            178            ; Enable the timer and interrupts
3758 439B80     179            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
375B D2CA       180       setb TR2  ; Enable timer 2
375D            181   
375D D2AF       182            setb EA ; Enable global interrupts
375F 22         183       ret
3760            184   
3760            185   
3760            186   ;---------------------------------;
3760            187   ; ISR for Timer 2                 ;
3760            188   ;---------------------------------;
3760            189   Timer2_ISR:
3760 C2CF       190            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
3762 C0D0       191            push psw
3764 C0E0       192            push acc
3766            193            
3766 0555       194            inc pwm_counter
3768 C3         195            clr c
3769 E558       196            mov a, pwm
376B 9555       197            subb a, pwm_counter ; If pwm_counter <= pwm then c=1
376D B3         198            cpl c
376E 9290       199            mov PWM_OUT, c
3770            200            
3770 E555       201            mov a, pwm_counter
3772 B46432     202            cjne a, #100, Timer2_ISR_done
3775            203            ; executes every second
3775 755500     204            mov pwm_counter, #0
3778 0557       205            inc seconds ; It is super easy to keep a seconds count here
377A D202       206            setb s_flag
377C E554       207            mov a, FSM1_state
377E B40003     208            cjne a, #0, Abort_Check0                        ; For abort check, the abort should not trigger if you are in state 0
3781 0237A7     209            ljmp Timer2_ISR_done
3784            210   
3784            211   Abort_Check0:
3784            212   ; Check if temperature is above 240. If so, abort
3784 C3         213            clr c
3785 E543       214            mov a, tempc
3787 94F0       215            subb a, #240                                            ; if a is greater than 240, there will be no carry bit so we need to abort
3789 4006       216            jc Abort_Check1                                                 ; if temperature is below 240, continue to next check
378B            217            ; abort routine
378B 75540A     218            mov FSM1_state, #10
378E 0237A7     219       ljmp Timer2_ISR_done                ; if temp is above 240, abort condition has already been triggered, skip ahead to done
3791            220   
3791            221   Abort_Check1:
3791            222   ; Check if temperature is below 50. If so, check for how long
3791 E543       223            mov a, tempc
3793 C3         224            clr c
3794 9432       225            subb a, #50                                                     ; if tempc (stored in a) is less than 50, there will be a carry bit
3796 500C       226            jnc Timer2_ISR_abort_done                       ; skip the abort checks if temperature is above 50
3798            227   
3798            228   Abort_Check2:
3798            229   ; Check if has been 60 seconds (at below 50 degrees)
3798 0559       230            inc abort_time
379A E559       231            mov a, abort_time
379C C3         232            clr c
379D 943C       233            subb a, #60                                                     ; if abort_time is less than 60, there will be a carry bit
379F 5006       234            jnc Timer2_ISR_done                                     ; if there is a carry 
37A1 75540A     235            mov FSM1_state, #10
37A4            236   
37A4            237   Timer2_ISR_abort_done:
37A4 755900     238            mov abort_time, #0
37A7            239   
37A7            240   Timer2_ISR_done:
37A7 D0E0       241            pop acc
37A9 D0D0       242            pop psw
37AB 32         243            reti
37AC            244   
37AC            245   line1:
37AC 50574D20   246            DB 'PWM Example     '
     4578616D
     706C6520
     20202020
37BC 00         247            DB 0
37BD            248   line2:
37BD 43686B20   249            DB 'Chk pin 15:P1.0 '
     70696E20
     31353A50
     312E3020
37CD 00         250            DB 0
37CE            251   
37CE            252   ; /* Send a character using the serial port */
37CE            253   putchar:
37CE 3099FD     254       jnb TI, putchar
37D1 C299       255       clr TI
37D3 F599       256       mov SBUF, a
37D5 22         257       ret
37D6            258   
37D6            259   ; Send a constant-zero-terminated string using the serial port
37D6            260   SendString:
37D6 E4         261       clr A
37D7 93         262       movc A, @A+DPTR
37D8 6006       263       jz SendStringDone
37DA 1237CE     264       lcall putchar
37DD A3         265       inc DPTR
37DE 80F6       266       sjmp SendString
37E0            267   SendStringDone:
37E0 22         268       ret
37E1            269   
37E1            270   ; Sends binary data to Python via putchar
37E1            271   SendBin:                                         
37E1 E4         272            clr A                                   ; Sends temp_mc
37E2 E544       273            mov a, temp_mc+0
37E4 1237CE     274            lcall putchar
37E7 E4         275            clr A
37E8 E545       276            mov a, temp_mc+1
37EA 1237CE     277            lcall putchar
37ED E4         278            clr A
37EE E546       279            mov a, temp_mc+2
37F0 1237CE     280            lcall putchar
37F3 E4         281            clr A
37F4 E547       282            mov a, temp_mc+3
37F6 1237CE     283            lcall putchar
37F9            284   
37F9 E4         285            clr A                                   ; Sends data_out
37FA E538       286            mov a, data_out+0
37FC 1237CE     287            lcall putchar
37FF E4         288            clr A
3800 E539       289            mov a, data_out+1
3802 1237CE     290            lcall putchar
3805 22         291            ret
3806            292   
3806            293   ASCII_CHAR: 
3806 30313233   294            db '0123456789ABCDEF'
     34353637
     38394142
     43444546
3816            295   
3816            296   Hello_World:
3816 48656C6C   297       DB  'Hello, World!', '\r', '\n', 0
     6F2C2057
     6F726C64
     210D0A00
3826            298   New_Line:
3826 0D0A00     299            DB '\r', '\n', 0
3829            300   
3829            301   ; /* 1ms DELAY FUNCTIONS */
3829            302   wait_1ms:
3829 C28C       303            clr     TR0 ; Stop timer 0
382B C28D       304            clr     TF0 ; Clear overflow flag
382D 758CBF     305            mov     TH0, #high(TIMER0_RELOAD_1MS)
3830 758A28     306            mov     TL0,#low(TIMER0_RELOAD_1MS)
3833 D28C       307            setb TR0
3835 308DFD     308            jnb     TF0, $ ; Wait for overflow
3838 22         309            ret
3839            310   waitms:
3839 123829     311            lcall wait_1ms
383C DAFB       312            djnz R2, waitms
383E 22         313            ret
383F            314   
383F            315   Display_formated_BCD: ;4 dig 
383F C0E0       316            push acc
3841 7401       316            mov a, #1
3843 14         316            dec a
3844 123357     316            lcall ?Set_Cursor_1 ; Select column and row
3847 D0E0       316            pop acc
3849 C083       317            push dph
384B C082       317            push dpl
384D C0E0       317            push acc
384F 90328B     317            mov dptr, #cel_message
3852 12334A     317            lcall ?Send_Constant_String
3855 D0E0       317            pop acc
3857 D082       317            pop dpl
3859 D083       317            pop dph
385B C0E0       318            push acc
385D 7407       318            mov a, #7
385F 14         318            dec a
3860 123355     318            lcall ?Set_Cursor_2 ; Select column and row
3863 D0E0       318            pop acc
3865            318   
3865 C000       319            push ar0
3867 A83C       319            mov r0, bcd+2
3869 12335C     319            lcall ?Display_BCD
386C D000       319            pop ar0
386E C0E0       320            push acc
3870 7409       320            mov a, #9
3872 14         320            dec a
3873 123355     320            lcall ?Set_Cursor_2 ; Select column and row
3876 D0E0       320            pop acc
3878 C000       321            push ar0
387A A83B       321            mov r0, bcd+1
387C 12335C     321            lcall ?Display_BCD
387F D000       321            pop ar0
3881 C0E0       322            push acc
3883 740A       322            mov a, #10
3885 14         322            dec a
3886 123355     322            lcall ?Set_Cursor_2 ; Select column and row
3889 D0E0       322            pop acc
388B C000       323            push ar0
388D A83B       323            mov r0, bcd+1
388F 12335C     323            lcall ?Display_BCD
3892 D000       323            pop ar0
3894            324            
3894 C0E0       325            push acc
3896 740C       325            mov a, #12
3898 14         325            dec a
3899 123355     325            lcall ?Set_Cursor_2 ; Select column and row
389C D0E0       325            pop acc
389E C000       326            push ar0
38A0 A83A       326            mov r0, bcd+0
38A2 12335C     326            lcall ?Display_BCD
38A5 D000       326            pop ar0
38A7 C0E0       327            push acc
38A9 740A       327            mov a, #10
38AB 14         327            dec a
38AC 123355     327            lcall ?Set_Cursor_2 ; Select column and row
38AF D0E0       327            pop acc
38B1 C0E0       328            push acc
38B3 742E       328            mov a, #'.'
38B5 12330D     328            lcall ?WriteData
38B8 D0E0       328            pop acc
38BA C0E0       329            push acc
38BC 7407       329            mov a, #7
38BE 14         329            dec a
38BF 123355     329            lcall ?Set_Cursor_2 ; Select column and row
38C2 D0E0       329            pop acc
38C4 C0E0       330            push acc
38C6 7420       330            mov a, #0x20
38C8 12330D     330            lcall ?WriteData
38CB D0E0       330            pop acc
38CD C0E0       331            push acc
38CF 740F       331            mov a, #15
38D1 14         331            dec a
38D2 123355     331            lcall ?Set_Cursor_2 ; Select column and row
38D5 D0E0       331            pop acc
38D7 C0E0       332            push acc
38D9 74DF       332            mov a, #0xDF
38DB 12330D     332            lcall ?WriteData
38DE D0E0       332            pop acc
38E0 C0E0       333            push acc
38E2 7410       333            mov a, #16
38E4 14         333            dec a
38E5 123355     333            lcall ?Set_Cursor_2 ; Select column and row
38E8 D0E0       333            pop acc
38EA C0E0       334            push acc
38EC 7443       334            mov a, #'C'
38EE 12330D     334            lcall ?WriteData
38F1 D0E0       334            pop acc
38F3 22         335            ret
38F4            336   
38F4            337   
38F4            338   ; /* READ ADC */
38F4            339   Read_ADC:
38F4 C2EF       340            clr ADCF
38F6 D2EE       341            setb ADCS ;  ADC start trigger signal
38F8 30EFFD     342       jnb ADCF, $ ; Wait for conversion complete
38FB            343       
38FB            344       ; Read the ADC result and store in [R1, R0]
38FB E5C2       345       mov a, ADCRL
38FD 540F       346       anl a, #0x0f
38FF F8         347       mov R0, a
3900 E5C3       348       mov a, ADCRH   
3902 C4         349       swap a
3903 C0E0       350       push acc
3905 540F       351       anl a, #0x0f
3907 F9         352       mov R1, a
3908 D0E0       353       pop acc
390A 54F0       354       anl a, #0xf0
390C 48         355       orl a, R0
390D F8         356       mov R0, A
390E 22         357            ret
390F            358   
390F            359   Main:
390F 75817F     360       mov SP, #0x7F        ; Set the stack pointer to the begining of idata
3912            361       
3912 1236DB     362       lcall InitAll
3915 123317     363       lcall LCD_4BIT
3918            364   
3918            365            ; Initialize all variables
3918 D201       366            setb seconds_flag
391A 755400     367            mov FSM1_state, #0
391D 755700     368            mov seconds, #0
3920 755A00     369            mov ReflowTemp, #0
3923 755B00     370            mov ReflowTime, #0
3926 755C00     371            mov SoakTime, #0
3929            372   
3929            373       ; initial messages in LCD
3929 C0E0       374            push acc
392B 7401       374            mov a, #1
392D 14         374            dec a
392E 123357     374            lcall ?Set_Cursor_1 ; Select column and row
3931 D0E0       374            pop acc
3933 C083       375            push dph
3935 C082       375            push dpl
3937 C0E0       375            push acc
3939 90326E     375            mov dptr, #test_message
393C 12334A     375            lcall ?Send_Constant_String
393F D0E0       375            pop acc
3941 D082       375            pop dpl
3943 D083       375            pop dph
3945 C0E0       376            push acc
3947 7401       376            mov a, #1
3949 14         376            dec a
394A 123355     376            lcall ?Set_Cursor_2 ; Select column and row
394D D0E0       376            pop acc
394F C083       377            push dph
3951 C082       377            push dpl
3953 C0E0       377            push acc
3955 90327F     377            mov dptr, #value_message
3958 12334A     377            lcall ?Send_Constant_String
395B D0E0       377            pop acc
395D D082       377            pop dpl
395F D083       377            pop dph
3961            378   
3961            379            ;mov data_out, #0b00000001
3961            380   
3961            381   ;Forever: ;avaliable: r2, r3
3961            382   FSM_sys:
3961            383   ; /* TEMP_READ: READS TEMPERATURE */
3961            384   ; Note:     Before converting to be stored tempC, 
3961            385   ;           all values are stored as 32 bit numbers 
3961            386   ;           with 3 decimal points. (in milli-celcius)
3961            387   ;           
3961            388   ; Example:  2.07 V would be represented by the number
3961            389   ;           20700. (The real value * 1000).
3961            390   TEMP_READ:
3961 023994     391            ljmp read_led
3964            392   
3964            393   Avg_ADC:                                                 ; function for ADC noise reduction
3964 753000     394            mov x+0, #low (0 % 0x10000) 
3967 753100     394            mov x+1, #high(0 % 0x10000) 
396A 753200     394            mov x+2, #low (0 / 0x10000) 
396D 753300     394            mov x+3, #high(0 / 0x10000) 
3970 7DFF       395       mov R5, #255
3972            396   sum_loop_avg:
3972 1238F4     397       lcall Read_ADC
3975 753700     398       mov y+3, #0
3978 753600     399       mov y+2, #0
397B 8935       400       mov y+1, R1
397D 8834       401       mov y+0, R0
397F 123478     402       lcall add32
3982 DDEE       403       djnz R5, sum_loop_avg
3984 7534FF     404            mov y+0, #low (255 % 0x10000) 
3987 753500     404            mov y+1, #high(255 % 0x10000) 
398A 753600     404            mov y+2, #low (255 / 0x10000) 
398D 753700     404            mov y+3, #high(255 / 0x10000) 
3990 1235BA     405       lcall div32
3993 22         406       ret
3994            407   
3994            408   read_led:
3994 53E8F0     409       anl ADCCON0, #0xf0          ; read led voltage
3997 43E800     410       orl ADCCON0, #LED_PORT
399A 123964     411       lcall Avg_ADC
399D 883F       412       mov VLED_ADC+0, R0          ; save reading to VLED_ADC
399F 8940       413            mov VLED_ADC+1, R1
39A1            414   
39A1            415   read_lm335:
39A1 53E8F0     416       anl ADCCON0, #0xf0          ; *** LM335 ***
39A4 43E805     417       orl ADCCON0, #LM335_PORT
39A7 123964     418       lcall Avg_ADC
39AA 8830       419       mov x+0, R0                              ; load lm335 reading to x
39AC 8931       420            mov x+1, R1
39AE 753200     421            mov x+2, #0                     
39B1 753300     422            mov x+3, #0
39B4 7534E0     423            mov y+0, #low (204000 % 0x10000) 
39B7 75351C     423            mov y+1, #high(204000 % 0x10000) 
39BA 753603     423            mov y+2, #low (204000 / 0x10000) 
39BD 753700     423            mov y+3, #high(204000 / 0x10000)               ; load const vled ref into y      
39C0 12352D     424       lcall mul32
39C3 853F34     425       mov y+0, VLED_ADC+0              ; import vled reading into y
39C6 854035     426            mov y+1, VLED_ADC+1         
39C9 753600     427            mov y+2, #0                     
39CC 753700     428            mov y+3, #0
39CF 1235BA     429       lcall div32
39D2 753468     430            mov y+0, #low (273000 % 0x10000) 
39D5 75352A     430            mov y+1, #high(273000 % 0x10000) 
39D8 753604     430            mov y+2, #low (273000 / 0x10000) 
39DB 753700     430            mov y+3, #high(273000 / 0x10000)                            ; adjust to 273.000 C offset
39DE 123499     431            lcall sub32                     ; result of lm335 temp remains in x
39E1 85304C     432            mov temp_lm+0, x+0          ; store 3 decimal lm335 value for later
39E4 85314D     433       mov temp_lm+1, x+1                           
39E7 85324E     434       mov temp_lm+2, x+2
39EA 85334F     435       mov temp_lm+3, x+3
39ED            436   
39ED            437   read_opamp:
39ED 53E8F0     438            anl ADCCON0, #0xf0          ; *** OPAMP ***
39F0 43E807     439       orl ADCCON0, #OPAMP_PORT     ; GAIN = 330 
39F3 123964     440            lcall Avg_ADC
39F6 8830       441            mov x+0, R0                         ; load opamp reading to x
39F8 8931       442            mov x+1, R1
39FA 753200     443            mov x+2, #0                     
39FD 753300     444            mov x+3, #0
3A00 8838       445            mov data_out+0, R0                      
3A02 8939       446            mov data_out+1, R1
3A04 753416     447            mov y+0, #low (2070 % 0x10000) 
3A07 753508     447            mov y+1, #high(2070 % 0x10000) 
3A0A 753600     447            mov y+2, #low (2070 / 0x10000) 
3A0D 753700     447            mov y+3, #high(2070 / 0x10000)                 ; load const vled ref (2070 mV) into y      
3A10 12352D     448       lcall mul32
3A13 853F34     449       mov y+0, VLED_ADC+0              ; import led adc reading into y
3A16 854035     450            mov y+1, VLED_ADC+1         
3A19 753600     451            mov y+2, #0                     
3A1C 753700     452            mov y+3, #0
3A1F 1235BA     453       lcall div32                 ; x value now stores OPAMP V in mV
3A22 7534E8     454            mov y+0, #low (1000 % 0x10000) 
3A25 753503     454            mov y+1, #high(1000 % 0x10000) 
3A28 753600     454            mov y+2, #low (1000 / 0x10000) 
3A2B 753700     454            mov y+3, #high(1000 / 0x10000)                                  
3A2E 12352D     455            lcall mul32                                     ; turn mV to uV
3A31            456            ; mov data_out+0, x+0                   ; use for reverse checking
3A31            457            ; mov data_out+1, x+1
3A31 7534DA     458            mov y+0, #low (V2C_DIVISOR % 0x10000) 
3A34 753534     458            mov y+1, #high(V2C_DIVISOR % 0x10000) 
3A37 753600     458            mov y+2, #low (V2C_DIVISOR / 0x10000) 
3A3A 753700     458            mov y+3, #high(V2C_DIVISOR / 0x10000) 
3A3D 1235BA     459            lcall div32                                     ; deg C reading now in x
3A40 853050     460            mov temp_offset+0, x+0          ; use for reverse checking
3A43 853151     461            mov temp_offset+1, x+1
3A46            462            
3A46 7534E8     463            mov y+0, #low (1000 % 0x10000) 
3A49 753503     463            mov y+1, #high(1000 % 0x10000) 
3A4C 753600     463            mov y+2, #low (1000 / 0x10000) 
3A4F 753700     463            mov y+3, #high(1000 / 0x10000) 
3A52 12352D     464            lcall mul32                                     ; conv to mV again to add to lm335 data
3A55            465   
3A55            466   add_lm335_to_opamp:
3A55 854C34     467       mov y+0, temp_lm+0           ; load lm335 temp to y
3A58 854D35     468       mov y+1, temp_lm+1
3A5B 854E36     469       mov y+2, temp_lm+2
3A5E 854F37     470       mov y+3, temp_lm+3
3A61 123478     471       lcall add32                  ; lm335 + opamp = real temp
3A64 853044     472       mov temp_mc+0, x+0          ; store result in temp_mc (for python)
3A67 853145     473       mov temp_mc+1, x+1                           
3A6A 853246     474       mov temp_mc+2, x+2
3A6D 853347     475       mov temp_mc+3, x+3
3A70            476   
3A70 854C44     477            mov temp_mc+0, temp_lm+0
3A73 854D45     478       mov temp_mc+1, temp_lm+1                             
3A76 854E46     479       mov temp_mc+2, temp_lm+2
3A79 854F47     480       mov temp_mc+3, temp_lm+3
3A7C            481   
3A7C            482   export_to_bcd:
3A7C 1233B3     483            lcall hex2bcd                           ; Convert val stored in x to BCD in "bcd"
3A7F 12383F     484            lcall Display_formated_BCD      
3A82            485            
3A82            486   export_to_main:
3A82 854430     487            mov x+0, temp_mc+0          
3A85 854531     488       mov x+1, temp_mc+1
3A88 854632     489       mov x+2, temp_mc+2
3A8B 854733     490       mov x+3, temp_mc+3
3A8E 7534E8     491            mov y+0, #low (1000 % 0x10000) 
3A91 753503     491            mov y+1, #high(1000 % 0x10000) 
3A94 753600     491            mov y+2, #low (1000 / 0x10000) 
3A97 753700     491            mov y+3, #high(1000 / 0x10000) 
3A9A 1235BA     492       lcall div32
3A9D 853043     493       mov tempc, x+0              ; Both tempc and x now stores temp (C)           
3AA0            494   
3AA0            495   Export:                                                  ; Data export to python
3AA0 7AFA       496            mov R2, #250                            ; Wait 500 ms between conversions
3AA2 123839     497            lcall waitms
3AA5 7AFA       498            mov R2, #250
3AA7 123839     499            lcall waitms                            ; Sends binary contents of 
3AAA            500   
3AAA 1237E1     501       lcall SendBin                                ; temp_mc and data_out to python
3AAD            502   
3AAD            503            ; /* FSM1 STATE CHANGE CONTROLS */
3AAD 023AB0     504            ljmp FSM1
3AB0            505   
3AB0            506   ; REQUIREMENTS
3AB0            507   ; Start/Stop button, to do this, make routine which displays "stopped" for a little bit
3AB0            508   ; Temperature display, implemented already
3AB0            509   ; Running time display, implement in main
3AB0            510   ; 
3AB0            511   
3AB0            512   
3AB0            513   FSM1:
3AB0 E554       514            mov a, FSM1_state
3AB2            515   
3AB2            516   FSM1_state0:
3AB2 B40011     517            cjne a, #0, FSM1_state1 ; if FSM1_state (currently stored in a) is not equal to zero (ie. state zero), go to state 1
3AB5 755800     518            mov pwm, #0
3AB8 C201       519            clr seconds_flag
3ABA            520            ; check for push button input
3ABA 208406     521            jb START_BUTTON, FSM1_state0_done
3ABD 3084FD     522            jnb START_BUTTON, $ ; Wait for key release
3AC0 755401     523            mov FSM1_state, #1
3AC3            524   
3AC3            525   FSM1_state0_done:
3AC3 023961     526            ljmp FSM_sys
3AC6            527   
3AC6            528   FSM1_state1:
3AC6 B40113     529            cjne a, #1, FSM1_state2
3AC9 755864     530            mov pwm, #100
3ACC 755700     531            mov seconds, #0
3ACF 7496       532            mov a, #150
3AD1 C3         533            clr c
3AD2 9543       534            subb a, tempc
3AD4 5003       535            jnc FSM1_state1_done
3AD6 755402     536            mov FSM1_state, #2
3AD9            537   
3AD9            538   FSM1_state1_done:
3AD9 023961     539            ljmp FSM_sys
3ADC            540   
3ADC            541   FSM1_state2:
3ADC B4021B     542            cjne a, #2, FSM1_state3
3ADF 755814     543            mov pwm, #20
3AE2 30010A     544            jnb seconds_flag, FSM_state2_funk
3AE5            545            ;mov a, #60
3AE5 E55C       546            mov a, SoakTime
3AE7 C3         547            clr c
3AE8 9557       548            subb a, seconds                 ; Want time to be greater than 60 seconds
3AEA 400B       549            jc FSM1_state2_done
3AEC 755403     550            mov FSM1_state, #3
3AEF            551   
3AEF            552   FSM_state2_funk:
3AEF 755700     553            mov seconds, #0         ; Set seconds so we can count up to the required time 
3AF2 D201       554            setb seconds_flag       ; seconds flag so we don't reset seconds_flag multiple times
3AF4 023ADC     555            ljmp FSM1_state2        
3AF7            556   
3AF7            557   FSM1_state2_done:
3AF7 023961     558            ljmp FSM_sys
3AFA            559   
3AFA            560   FSM1_state3:
3AFA B40312     561            cjne a, #3, FSM1_state4
3AFD 755864     562            mov pwm, #100
3B00            563            ;mov a, #220
3B00 E55A       564            mov a, ReflowTemp
3B02 C201       565            clr seconds_flag
3B04 C3         566            clr c
3B05 9543       567            subb a, tempc
3B07 5003       568            jnc FSM1_state3_done
3B09 755404     569            mov FSM1_state, #4
3B0C            570   
3B0C            571   FSM1_state3_done:
3B0C 023961     572            ljmp FSM_sys
3B0F            573   
3B0F            574   FSM1_state4:
3B0F B4041B     575            cjne a, #4, FSM1_state5
3B12 755814     576            mov pwm, #20 
3B15 30010A     577            jnb seconds_flag, FSM1_state4_funk
3B18            578            ;mov a, #45
3B18 E55B       579            mov a, ReflowTime
3B1A C3         580            clr c 
3B1B 9557       581            subb a, seconds ; when seconds is greater than 45, there will be a carry bit
3B1D 400B       582            jc FSM1_state4_done
3B1F 755405     583            mov FSM1_state, #5
3B22            584   
3B22            585   FSM1_state4_funk:
3B22 755700     586            mov seconds, #0
3B25 D201       587            setb seconds_flag
3B27 023B0F     588            ljmp FSM1_state4
3B2A            589   
3B2A            590   FSM1_state4_done:
3B2A 023961     591            ljmp FSM_sys
3B2D            592   
3B2D            593   FSM1_state5:
3B2D B40510     594            cjne a, #5, FSM1_abort_state            ; if the state is not in 0-5, then it must be 10 (aka the abort state)
3B30 755800     595            mov pwm, #0
3B33 743C       596            mov a, #60
3B35 C3         597            clr c
3B36 9543       598            subb a, tempc
3B38 4003       599            jc FSM1_state5_done
3B3A 755400     600            mov FSM1_state, #0
3B3D            601   
3B3D            602   FSM1_state5_done:
3B3D 023961     603            ljmp FSM_sys
3B40            604   
3B40            605   FSM1_abort_state:                                                ; When the abort state is triggered, turn everything off and remain in this state utill you reset
3B40 755800     606            mov pwm, #0
3B43 C0E0       607            push acc
3B45 7401       607            mov a, #1
3B47 14         607            dec a
3B48 123357     607            lcall ?Set_Cursor_1 ; Select column and row
3B4B D0E0       607            pop acc
3B4D C083       608            push dph
3B4F C082       608            push dpl
3B51 C0E0       608            push acc
3B53 9032AD     608            mov dptr, #abort_message
3B56 12334A     608            lcall ?Send_Constant_String
3B59 D0E0       608            pop acc
3B5B D082       608            pop dpl
3B5D D083       608            pop dph
3B5F            609   
3B5F 023B40     610            ljmp FSM1_abort_state
3B62            611   
3B62            612   END
